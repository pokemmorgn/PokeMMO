// client/src/managers/ObjectManager.js - VERSION CORRIG√âE COMPL√àTE

export default class ObjectManager {
    constructor(scene) {
        this.scene = scene;
        this.objectSprites = new Map(); // ID -> sprite
        this.phaserGroups = null;
        this.isInitialized = false;
        this.isDestroyed = false; // ‚úÖ NOUVEAU: Flag de destruction
        this.networkManager = null;
        this.lastProcessedData = null; // ‚úÖ NOUVEAU: √âviter les doublons
        
        // ‚úÖ NOUVEAU: Configuration par d√©faut
        this.config = {
            enableVisualFeedback: true,
            enableClickHandling: true,
            enableHoverEffects: true,
            debugMode: true
        };
        
        console.log(`[ObjectManager] üì¶ Cr√©√© pour sc√®ne: ${scene.constructor.name}`);
    }

    // ‚úÖ CORRECTION 1: Initialisation s√©curis√©e
    initialize() {
        if (this.isInitialized || this.isDestroyed) {
            console.log(`[ObjectManager] ‚ö†Ô∏è D√©j√† initialis√© ou d√©truit`);
            return false;
        }

        console.log(`[ObjectManager] üöÄ === INITIALISATION ===`);
        console.log(`[ObjectManager] Sc√®ne: ${this.scene.constructor.name}`);

        try {
            this.setupPhaserGroups();
            this.setupEventHandlers();
            this.setupNetworkIntegration();
            
            this.isInitialized = true;
            console.log(`[ObjectManager] ‚úÖ Initialis√© avec succ√®s`);
            return true;
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur initialisation:`, error);
            return false;
        }
    }

    // ‚úÖ CORRECTION 2: Cr√©ation groupes Phaser s√©curis√©e
    setupPhaserGroups() {
        console.log(`[ObjectManager] üé≠ Cr√©ation des groupes Phaser...`);
        
        if (!this.scene || !this.scene.add) {
            throw new Error('Sc√®ne Phaser invalide');
        }

        // ‚úÖ V√©rifier si les groupes existent d√©j√†
        if (this.phaserGroups) {
            console.log(`[ObjectManager] ‚ö†Ô∏è Groupes d√©j√† cr√©√©s, nettoyage...`);
            this.cleanupPhaserGroups();
        }

        try {
            this.phaserGroups = {
                objects: this.scene.add.group({
                    name: 'ObjectManagerGroup',
                    active: true,
                    maxSize: -1
                }),
                interactions: this.scene.add.group({
                    name: 'ObjectInteractionGroup', 
                    active: true,
                    maxSize: -1
                })
            };
            
            console.log(`[ObjectManager] ‚úÖ Groupes Phaser cr√©√©s`);
            console.log(`[ObjectManager]   - objects: ${!!this.phaserGroups.objects}`);
            console.log(`[ObjectManager]   - interactions: ${!!this.phaserGroups.interactions}`);
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur cr√©ation groupes:`, error);
            throw error;
        }
    }

    // ‚úÖ CORRECTION 3: Event handlers s√©curis√©s
    setupEventHandlers() {
        console.log(`[ObjectManager] ‚öôÔ∏è Configuration handlers d'√©v√©nements...`);
        
        if (!this.scene || !this.scene.input) {
            console.warn(`[ObjectManager] ‚ö†Ô∏è Scene.input manquant, skip event handlers`);
            return;
        }

        try {
            if (this.config.enableClickHandling) {
                // ‚úÖ Click handling basique
                console.log(`[ObjectManager] üñ±Ô∏è Click handling activ√©`);
            }
            
            if (this.config.enableHoverEffects) {
                // ‚úÖ Hover effects basiques  
                console.log(`[ObjectManager] üéØ Hover effects activ√©s`);
            }
            
            console.log(`[ObjectManager] ‚úÖ Event handlers configur√©s`);
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur event handlers:`, error);
            // ‚úÖ Non-critique, continuer
        }
    }

    // ‚úÖ CORRECTION 4: Int√©gration r√©seau robuste
    setupNetworkIntegration() {
        console.log(`[ObjectManager] üåê Configuration int√©gration r√©seau...`);
        
        // ‚úÖ Recherche NetworkManager multi-sources
        const networkSources = [
            () => this.scene.networkManager,
            () => this.scene.game?.registry?.get('networkManager'),
            () => window.globalNetworkManager,
            () => window.networkManager
        ];
        
        for (const getNetwork of networkSources) {
            try {
                const network = getNetwork();
                if (network) {
                    console.log(`[ObjectManager] üéØ NetworkManager trouv√©`);
                    this.networkManager = network;
                    break;
                }
            } catch (error) {
                // ‚úÖ Ignorer les erreurs et continuer
            }
        }
        
        if (!this.networkManager) {
            console.warn(`[ObjectManager] ‚ö†Ô∏è NetworkManager non trouv√©, mode autonome`);
            console.log(`[ObjectManager] ‚úÖ Int√©gration r√©seau configur√©e (mode autonome)`);
            return;
        }
        
        console.log(`[ObjectManager] üîó NetworkManager trouv√©, configuration callbacks...`);
        
        try {
            // ‚úÖ Configurer callback pour objets de zone
            this.networkManager.onZoneObjects((data) => {
                console.log(`[ObjectManager] üì® Objets de zone re√ßus:`, data);
                this.processZoneObjects(data);
            });
            
            // ‚úÖ Demander les objets pour la zone actuelle
            const currentZone = this.networkManager.getCurrentZone();
            if (currentZone) {
                console.log(`[ObjectManager] üì§ Demande objets pour zone: ${currentZone}`);
                this.requestZoneObjects(currentZone);
            }
            
            console.log(`[ObjectManager] ‚úÖ Int√©gration r√©seau configur√©e`);
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur int√©gration r√©seau:`, error);
            // ‚úÖ Non-critique, continuer en mode autonome
        }
    }

    // ‚úÖ CORRECTION 5: Traitement objets avec d√©doublonnage
    processZoneObjects(data) {
        console.log(`[ObjectManager] üîÑ === TRAITEMENT OBJETS ZONE ===`);
        console.log(`[ObjectManager] Zone: ${data.zone}`);
        console.log(`[ObjectManager] Objets: ${data.objects?.length || 0}`);
        
        // ‚úÖ NOUVEAU: √âviter les doublons
        const dataKey = `${data.zone}_${data.objects?.length || 0}_${Date.now()}`;
        if (this.lastProcessedData === dataKey) {
            console.log(`[ObjectManager] ‚ö†Ô∏è Donn√©es d√©j√† trait√©es r√©cemment, skip`);
            return;
        }
        this.lastProcessedData = dataKey;
        
        if (!data.objects || !Array.isArray(data.objects)) {
            console.log(`[ObjectManager] ‚ö†Ô∏è Pas d'objets √† traiter`);
            return;
        }
        
        if (this.isDestroyed) {
            console.log(`[ObjectManager] ‚ö†Ô∏è Manager d√©truit, skip traitement`);
            return;
        }
        
        try {
            let created = 0;
            let updated = 0;
            
            data.objects.forEach(objectData => {
                if (this.objectSprites.has(objectData.id)) {
                    console.log(`[ObjectManager] ‚ôªÔ∏è Objet ${objectData.id} existe d√©j√†, mise √† jour`);
                    this.updateObjectSprite(objectData);
                    updated++;
                } else {
                    console.log(`[ObjectManager] üé® Cr√©ation sprite objet: ${objectData.id} (${objectData.type || 'unknown'})`);
                    this.createObjectSprite(objectData);
                    created++;
                }
            });
            
            console.log(`[ObjectManager] ‚úÖ ${data.objects.length} objets trait√©s (${created} cr√©√©s, ${updated} mis √† jour)`);
            console.log(`[ObjectManager] üìä === R√âSUM√â OBJETS ===`);
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur traitement objets:`, error);
        }
    }

    // ‚úÖ CORRECTION 6: Cr√©ation sprite s√©curis√©e
    createObjectSprite(objectData) {
        if (!this.phaserGroups || this.isDestroyed) {
            console.warn(`[ObjectManager] ‚ö†Ô∏è Groupes non disponibles pour cr√©ation sprite`);
            return null;
        }
        
        try {
            const sprite = this.createPlaceholderSprite(objectData);
            if (!sprite) {
                console.warn(`[ObjectManager] ‚ö†Ô∏è √âchec cr√©ation sprite pour objet ${objectData.id}`);
                return null;
            }
            
            // ‚úÖ Configurer le sprite
            sprite.setData('objectId', objectData.id);
            sprite.setData('objectType', objectData.type || 'unknown');
            sprite.setData('objectData', objectData);
            
            // ‚úÖ Ajouter au groupe et au cache
            this.phaserGroups.objects.add(sprite);
            this.objectSprites.set(objectData.id, sprite);
            
            console.log(`[ObjectManager] ‚úÖ Sprite cr√©√©: ${objectData.id} √† (${objectData.x}, ${objectData.y})`);
            return sprite;
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur cr√©ation sprite ${objectData.id}:`, error);
            return null;
        }
    }

    // ‚úÖ AM√âLIORATION: Cr√©ation placeholder am√©lior√©e
    createPlaceholderSprite(objectData) {
        if (!this.scene || !this.scene.add) {
            console.error(`[ObjectManager] ‚ùå Scene.add non disponible`);
            return null;
        }
        
        const type = objectData.type || 'unknown';
        console.log(`[ObjectManager] üü® Cr√©ation placeholder pour ${type}`);
        
        // ‚úÖ Couleurs par type d'objet
        const typeColors = {
            'pokeball': 0xFF0000,    // Rouge
            'item': 0x00FF00,        // Vert
            'collectible': 0x0000FF, // Bleu
            'machine': 0xFFFF00,     // Jaune
            'container': 0xFF00FF,   // Magenta
            'unknown': 0x808080      // Gris
        };
        
        const color = typeColors[type] || typeColors.unknown;
        
        try {
            // ‚úÖ Cr√©er rectangle color√©
            const sprite = this.scene.add.rectangle(
                objectData.x,
                objectData.y,
                32, // largeur
                32, // hauteur
                color,
                0.8 // alpha
            );
            
            // ‚úÖ Ajouter bordure
            sprite.setStrokeStyle(2, 0xFFFFFF);
            
            // ‚úÖ Rendre interactif si demand√©
            if (this.config.enableClickHandling) {
                sprite.setInteractive();
                sprite.on('pointerdown', () => {
                    console.log(`[ObjectManager] üñ±Ô∏è Click sur objet ${objectData.id}`);
                    this.handleObjectClick(objectData);
                });
            }
            
            return sprite;
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur cr√©ation rectangle:`, error);
            return null;
        }
    }

    // ‚úÖ NOUVEAU: Gestion click objets
    handleObjectClick(objectData) {
        console.log(`[ObjectManager] üéØ Interaction avec objet:`, objectData);
        
        // ‚úÖ TODO: Impl√©menter interaction avec objets
        if (this.networkManager && typeof this.networkManager.sendObjectInteract === 'function') {
            this.networkManager.sendObjectInteract(objectData.id, objectData.type);
        }
    }

    // ‚úÖ NOUVEAU: Mise √† jour sprite existant
    updateObjectSprite(objectData) {
        const sprite = this.objectSprites.get(objectData.id);
        if (!sprite || sprite.active === false) {
            console.warn(`[ObjectManager] ‚ö†Ô∏è Sprite ${objectData.id} non trouv√© pour mise √† jour`);
            return;
        }
        
        console.log(`[ObjectManager] üîÑ Mise √† jour sprite: ${objectData.id}`);
        
        try {
            // ‚úÖ Mettre √† jour position
            sprite.setPosition(objectData.x, objectData.y);
            
            // ‚úÖ Mettre √† jour donn√©es
            sprite.setData('objectData', objectData);
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur mise √† jour sprite ${objectData.id}:`, error);
        }
    }

    // ‚úÖ CORRECTION 7: Destruction s√©curis√©e
    destroyObjectSprite(objectId) {
        console.log(`[ObjectManager] üí• Destruction sprite: ${objectId}`);
        
        const sprite = this.objectSprites.get(objectId);
        if (!sprite) {
            console.log(`[ObjectManager] ‚ö†Ô∏è Sprite ${objectId} non trouv√©`);
            return;
        }
        
        try {
            // ‚úÖ NOUVELLE LOGIQUE: V√©rification s√©curis√©e
            if (this.phaserGroups && this.phaserGroups.objects) {
                // ‚úÖ V√©rifier si le sprite est dans le groupe avant de l'enlever
                if (this.phaserGroups.objects.contains && this.phaserGroups.objects.contains(sprite)) {
                    this.phaserGroups.objects.remove(sprite);
                    console.log(`[ObjectManager] ‚úÖ Sprite ${objectId} retir√© du groupe`);
                } else {
                    console.log(`[ObjectManager] ‚ö†Ô∏è Sprite ${objectId} pas dans le groupe`);
                }
            } else {
                console.log(`[ObjectManager] ‚ö†Ô∏è Groupe objects non disponible pour ${objectId}`);
            }
            
            // ‚úÖ D√©truire le sprite directement
            if (sprite.destroy && typeof sprite.destroy === 'function') {
                sprite.destroy();
                console.log(`[ObjectManager] ‚úÖ Sprite ${objectId} d√©truit`);
            }
            
            // ‚úÖ Nettoyer le cache
            this.objectSprites.delete(objectId);
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur destruction sprite ${objectId}:`, error);
            
            // ‚úÖ FALLBACK: Nettoyer le cache m√™me en cas d'erreur
            this.objectSprites.delete(objectId);
        }
    }

    // ‚úÖ CORRECTION 8: Nettoyage groupes s√©curis√©
    cleanupPhaserGroups() {
        console.log(`[ObjectManager] üßπ Nettoyage groupes Phaser...`);
        
        if (!this.phaserGroups) {
            console.log(`[ObjectManager] ‚ö†Ô∏è Pas de groupes √† nettoyer`);
            return;
        }
        
        try {
            // ‚úÖ Nettoyer le groupe objects
            if (this.phaserGroups.objects) {
                console.log(`[ObjectManager] üóëÔ∏è Nettoyage groupe objects (${this.phaserGroups.objects.children?.size || 0} √©l√©ments)`);
                
                if (this.phaserGroups.objects.clear) {
                    this.phaserGroups.objects.clear(true, true); // removeFromScene=true, destroyChild=true
                }
                
                if (this.phaserGroups.objects.destroy) {
                    this.phaserGroups.objects.destroy();
                }
            }
            
            // ‚úÖ Nettoyer le groupe interactions
            if (this.phaserGroups.interactions) {
                console.log(`[ObjectManager] üóëÔ∏è Nettoyage groupe interactions`);
                
                if (this.phaserGroups.interactions.clear) {
                    this.phaserGroups.interactions.clear(true, true);
                }
                
                if (this.phaserGroups.interactions.destroy) {
                    this.phaserGroups.interactions.destroy();
                }
            }
            
            console.log(`[ObjectManager] ‚úÖ Groupes nettoy√©s`);
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur nettoyage groupes:`, error);
        } finally {
            // ‚úÖ Toujours reset la r√©f√©rence
            this.phaserGroups = null;
        }
    }

    // ‚úÖ CORRECTION 9: Demande objets robuste
    requestZoneObjects(zone) {
        if (!this.networkManager) {
            console.log(`[ObjectManager] ‚ö†Ô∏è Pas de NetworkManager pour demander objets`);
            return false;
        }
        
        try {
            console.log(`[ObjectManager] üéØ NetworkManager trouv√©`);
            
            if (typeof this.networkManager.sendMessage === 'function') {
                this.networkManager.sendMessage('requestZoneObjects', { zone });
                console.log(`[ObjectManager] ‚úÖ Demande envoy√©e pour zone ${zone}`);
                return true;
            } else {
                console.log(`[ObjectManager] ‚ö†Ô∏è M√©thode sendMessage non disponible`);
                return false;
            }
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur demande objets:`, error);
            return false;
        }
    }

    // ‚úÖ CORRECTION 10: Destruction compl√®te et s√©curis√©e
    destroy() {
        console.log(`[ObjectManager] üíÄ === DESTRUCTION ===`);
        
        if (this.isDestroyed) {
            console.log(`[ObjectManager] ‚ö†Ô∏è D√©j√† d√©truit`);
            return;
        }
        
        this.isDestroyed = true;
        
        try {
            // ‚úÖ 1. D√©truire tous les sprites individuellement
            console.log(`[ObjectManager] üóëÔ∏è Destruction ${this.objectSprites.size} sprites...`);
            
            for (const [objectId, sprite] of this.objectSprites) {
                try {
                    if (sprite && sprite.active !== false) {
                        if (sprite.destroy && typeof sprite.destroy === 'function') {
                            sprite.destroy();
                        }
                    }
                } catch (error) {
                    console.warn(`[ObjectManager] ‚ö†Ô∏è Erreur destruction sprite ${objectId}:`, error);
                }
            }
            
            // ‚úÖ 2. Nettoyer le cache
            this.objectSprites.clear();
            console.log(`[ObjectManager] ‚úÖ Cache sprites nettoy√©`);
            
            // ‚úÖ 3. Nettoyer les groupes Phaser
            this.cleanupPhaserGroups();
            
            // ‚úÖ 4. Nettoyer les r√©f√©rences
            this.networkManager = null;
            this.scene = null;
            this.lastProcessedData = null;
            
            // ‚úÖ 5. Reset √©tat
            this.isInitialized = false;
            
            console.log(`[ObjectManager] ‚úÖ D√©truit`);
            
        } catch (error) {
            console.error(`[ObjectManager] ‚ùå Erreur destruction:`, error);
        }
    }

    // ‚úÖ M√âTHODES UTILITAIRES

    getObjectCount() {
        return this.objectSprites.size;
    }

    getObjectSprite(objectId) {
        return this.objectSprites.get(objectId) || null;
    }

    getAllObjects() {
        return Array.from(this.objectSprites.values());
    }

    isObjectVisible(objectId) {
        const sprite = this.objectSprites.get(objectId);
        return sprite && sprite.active && sprite.visible;
    }

    // ‚úÖ DEBUG ET MONITORING

    getDebugInfo() {
        return {
            isInitialized: this.isInitialized,
            isDestroyed: this.isDestroyed,
            objectCount: this.objectSprites.size,
            hasPhaserGroups: !!this.phaserGroups,
            hasNetworkManager: !!this.networkManager,
            sceneValid: !!(this.scene && this.scene.add),
            config: this.config,
            lastProcessedData: this.lastProcessedData
        };
    }

    debugObjectList() {
        console.log(`[ObjectManager] üìã === LISTE OBJETS DEBUG ===`);
        console.log(`Total: ${this.objectSprites.size} objets`);
        
        this.objectSprites.forEach((sprite, objectId) => {
            const objectData = sprite.getData('objectData');
            console.log(`  ${objectId}: (${sprite.x}, ${sprite.y}) - ${objectData?.type || 'unknown'} - active: ${sprite.active}`);
        });
    }
}

// ‚úÖ FONCTIONS DEBUG GLOBALES

window.debugObjectManager = function() {
    // ‚úÖ Recherche multi-sources du manager
    const managers = [
        () => window.currentScene?.objectManager,
        () => window.game?.scene?.getScenes(true)?.[0]?.objectManager,
        () => window.globalObjectManager
    ].map(getter => {
        try { return getter(); } catch { return null; }
    }).filter(Boolean);
    
    if (managers.length > 0) {
        const manager = managers[0];
        const info = manager.getDebugInfo();
        
        console.log('[ObjectManager] === INFO DEBUG ===');
        console.table({
            'Initialis√©': info.isInitialized,
            'D√©truit': info.isDestroyed,
            'Objets': info.objectCount,
            'Groupes Phaser': info.hasPhaserGroups,
            'NetworkManager': info.hasNetworkManager,
            'Sc√®ne Valide': info.sceneValid
        });
        
        console.log('[ObjectManager] Info compl√®te:', info);
        
        if (info.objectCount > 0) {
            manager.debugObjectList();
        }
        
        return info;
    } else {
        console.error('[ObjectManager] ‚ùå Manager non trouv√©');
        return null;
    }
};

window.testObjectManager = function() {
    console.log('[ObjectManager] üß™ === TEST AVEC OBJETS SIMUL√âS ===');
    
    const managers = [
        () => window.currentScene?.objectManager,
        () => window.game?.scene?.getScenes(true)?.[0]?.objectManager
    ].map(getter => {
        try { return getter(); } catch { return null; }
    }).filter(Boolean);
    
    if (managers.length === 0) {
        console.error('[ObjectManager] ‚ùå Aucun manager trouv√© pour test');
        return false;
    }
    
    const manager = managers[0];
    
    // ‚úÖ Cr√©er des objets de test
    const testObjects = [
        { id: 'test_pokeball_1', x: 100, y: 100, type: 'pokeball' },
        { id: 'test_item_1', x: 200, y: 150, type: 'item' },
        { id: 'test_machine_1', x: 300, y: 200, type: 'machine' }
    ];
    
    console.log(`[ObjectManager] üéØ Test avec ${testObjects.length} objets simul√©s`);
    
    try {
        manager.processZoneObjects({
            zone: 'test_zone',
            objects: testObjects
        });
        
        console.log('[ObjectManager] ‚úÖ Test r√©ussi !');
        console.log(`[ObjectManager] Objets cr√©√©s: ${manager.getObjectCount()}`);
        
        return true;
        
    } catch (error) {
        console.error('[ObjectManager] ‚ùå Test √©chou√©:', error);
        return false;
    }
};

console.log('‚úÖ ObjectManager corrig√© charg√©!');
console.log('üîç Utilisez window.debugObjectManager() pour diagnostiquer');
console.log('üß™ Utilisez window.testObjectManager() pour tester avec des objets simul√©s');
