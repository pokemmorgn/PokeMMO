// client/src/managers/TeamManager.js - VERSION CONTR√îL√âE PAR UIMANAGER
// üéØ UIManager devient le MA√éTRE - modules deviennent des SERVANTS ob√©issants

import { TeamUI } from '../components/TeamUI.js';
import { TeamIcon } from '../components/TeamIcon.js';

export class TeamManager {
  constructor(scene, gameRoom) {
    this.scene = scene;
    this.gameRoom = gameRoom;
    
    // === √âTAT CENTRALIS√â CONTR√îL√â PAR UIMANAGER ===
    this.uiManagerState = {
      visible: false,           // UIManager contr√¥le la visibilit√©
      enabled: false,           // UIManager contr√¥le l'√©tat
      initialized: false,       // UIManager contr√¥le l'initialisation
      controlled: true          // Marquer comme contr√¥l√© par UIManager
    };
    
    // === MODULES UI PASSIFS ===
    this.teamUI = null;
    this.teamIcon = null;
    
    // === DONN√âES BUSINESS LOGIC SEULEMENT ===
    this.teamData = [];
    this.teamStats = {
      totalPokemon: 0,
      alivePokemon: 0,
      faintedPokemon: 0,
      averageLevel: 0,
      canBattle: false
    };
    
    // === CONFIGURATION ===
    this.isUIManagerControlled = true;  // Flag important
    this.preventAutoActions = true;     // Emp√™cher les actions automatiques
    this.silentMode = false;           // Mode silencieux pour les logs
    
    console.log("‚öîÔ∏è [TeamManager] Instance cr√©√©e (UIManager-controlled)");
  }

  // ===== üéØ INITIALISATION CONTR√îL√âE PAR UIMANAGER =====
  
  async init() {
    if (this.isUIManagerControlled) {
      // En mode contr√¥l√©, on ne fait QUE la logique business
      this.log("üéØ [TeamManager] Init en mode UIManager-controlled");
      
      // Setup data logic seulement
      this.setupDataLogic();
      this.setupServerListeners();
      
      // PAS d'UI - sera cr√©√©e par UIManager via les factories
      this.uiManagerState.initialized = true;
      
      this.log("‚úÖ [TeamManager] Logique business initialis√©e");
      return this;
    }
    
    // Mode legacy (ne devrait pas √™tre utilis√©)
    return this.initLegacy();
  }

  setupDataLogic() {
    // Setup uniquement la logique de donn√©es
    this.dataUpdateHandlers = new Map();
    this.eventQueue = [];
    this.lastDataUpdate = 0;
    
    // Auto-cleanup des donn√©es anciennes
    setInterval(() => {
      this.cleanupStaleData();
    }, 60000); // 1 minute
  }

  setupServerListeners() {
    if (!this.gameRoom) {
      this.warn("‚ö†Ô∏è Pas de gameRoom pour les listeners");
      return;
    }

    try {
      // === LISTENERS PUREMENT DATA - SANS UI ===
      
      this.gameRoom.onMessage("teamData", (data) => {
        this.handleTeamDataUpdate(data);
      });

      this.gameRoom.onMessage("teamActionResult", (data) => {
        this.handleTeamActionResult(data);
      });

      this.gameRoom.onMessage("teamHealed", (data) => {
        this.handleTeamHealed(data);
      });

      this.gameRoom.onMessage("teamStats", (data) => {
        this.handleTeamStats(data);
      });
      
      this.log("‚úÖ [TeamManager] Listeners data configur√©s");
      
    } catch (error) {
      console.error("‚ùå [TeamManager] Erreur setup listeners:", error);
    }
  }

  // ===== üè≠ FACTORIES POUR UIMANAGER =====
  
  /**
   * Factory pour TeamIcon - appel√©e par UIManager
   */
  createTeamIconForUIManager() {
    this.log("üè≠ [Factory] Cr√©ation TeamIcon pour UIManager");
    
    if (this.teamIcon) {
      this.warn("‚ö†Ô∏è TeamIcon existe d√©j√† - destruction...");
      this.destroyTeamIcon();
    }

    try {
      // Cr√©er TeamIcon en mode passif
      this.teamIcon = new TeamIcon(null, {
        uiManagerControlled: true,
        preventAutoActions: true,
        silent: this.silentMode,
        dataProvider: this // TeamManager fournit les donn√©es
      });
      
      // Connecter les donn√©es sans logique UI
      this.connectTeamIconData();
      
      this.log("‚úÖ [Factory] TeamIcon cr√©√© (contr√¥l√© par UIManager)");
      return this.teamIcon;
      
    } catch (error) {
      console.error("‚ùå [Factory] Erreur cr√©ation TeamIcon:", error);
      return this.createFallbackTeamIcon();
    }
  }

  /**
   * Factory pour TeamUI - appel√©e par UIManager
   */
  createTeamUIForUIManager() {
    this.log("üè≠ [Factory] Cr√©ation TeamUI pour UIManager");
    
    if (this.teamUI) {
      this.warn("‚ö†Ô∏è TeamUI existe d√©j√† - destruction...");
      this.destroyTeamUI();
    }

    try {
      // Cr√©er TeamUI en mode passif
      this.teamUI = new TeamUI(this.gameRoom, {
        uiManagerControlled: true,
        preventAutoShow: true,
        preventAutoHide: true,
        dataProvider: this // TeamManager fournit les donn√©es
      });
      
      // Connecter les donn√©es sans logique UI
      this.connectTeamUIData();
      
      this.log("‚úÖ [Factory] TeamUI cr√©√© (contr√¥l√© par UIManager)");
      return this.teamUI;
      
    } catch (error) {
      console.error("‚ùå [Factory] Erreur cr√©ation TeamUI:", error);
      return this.createFallbackTeamUI();
    }
  }

  // ===== üîó CONNEXIONS DATA SANS LOGIQUE UI =====

  connectTeamIconData() {
    if (!this.teamIcon) return;
    
    // Fournir les donn√©es initiales
    this.teamIcon.updateTeamStats(this.teamStats);
    
    // Connecter le click handler SANS logique d'affichage
    this.teamIcon.onClickRequest = () => {
      // Demander √† UIManager d'ouvrir TeamUI
      this.requestUIManagerAction('toggleTeamUI');
    };
    
    // Connecter les updates de donn√©es
    this.on('statsUpdated', (stats) => {
      if (this.teamIcon && this.teamIcon.updateTeamStats) {
        this.teamIcon.updateTeamStats(stats);
      }
    });
  }

  connectTeamUIData() {
    if (!this.teamUI) return;
    
    // Fournir les donn√©es initiales
    this.teamUI.updateTeamData({ team: this.teamData });
    
    // Connecter les actions SANS logique d'affichage
    this.teamUI.onActionRequest = (action, data) => {
      this.handleTeamUIAction(action, data);
    };
    
    // Connecter les updates de donn√©es
    this.on('teamDataUpdated', (data) => {
      if (this.teamUI && this.teamUI.updateTeamData) {
        this.teamUI.updateTeamData(data);
      }
    });
  }

  // ===== üì° COMMUNICATION AVEC UIMANAGER =====

  requestUIManagerAction(action, data = null) {
    this.log(`üì° [Request] Demande action UIManager: ${action}`);
    
    // Notifier UIManager via √©v√©nement global
    window.dispatchEvent(new CustomEvent('teamManagerRequest', {
      detail: { action, data, source: 'teamManager' }
    }));
    
    // Fallback si UIManager n'est pas disponible
    if (!window.uiManager && !window.pokemonUISystem?.uiManager) {
      this.warn("‚ö†Ô∏è UIManager non disponible - action directe");
      this.handleDirectAction(action, data);
    }
  }

  handleDirectAction(action, data) {
    // Actions de fallback si UIManager n'est pas disponible
    switch (action) {
      case 'toggleTeamUI':
        if (this.teamUI) {
          this.teamUI.isVisible ? this.teamUI.hide() : this.teamUI.show();
        }
        break;
      case 'showTeamUI':
        if (this.teamUI) {
          this.teamUI.show();
        }
        break;
      case 'hideTeamUI':
        if (this.teamUI) {
          this.teamUI.hide();
        }
        break;
    }
  }

  handleTeamUIAction(action, data) {
    this.log(`üé¨ [Action] TeamUI action: ${action}`);
    
    switch (action) {
      case 'healTeam':
        this.healTeam();
        break;
      case 'healPokemon':
        this.healPokemon(data.pokemonId);
        break;
      case 'removePokemon':
        this.removePokemon(data.pokemonId);
        break;
      case 'swapPokemon':
        this.swapPokemon(data.fromSlot, data.toSlot);
        break;
      case 'close':
        this.requestUIManagerAction('hideTeamUI');
        break;
    }
  }

  // ===== üéõÔ∏è M√âTHODES UIMANAGER (INTERFACE PRINCIPALE) =====

  /**
   * UIManager appelle cette m√©thode pour afficher
   */
  show() {
    this.log("üëÅÔ∏è [UIManager‚ÜíTeamManager] show() appel√©e");
    
    this.uiManagerState.visible = true;
    
    // Afficher uniquement si les composants existent
    if (this.teamIcon && !this.teamIcon.isDestroyed) {
      this.teamIcon.show();
    }
    
    // TeamUI reste cach√© par d√©faut (sera affich√© sur demande)
    return true;
  }

  /**
   * UIManager appelle cette m√©thode pour cacher
   */
  hide() {
    this.log("üëª [UIManager‚ÜíTeamManager] hide() appel√©e");
    
    this.uiManagerState.visible = false;
    
    // Cacher tous les composants
    if (this.teamIcon && !this.teamIcon.isDestroyed) {
      this.teamIcon.hide();
    }
    
    if (this.teamUI && !this.teamUI.isDestroyed) {
      this.teamUI.hide();
    }
    
    return true;
  }

  /**
   * UIManager appelle cette m√©thode pour activer/d√©sactiver
   */
  setEnabled(enabled) {
    this.log(`üîß [UIManager‚ÜíTeamManager] setEnabled(${enabled}) appel√©e`);
    
    this.uiManagerState.enabled = enabled;
    
    // Appliquer aux composants
    if (this.teamIcon && !this.teamIcon.isDestroyed) {
      this.teamIcon.setEnabled(enabled);
    }
    
    if (this.teamUI && !this.teamUI.isDestroyed) {
      this.teamUI.setEnabled(enabled);
    }
    
    return true;
  }

  /**
   * UIManager appelle cette m√©thode pour obtenir l'√©tat
   */
  getUIManagerState() {
    return {
      ...this.uiManagerState,
      teamStats: this.teamStats,
      hasTeamIcon: !!this.teamIcon && !this.teamIcon.isDestroyed,
      hasTeamUI: !!this.teamUI && !this.teamUI.isDestroyed,
      canBattle: this.canBattle(),
      isTeamFull: this.isTeamFull(),
      lastUpdate: this.lastDataUpdate
    };
  }

  /**
   * UIManager appelle cette m√©thode pour destruction
   */
  destroy() {
    this.log("üßπ [UIManager‚ÜíTeamManager] destroy() appel√©e");
    
    try {
      // D√©truire les composants UI
      this.destroyTeamIcon();
      this.destroyTeamUI();
      
      // Nettoyer les donn√©es
      this.cleanupData();
      
      // Reset √©tat
      this.uiManagerState.initialized = false;
      this.uiManagerState.visible = false;
      this.uiManagerState.enabled = false;
      
      this.log("‚úÖ [TeamManager] Destruction termin√©e");
      
    } catch (error) {
      console.error("‚ùå [TeamManager] Erreur destruction:", error);
    }
  }

  // ===== üóëÔ∏è DESTRUCTION COMPOSANTS =====

  destroyTeamIcon() {
    if (this.teamIcon) {
      try {
        if (typeof this.teamIcon.destroy === 'function') {
          this.teamIcon.destroy();
        }
        this.teamIcon.isDestroyed = true;
        this.teamIcon = null;
        this.log("‚úÖ TeamIcon d√©truit");
      } catch (error) {
        console.error("‚ùå Erreur destruction TeamIcon:", error);
        this.teamIcon = null;
      }
    }
  }

  destroyTeamUI() {
    if (this.teamUI) {
      try {
        if (typeof this.teamUI.destroy === 'function') {
          this.teamUI.destroy();
        }
        this.teamUI.isDestroyed = true;
        this.teamUI = null;
        this.log("‚úÖ TeamUI d√©truit");
      } catch (error) {
        console.error("‚ùå Erreur destruction TeamUI:", error);
        this.teamUI = null;
      }
    }
  }

  cleanupData() {
    this.teamData = [];
    this.teamStats = {
      totalPokemon: 0,
      alivePokemon: 0,
      faintedPokemon: 0,
      averageLevel: 0,
      canBattle: false
    };
    this.eventQueue = [];
    this.dataUpdateHandlers.clear();
  }

  // ===== üìä GESTION DONN√âES (BUSINESS LOGIC PURE) =====

  handleTeamDataUpdate(data) {
    try {
      this.updateLocalTeamData(data);
      this.emit('teamDataUpdated', data);
      this.log("üìä Donn√©es √©quipe mises √† jour");
    } catch (error) {
      this.handleError(error, 'team_data_update');
    }
  }

  handleTeamActionResult(data) {
    try {
      // Traiter le r√©sultat d'action
      this.emit('actionResult', data);
      
      // Notifier via syst√®me global si disponible
      if (typeof window.showGameNotification === 'function') {
        window.showGameNotification(
          data.message, 
          data.success ? 'success' : 'error'
        );
      }
      
      // Rafra√Æchir les donn√©es apr√®s action
      setTimeout(() => this.requestTeamData(), 500);
      
    } catch (error) {
      this.handleError(error, 'team_action_result');
    }
  }

  handleTeamHealed(data) {
    try {
      this.emit('teamHealed', data);
      
      if (typeof window.showGameNotification === 'function') {
        window.showGameNotification('√âquipe soign√©e!', 'success');
      }
      
      // Rafra√Æchir les donn√©es
      setTimeout(() => this.requestTeamData(), 500);
      
    } catch (error) {
      this.handleError(error, 'team_healed');
    }
  }

  handleTeamStats(data) {
    try {
      this.teamStats = { ...data };
      this.emit('statsUpdated', data);
    } catch (error) {
      this.handleError(error, 'team_stats');
    }
  }

  updateLocalTeamData(data) {
    this.teamData = Array.isArray(data.team) ? data.team : [];
    this.calculateStats();
    this.lastDataUpdate = Date.now();
  }

  calculateStats() {
    this.teamStats.totalPokemon = this.teamData.length;
    this.teamStats.alivePokemon = this.teamData.filter(p => p && p.currentHp > 0).length;
    this.teamStats.faintedPokemon = this.teamData.filter(p => p && p.currentHp === 0).length;
    this.teamStats.canBattle = this.teamStats.alivePokemon > 0;
    
    if (this.teamData.length > 0) {
      const totalLevel = this.teamData.reduce((sum, p) => sum + (p?.level || 1), 0);
      this.teamStats.averageLevel = Math.round(totalLevel / this.teamData.length);
    } else {
      this.teamStats.averageLevel = 0;
    }
  }

  // ===== üé¨ ACTIONS √âQUIPE (BUSINESS LOGIC) =====

  requestTeamData() {
    if (this.gameRoom && this.canSendRequest()) {
      this.gameRoom.send("getTeam");
      this.lastTeamDataRequest = Date.now();
    }
  }

  healTeam() {
    if (this.gameRoom && this.canSendRequest()) {
      this.gameRoom.send("healTeam");
    }
  }

  healPokemon(pokemonId) {
    if (this.gameRoom && this.canSendRequest()) {
      this.gameRoom.send("healPokemon", { pokemonId });
    }
  }

  removePokemon(pokemonId) {
    if (this.gameRoom && this.canSendRequest()) {
      this.gameRoom.send("removeFromTeam", { pokemonId });
    }
  }

  swapPokemon(fromSlot, toSlot) {
    if (this.gameRoom && this.canSendRequest()) {
      this.gameRoom.send("swapTeamSlots", { slotA: fromSlot, slotB: toSlot });
    }
  }

  canSendRequest() {
    const now = Date.now();
    const timeSinceLastRequest = now - (this.lastTeamDataRequest || 0);
    return timeSinceLastRequest > 1000; // 1 seconde de cooldown
  }

  // ===== üîç GETTERS (LECTURE SEULE) =====

  getTeamData() {
    return [...this.teamData];
  }

  getTeamStats() {
    return { ...this.teamStats };
  }

  canBattle() {
    return this.teamStats.canBattle;
  }

  isTeamFull() {
    return this.teamData.length >= 6;
  }

  isTeamOpen() {
    return this.teamUI ? this.teamUI.isVisible : false;
  }

  getPokemonBySlot(slot) {
    return this.teamData[slot] || null;
  }

  getAlivePokemon() {
    return this.teamData.filter(p => p && p.currentHp > 0);
  }

  // ===== üÜò FALLBACKS =====

  createFallbackTeamIcon() {
    this.warn("üÜò Cr√©ation TeamIcon de secours");
    
    return {
      show: () => this.log("Fallback TeamIcon show"),
      hide: () => this.log("Fallback TeamIcon hide"),
      setEnabled: (enabled) => this.log(`Fallback TeamIcon enabled: ${enabled}`),
      updateTeamStats: (stats) => this.log("Fallback TeamIcon stats update"),
      destroy: () => this.log("Fallback TeamIcon destroy"),
      isDestroyed: false,
      iconElement: document.createElement('div')
    };
  }

  createFallbackTeamUI() {
    this.warn("üÜò Cr√©ation TeamUI de secours");
    
    return {
      show: () => this.log("Fallback TeamUI show"),
      hide: () => this.log("Fallback TeamUI hide"),
      setEnabled: (enabled) => this.log(`Fallback TeamUI enabled: ${enabled}`),
      updateTeamData: (data) => this.log("Fallback TeamUI data update"),
      destroy: () => this.log("Fallback TeamUI destroy"),
      isDestroyed: false,
      isVisible: false
    };
  }

  // ===== üõ†Ô∏è UTILITAIRES =====

  cleanupStaleData() {
    const now = Date.now();
    const maxAge = 5 * 60 * 1000; // 5 minutes
    
    // Nettoyer les √©v√©nements anciens
    this.eventQueue = this.eventQueue.filter(event => 
      now - event.timestamp < maxAge
    );
  }

  handleError(error, context = 'unknown') {
    console.error(`‚ùå [TeamManager:${context}]`, error);
    
    // En mode UIManager-controlled, on ne fait PAS de r√©cup√©ration automatique
    // On laisse UIManager g√©rer les erreurs
    this.emit('error', { error, context });
  }

  // ===== üì¢ SYST√àME D'√âV√âNEMENTS SIMPLE =====

  on(event, callback) {
    if (!this.eventListeners) {
      this.eventListeners = new Map();
    }
    
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, new Set());
    }
    
    this.eventListeners.get(event).add(callback);
  }

  off(event, callback) {
    if (this.eventListeners && this.eventListeners.has(event)) {
      this.eventListeners.get(event).delete(callback);
    }
  }

  emit(event, data) {
    if (this.eventListeners && this.eventListeners.has(event)) {
      this.eventListeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          this.warn(`‚ö†Ô∏è Erreur callback √©v√©nement ${event}:`, error);
        }
      });
    }
  }

  // ===== üêõ LOGGING CONTR√îL√â =====

  log(...args) {
    if (!this.silentMode) {
      console.log('[TeamManager]', ...args);
    }
  }

  warn(...args) {
    console.warn('[TeamManager]', ...args);
  }

  error(...args) {
    console.error('[TeamManager]', ...args);
  }

  // ===== üîß MODE LEGACY (NE PAS UTILISER) =====

  async initLegacy() {
    this.warn("‚ö†Ô∏è Mode legacy - utiliser UIManager √† la place");
    
    // Ancienne initialisation pour compatibilit√©
    this.teamUI = new TeamUI(this.gameRoom);
    this.teamIcon = new TeamIcon(this.teamUI);
    
    this.setupServerListeners();
    
    return this;
  }

  // ===== üéØ M√âTHODES PUBLIQUES LEGACY (D√âPR√âCI√â) =====

  toggleTeam() {
    this.warn("‚ö†Ô∏è toggleTeam() d√©pr√©ci√© - utiliser UIManager");
    this.requestUIManagerAction('toggleTeamUI');
  }

  openTeam() {
    this.warn("‚ö†Ô∏è openTeam() d√©pr√©ci√© - utiliser UIManager");
    this.requestUIManagerAction('showTeamUI');
  }

  closeTeam() {
    this.warn("‚ö†Ô∏è closeTeam() d√©pr√©ci√© - utiliser UIManager");
    this.requestUIManagerAction('hideTeamUI');
  }

  // ===== üìä DEBUG =====

  debugInfo() {
    return {
      mode: 'UIManager-controlled',
      uiManagerState: this.uiManagerState,
      hasTeamIcon: !!this.teamIcon && !this.teamIcon.isDestroyed,
      hasTeamUI: !!this.teamUI && !this.teamUI.isDestroyed,
      teamStats: this.teamStats,
      teamData: this.teamData.length,
      lastUpdate: this.lastDataUpdate,
      eventListeners: this.eventListeners ? this.eventListeners.size : 0
    };
  }

  enableSilentMode() {
    this.silentMode = true;
    this.log("üîá Mode silencieux activ√©");
  }

  disableSilentMode() {
    this.silentMode = false;
    this.log("üîä Mode silencieux d√©sactiv√©");
  }
}

// ===== üè≠ FONCTIONS FACTORY POUR UIMANAGER =====

/**
 * Factory function pour cr√©er TeamManager contr√¥l√© par UIManager
 */
export function createUIManagerControlledTeamManager(scene, gameRoom) {
  console.log("üè≠ [Factory] Cr√©ation TeamManager UIManager-controlled");
  
  const teamManager = new TeamManager(scene, gameRoom);
  teamManager.isUIManagerControlled = true;
  teamManager.preventAutoActions = true;
  
  return teamManager;
}

/**
 * Factory function pour TeamIcon √† utiliser dans UIManager
 */
export function createTeamIconForUIManager(teamManager) {
  if (!teamManager) {
    throw new Error("TeamManager requis pour cr√©er TeamIcon");
  }
  
  return teamManager.createTeamIconForUIManager();
}

/**
 * Factory function pour TeamUI √† utiliser dans UIManager
 */
export function createTeamUIForUIManager(teamManager) {
  if (!teamManager) {
    throw new Error("TeamManager requis pour cr√©er TeamUI");
  }
  
  return teamManager.createTeamUIForUIManager();
}

/**
 * Setup listener pour les requ√™tes TeamManager ‚Üí UIManager
 */
export function setupTeamManagerUIManagerBridge() {
  window.addEventListener('teamManagerRequest', (event) => {
    const { action, data } = event.detail;
    
    console.log(`üåâ [Bridge] TeamManager ‚Üí UIManager: ${action}`);
    
    const uiManager = window.uiManager || window.pokemonUISystem?.uiManager;
    
    if (!uiManager) {
      console.warn("‚ö†Ô∏è [Bridge] UIManager non disponible");
      return;
    }
    
    // Router l'action vers UIManager
    switch (action) {
      case 'toggleTeamUI':
        uiManager.toggleModule?.('teamUI');
        break;
      case 'showTeamUI':
        uiManager.showModule?.('teamUI');
        break;
      case 'hideTeamUI':
        uiManager.hideModule?.('teamUI');
        break;
      default:
        console.warn(`‚ö†Ô∏è [Bridge] Action inconnue: ${action}`);
    }
  });
  
  console.log("üåâ [Bridge] TeamManager ‚Üî UIManager configur√©");
}

export default TeamManager;

// ===== üìã INSTRUCTIONS D'UTILISATION =====

console.log(`
üéØ === TEAMMANAGER UIMANAGER-CONTROLLED ===

‚úÖ NOUVELLE ARCHITECTURE:
- TeamManager = BUSINESS LOGIC seulement
- UIManager = MA√éTRE qui contr√¥le tout
- Modules UI = SERVANTS ob√©issants

üè≠ UTILISATION DANS UIMANAGER:
uiManager.registerModule('teamIcon', {
  factory: () => createTeamIconForUIManager(teamManager)
});

uiManager.registerModule('teamUI', {
  factory: () => createTeamUIForUIManager(teamManager)
});

üö´ PLUS DE SPAM:
- Un seul ma√Ætre: UIManager
- Modules passifs qui ob√©issent
- Communication via √©v√©nements contr√¥l√©s

üîß SETUP:
1. Cr√©er TeamManager: createUIManagerControlledTeamManager()
2. Setup bridge: setupTeamManagerUIManagerBridge()
3. Enregistrer modules dans UIManager
4. UIManager contr√¥le tout !
`);
