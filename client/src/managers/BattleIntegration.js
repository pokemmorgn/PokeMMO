// client/src/managers/BattleIntegration.js - Version simplifi√©e qui utilise le r√©seau existant
import { BattleUITransition } from '../Battle/BattleUITransition.js';

export class BattleIntegration {
  constructor(gameManager, networkManager) {
    this.gameManager = gameManager;
    this.networkManager = networkManager;
    
    // Gestionnaires
    this.battleUITransition = null;
    this.battleScene = null;
    
    // √âtat
    this.isInitialized = false;
    this.currentBattle = null;
    
    console.log('üéÆ [BattleIntegration] Gestionnaire principal cr√©√© (version simplifi√©e)');
  }

  // === INITIALISATION ===

  async initialize() {
    console.log('üîß [BattleIntegration] Initialisation du syst√®me de combat...');
    
    try {
      // 1. Initialiser la transition UI
      this.battleUITransition = new BattleUITransition(
        window.pokemonUISystem?.uiManager,
        this.gameManager
      );
      
      // 2. ‚úÖ UTILISER LE R√âSEAU EXISTANT au lieu de cr√©er BattleConnection
      // Ton syst√®me r√©seau fonctionne d√©j√† !
      
      // 3. Obtenir la r√©f√©rence √† BattleScene
      this.battleScene = this.gameManager?.currentScene?.scene?.get('BattleScene');
      if (!this.battleScene) {
        console.warn('‚ö†Ô∏è [BattleIntegration] BattleScene non trouv√©e, sera initialis√©e plus tard');
      }
      
      // 4. Setup des √©v√©nements sur le r√©seau existant
      this.setupEvents();
      
      this.isInitialized = true;
      console.log('‚úÖ [BattleIntegration] Syst√®me de combat initialis√© (sans BattleConnection)');
      
      return true;
      
    } catch (error) {
      console.error('‚ùå [BattleIntegration] Erreur initialisation:', error);
      return false;
    }
  }

  // === CONFIGURATION DES √âV√âNEMENTS ===

  setupEvents() {
    console.log('üì° [BattleIntegration] Configuration des √©v√©nements sur r√©seau existant...');
    
    // ‚úÖ UTILISER LE SYST√àME R√âSEAU EXISTANT
    // Ton BattleNetworkHandler fonctionne d√©j√† !
    
    // √âcouter les √©v√©nements existants
    if (window.globalNetworkManager?.battleHandler) {
      const battleHandler = window.globalNetworkManager.battleHandler;
      
      battleHandler.on('wildEncounterStart', (data) => {
        this.handleWildEncounterStart(data);
      });
      
      battleHandler.on('battleRoomCreated', (data) => {
        this.handleBattleRoomCreated(data);
      });
      
      battleHandler.on('battleStart', (data) => {
        this.handleBattleStart(data);
      });
      
      battleHandler.on('battleEnd', (data) => {
        this.handleBattleEnd(data);
      });
    }
    
    // Fallback : √©couter sur le networkManager principal
    if (this.networkManager?.on) {
      this.networkManager.on('wildEncounterStart', (data) => {
        this.handleWildEncounterStart(data);
      });
      
      this.networkManager.on('battleStart', (data) => {
        this.handleBattleStart(data);
      });
      
      this.networkManager.on('battleEnd', (data) => {
        this.handleBattleEnd(data);
      });
    }
    
    console.log('‚úÖ [BattleIntegration] √âv√©nements configur√©s sur r√©seau existant');
  }

  // === GESTION DES √âV√âNEMENTS ===

  async handleWildEncounterStart(data) {
    console.log('üêæ [BattleIntegration] === D√âBUT COMBAT SAUVAGE ===');
    console.log('üìä Donn√©es:', data);
    
    this.currentBattle = {
      type: 'wild',
      pokemon: data.pokemon,
      startTime: Date.now()
    };
    
    // ‚úÖ √âTAPE 1: Lancer la transition UI
    console.log('üé¨ [BattleIntegration] √âtape 1: Transition UI...');
    const transitionSuccess = await this.battleUITransition.startBattleTransition({
      pokemon: data.pokemon,
      location: data.location
    });
    
    if (!transitionSuccess) {
      console.error('‚ùå [BattleIntegration] √âchec transition UI');
      return;
    }
      // üü¢ === AJOUTER CETTE LIGNE :
  await this.showBattleInterface({
    pokemon: data.pokemon,
    location: data.location,
    method: data.method
  });
    
    console.log('‚úÖ [BattleIntegration] Transition UI lanc√©e - interface dans 2 secondes');
  }

  async showBattleInterface(encounterData) {
    console.log('üñ•Ô∏è [BattleIntegration] === AFFICHAGE INTERFACE COMBAT ===');
    
    try {
      // ‚úÖ √âTAPE 1: Obtenir ou initialiser BattleScene
      if (!this.battleScene) {
        this.battleScene = this.gameManager?.currentScene?.scene?.get('BattleScene');
      }
      
      if (!this.battleScene) {
        console.error('‚ùå [BattleIntegration] BattleScene non disponible');
        return;
      }
      
      // ‚úÖ √âTAPE 2: Initialiser BattleScene si n√©cessaire
      if (!this.battleScene.isActive) {
        await this.initializeBattleScene();
      }
      
      // ‚úÖ √âTAPE 3: D√©clencher l'encounter dans BattleScene
      console.log('‚öîÔ∏è [BattleIntegration] D√©clenchement encounter...');
      this.battleScene.handleEncounterStart(encounterData);
      
      console.log('‚úÖ [BattleIntegration] Interface de combat affich√©e');
      
    } catch (error) {
      console.error('‚ùå [BattleIntegration] Erreur affichage interface:', error);
      await this.cancelBattle();
    }
  }

  async initializeBattleScene() {
    console.log('üîß [BattleIntegration] Initialisation BattleScene...');
    
    if (!this.battleScene) return;
    
    // Passer les managers √† BattleScene
    this.battleScene.init({
      gameManager: this.gameManager,
      networkHandler: this.networkManager // Utiliser le networkManager existant
    });
    
    // S'assurer que la sc√®ne est cr√©√©e
    if (!this.battleScene.isActive) {
      this.battleScene.create();
    }
    
    console.log('‚úÖ [BattleIntegration] BattleScene initialis√©e');
  }

  handleBattleRoomCreated(data) {
    console.log('üè† [BattleIntegration] BattleRoom cr√©√©e:', data.battleRoomId);
    
    if (this.currentBattle) {
      this.currentBattle.battleRoomId = data.battleRoomId;
    }
  }

  handleBattleStart(data) {
    console.log('‚öîÔ∏è [BattleIntegration] Combat d√©marr√© !');
    
    if (this.currentBattle) {
      this.currentBattle.status = 'active';
      this.currentBattle.battleData = data;
    }
  }

  async handleBattleEnd(data) {
    console.log('üèÅ [BattleIntegration] === FIN DE COMBAT ===');
    console.log('üìä R√©sultat:', data);
    
    if (this.currentBattle) {
      this.currentBattle.status = 'ended';
      this.currentBattle.result = data.result;
      this.currentBattle.endTime = Date.now();
    }
    
    // Attendre un peu puis revenir √† l'exploration
    setTimeout(async () => {
      await this.returnToExploration(data);
    }, 3000);
  }

  async returnToExploration(battleResult = {}) {
    console.log('üåç [BattleIntegration] === RETOUR EXPLORATION ===');
    
    try {
      // ‚úÖ √âTAPE 1: Masquer l'interface de combat
      if (this.battleScene && this.battleScene.isBattleActive()) {
        console.log('üñ•Ô∏è [BattleIntegration] Masquage interface combat...');
        this.battleScene.hideBattleInterface();
      }
      
      // ‚úÖ √âTAPE 2: Transition de retour √† l'exploration
      if (this.battleUITransition && this.battleUITransition.isBattleActive()) {
        console.log('üîÑ [BattleIntegration] Transition retour...');
        await this.battleUITransition.endBattleTransition(battleResult);
      }
      
      // ‚úÖ √âTAPE 3: Nettoyer l'√©tat de combat
      this.currentBattle = null;
      
      console.log('‚úÖ [BattleIntegration] Retour exploration termin√©');
      
    } catch (error) {
      console.error('‚ùå [BattleIntegration] Erreur retour exploration:', error);
      await this.forceCleanup();
    }
  }

  async cancelBattle() {
    console.log('‚ùå [BattleIntegration] Annulation du combat...');
    
    try {
      // Masquer l'interface de combat
      if (this.battleScene) {
        this.battleScene.hideBattleInterface();
      }
      
      // Annuler la transition
      if (this.battleUITransition) {
        await this.battleUITransition.cancelTransition();
      }
      
      // Nettoyer
      this.currentBattle = null;
      
      console.log('‚úÖ [BattleIntegration] Combat annul√©');
      
    } catch (error) {
      console.error('‚ùå [BattleIntegration] Erreur annulation:', error);
      await this.forceCleanup();
    }
  }

  async forceCleanup() {
    console.log('üßπ [BattleIntegration] Nettoyage forc√©...');
    
    // Supprimer tous les overlays de combat
    const battleOverlays = document.querySelectorAll(
      '#battleOverlay, #battleActionOverlay, #battleTransitionOverlay'
    );
    battleOverlays.forEach(overlay => {
      if (overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
    });
    
    // R√©afficher toutes les ic√¥nes UI
    const hiddenIcons = document.querySelectorAll('.ui-icon-hidden');
    hiddenIcons.forEach(icon => {
      icon.classList.remove('ui-icon-hidden');
      icon.style.display = '';
      icon.style.opacity = '1';
      icon.style.transform = 'scale(1)';
    });
    
    // R√©activer le mouvement
    if (this.gameManager?.player?.setMovementEnabled) {
      this.gameManager.player.setMovementEnabled(true);
    }
    
    // Remettre l'√©tat UI √† exploration
    if (window.pokemonUISystem?.setGameState) {
      window.pokemonUISystem.setGameState('exploration');
    }
    
    console.log('‚úÖ [BattleIntegration] Nettoyage forc√© termin√©');
  }

  // === M√âTHODES PUBLIQUES ===

  /**
   * ‚úÖ VERSION SIMPLIFI√âE : D√©marrage manuel avec donn√©es de test
   */
  async startTestBattle() {
    console.log('üéÆ [BattleIntegration] D√©marrage combat de test...');
    
    if (!this.isInitialized) {
      console.error('‚ùå [BattleIntegration] Syst√®me non initialis√©');
      return false;
    }
    
    // Simuler l'√©v√©nement de rencontre sauvage
    const testData = {
      pokemon: {
        pokemonId: 16, // Pidgey
        name: 'Pidgey',
        level: 3,
        currentHp: 15,
        maxHp: 15,
        types: ['normal', 'flying'],
        moves: ['tackle', 'sand_attack'],
        statusCondition: 'normal'
      },
      location: 'test_zone',
      method: 'manual'
    };
    
    await this.handleWildEncounterStart(testData);
    
    return true;
  }

  /**
   * Force l'arr√™t du combat
   */
  async stopBattle() {
    console.log('üõë [BattleIntegration] Arr√™t forc√© du combat...');
    
    if (this.currentBattle) {
      await this.cancelBattle();
    }
  }

  /**
   * Obtient l'√©tat actuel du combat
   */
  getBattleStatus() {
    return {
      active: !!this.currentBattle,
      battle: this.currentBattle,
      initialized: this.isInitialized,
      components: {
        transition: !!this.battleUITransition,
        scene: !!this.battleScene,
        networkExists: !!(this.networkManager || window.globalNetworkManager)
      }
    };
  }

  // === DEBUG ET TEST ===

  /**
   * Test simple qui utilise les donn√©es de ton r√©seau existant
   */
  async testBattleSystem() {
    console.log('üß™ [BattleIntegration] === TEST SYST√àME COMBAT ===');
    
    const success = await this.startTestBattle();
    
    if (success) {
      console.log('‚úÖ [BattleIntegration] Test d√©marr√© - transition UI lanc√©e');
      
      // Auto-terminer le test apr√®s 15 secondes
      setTimeout(async () => {
        console.log('üß™ [BattleIntegration] Fin auto du test...');
        await this.returnToExploration({ result: 'victory', experience: 50 });
      }, 15000);
      
    } else {
      console.error('‚ùå [BattleIntegration] √âchec du test');
    }
    
    return success;
  }

  debug() {
    console.log('üîç [BattleIntegration] === DEBUG SYST√àME ===');
    
    const status = this.getBattleStatus();
    console.log('üìä Statut:', status);
    
    if (this.battleUITransition) {
      console.log('üé¨ Transition:', this.battleUITransition.getCurrentUIState());
    }
    
    if (this.battleScene) {
      console.log('üéÆ Sc√®ne:', this.battleScene.getBattleState ? this.battleScene.getBattleState() : 'Non d√©fini');
    }
    
    console.log('üåê R√©seau existant:', {
      networkManager: !!this.networkManager,
      globalNetworkManager: !!window.globalNetworkManager,
      battleHandler: !!(window.globalNetworkManager?.battleHandler)
    });
    
    return status;
  }

  // === NETTOYAGE ===

  async destroy() {
    console.log('üíÄ [BattleIntegration] Destruction...');
    
    if (this.currentBattle) {
      await this.cancelBattle();
    }
    
    if (this.battleUITransition) {
      this.battleUITransition.destroy();
      this.battleUITransition = null;
    }
    
    this.battleScene = null;
    this.gameManager = null;
    this.networkManager = null;
    this.currentBattle = null;
    this.isInitialized = false;
    
    console.log('‚úÖ [BattleIntegration] D√©truit');
  }
}

// === INT√âGRATION GLOBALE ===

window.BattleIntegration = BattleIntegration;

// ‚úÖ FONCTION DE TEST SIMPLIFI√âE
window.testBattleIntegrationSimple = async function() {
  console.log('üß™ Test int√©gration combat simple (sans BattleConnection)...');
  
  const integration = new BattleIntegration(
    window.gameManager || window.globalNetworkManager?.gameManager,
    window.globalNetworkManager || window.networkManager
  );
  
  const initialized = await integration.initialize();
  if (initialized) {
    console.log('‚úÖ Int√©gration initialis√©e');
    
    // Lancer le test
    await integration.testBattleSystem();
  } else {
    console.error('‚ùå √âchec initialisation');
  }
  
  return integration;
};

console.log('üéÆ [BattleIntegration] Module charg√© (version simplifi√©e)');
console.log('üß™ Utilisez window.testBattleIntegrationSimple() pour tester');
