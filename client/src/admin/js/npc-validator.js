// PokeWorld Admin Panel - NPC Validator avec LOGS DE DEBUG
// √Ä remplacer dans client/src/admin/js/npc-validator.js

import { NPC_TYPES, COMMON_FIELDS, FIELD_VALIDATORS } from './npc-types-config.js'

export class NPCValidator {
    constructor(options = {}) {
        this.errors = []
        this.warnings = []
        this.suggestions = []
        this.enableLogging = options.enableLogging || false
        this.logLevel = options.logLevel || 'info'
    }

    log(level, message, data = null) {
        if (!this.enableLogging) return
        
        const levels = ['debug', 'info', 'warn', 'error']
        if (levels.indexOf(level) >= levels.indexOf(this.logLevel)) {
            console.log(`üîç [NPCValidator] ${level.toUpperCase()}: ${message}`, data || '')
        }
    }

    // Validation compl√®te d'un NPC
    validateNPC(npc) {
        this.reset()
        
        this.log('info', '=== D√âBUT VALIDATION NPC ===')
        this.log('debug', 'NPC √† valider:', {
            id: npc?.id,
            name: npc?.name,
            type: npc?.type,
            keysCount: npc ? Object.keys(npc).length : 0
        })
        
        if (!npc || typeof npc !== 'object') {
            this.addError('general', 'NPC invalide ou manquant')
            this.log('error', 'NPC invalide ou manquant')
            return this.getResult()
        }

        // Validations de base
        this.log('info', 'Validation des champs de base...')
        this.validateBasicFields(npc)
        
        this.log('info', 'Validation des champs communs...')
        this.validateCommonFields(npc)
        
        // Validations sp√©cifiques au type
        if (npc.type && NPC_TYPES[npc.type]) {
            this.log('info', `Validation sp√©cifique au type: ${npc.type}`)
            this.validateTypeSpecificFields(npc)
            this.validateBusinessLogic(npc)
            this.validateReferences(npc)
        } else {
            this.addError('type', `Type NPC invalide: ${npc.type}`)
            this.log('error', `Type NPC invalide: ${npc.type}`)
        }

        // Suggestions d'am√©lioration
        this.generateSuggestions(npc)

        this.log('info', '=== R√âSULTAT VALIDATION ===')
        this.log('info', `Erreurs: ${this.errors.length}`)
        this.log('info', `Avertissements: ${this.warnings.length}`)
        this.log('info', `Suggestions: ${this.suggestions.length}`)
        
        if (this.errors.length > 0) {
            this.log('error', 'D√âTAIL DES ERREURS:')
            this.errors.forEach((error, index) => {
                this.log('error', `${index + 1}. [${error.field}] ${error.message}`)
            })
        }

        return this.getResult()
    }

    // Validation des champs de base obligatoires
    validateBasicFields(npc) {
        this.log('debug', 'validateBasicFields - d√©but')
        
        const requiredFields = ['id', 'name', 'type', 'position', 'sprite']
        
        requiredFields.forEach(field => {
            this.log('debug', `V√©rification champ requis: ${field}`, npc[field])
            
            if (!npc[field]) {
                this.addError(field, `Champ obligatoire manquant: ${field}`)
                this.log('error', `Champ manquant: ${field}`)
            }
        })

        // Validation du nom
        if (npc.name) {
            this.log('debug', 'Validation du nom:', npc.name)
            
            if (typeof npc.name !== 'string' || npc.name.trim().length < 2) {
                this.addError('name', 'Le nom doit contenir au moins 2 caract√®res')
                this.log('error', 'Nom invalide:', npc.name)
            }
            if (npc.name.length > 50) {
                this.addWarning('name', 'Le nom est tr√®s long (>50 caract√®res)')
                this.log('warn', 'Nom tr√®s long:', npc.name.length)
            }
        }

        // Validation de la position
        if (npc.position) {
            this.log('debug', 'Validation position:', npc.position)
            
            if (typeof npc.position !== 'object' || 
                typeof npc.position.x !== 'number' || 
                typeof npc.position.y !== 'number') {
                this.addError('position', 'Position invalide (x et y doivent √™tre des nombres)')
                this.log('error', 'Position invalide:', {
                    position: npc.position,
                    xType: typeof npc.position?.x,
                    yType: typeof npc.position?.y
                })
            } else {
                if (npc.position.x < 0 || npc.position.y < 0) {
                    this.addWarning('position', 'Position n√©gative d√©tect√©e')
                    this.log('warn', 'Position n√©gative:', npc.position)
                }
                if (npc.position.x > 2000 || npc.position.y > 2000) {
                    this.addWarning('position', 'Position tr√®s √©loign√©e (>2000px)')
                    this.log('warn', 'Position √©loign√©e:', npc.position)
                }
            }
        }

        // Validation du sprite
        if (npc.sprite) {
            this.log('debug', 'Validation sprite:', npc.sprite)
            
            if (!npc.sprite.endsWith('.png')) {
                this.addWarning('sprite', 'Le sprite devrait √™tre un fichier .png')
                this.log('warn', 'Sprite pas .png:', npc.sprite)
            }
            if (npc.sprite.includes(' ')) {
                this.addError('sprite', 'Le nom du sprite ne doit pas contenir d\'espaces')
                this.log('error', 'Sprite avec espaces:', npc.sprite)
            }
        }
        
        this.log('debug', 'validateBasicFields - fin')
    }

    // Validation des champs communs
    validateCommonFields(npc) {
        this.log('debug', 'validateCommonFields - d√©but')
        
        // Direction
        if (npc.direction) {
            this.log('debug', 'Validation direction:', npc.direction)
            
            const validDirections = ['north', 'south', 'east', 'west']
            if (!validDirections.includes(npc.direction)) {
                this.addError('direction', `Direction invalide: ${npc.direction}`)
                this.log('error', 'Direction invalide:', npc.direction)
            }
        }

        // Rayon d'interaction
        if (npc.interactionRadius !== undefined) {
            this.log('debug', 'Validation interactionRadius:', npc.interactionRadius)
            
            if (typeof npc.interactionRadius !== 'number' || npc.interactionRadius < 16 || npc.interactionRadius > 128) {
                this.addError('interactionRadius', 'Le rayon d\'interaction doit √™tre entre 16 et 128 pixels')
                this.log('error', 'interactionRadius invalide:', npc.interactionRadius)
            }
        }

        // Cooldown
        if (npc.cooldownSeconds !== undefined) {
            this.log('debug', 'Validation cooldownSeconds:', npc.cooldownSeconds)
            
            if (typeof npc.cooldownSeconds !== 'number' || npc.cooldownSeconds < 0) {
                this.addError('cooldownSeconds', 'Le cooldown doit √™tre un nombre positif')
                this.log('error', 'cooldownSeconds invalide:', npc.cooldownSeconds)
            }
            if (npc.cooldownSeconds > 3600) {
                this.addWarning('cooldownSeconds', 'Cooldown tr√®s long (>1 heure)')
                this.log('warn', 'Cooldown tr√®s long:', npc.cooldownSeconds)
            }
        }
        
        this.log('debug', 'validateCommonFields - fin')
    }

    // Validation des champs sp√©cifiques au type
    validateTypeSpecificFields(npc) {
        this.log('debug', `validateTypeSpecificFields - type: ${npc.type}`)
        
        const typeConfig = NPC_TYPES[npc.type]
        
        if (!typeConfig) {
            this.addError('type', `Configuration manquante pour le type: ${npc.type}`)
            this.log('error', 'Config type manquante:', npc.type)
            return
        }
        
        // V√©rifier les champs obligatoires du type
        if (typeConfig.fields && typeConfig.fields.required) {
            this.log('debug', 'Champs requis pour ce type:', typeConfig.fields.required)
            
            typeConfig.fields.required.forEach(field => {
                if (!npc[field]) {
                    this.addError(field, `Champ obligatoire pour ${npc.type}: ${field}`)
                    this.log('error', `Champ requis manquant pour ${npc.type}:`, field)
                }
            })
        }

        // Validation selon le type
        this.log('debug', `Validation sp√©cifique pour type: ${npc.type}`)
        switch (npc.type) {
            case 'dialogue':
                this.validateDialogueNPC(npc)
                break
            case 'merchant':
                this.validateMerchantNPC(npc)
                break
            case 'trainer':
                this.validateTrainerNPC(npc)
                break
            case 'healer':
                this.validateHealerNPC(npc)
                break
            case 'gym_leader':
                this.validateGymLeaderNPC(npc)
                break
            case 'transport':
                this.validateTransportNPC(npc)
                break
            case 'service':
                this.validateServiceNPC(npc)
                break
            default:
                this.log('debug', `Pas de validation sp√©cifique pour le type: ${npc.type}`)
        }
    }

    // ‚úÖ NOUVELLE VERSION avec logs d√©taill√©s
    validateMerchantNPC(npc) {
        this.log('info', '=== VALIDATION MERCHANT ===')
        this.log('debug', 'NPC Merchant data:', {
            shopId: npc.shopId,
            shopIdType: typeof npc.shopId,
            shopConfig: npc.shopConfig,
            hasShopConfig: !!npc.shopConfig
        })
        
        // ‚úÖ CORRECTION : Validation du nouveau format shopId simplifi√©
        if (npc.type === 'merchant') {
            // V√©rifier que shopId existe et est une cha√Æne valide
            if (npc.shopId === undefined || npc.shopId === null) {
                this.log('warn', 'Merchant sans shopId - sera g√©n√©rique')
                this.addWarning('shopId', 'Merchant sans shopId - sera un marchand g√©n√©rique')
            } else if (typeof npc.shopId !== 'string') {
                this.log('error', 'shopId pas string:', typeof npc.shopId)
                this.addError('shopId', 'shopId doit √™tre une cha√Æne de caract√®res')
            } else {
                // Validation du format shopId
                if (npc.shopId.trim().length === 0) {
                    this.log('info', 'shopId vide - marchand g√©n√©rique')
                    this.addWarning('shopId', 'shopId vide - sera un marchand g√©n√©rique')
                } else if (npc.shopId.includes(' ')) {
                    this.log('error', 'shopId avec espaces:', npc.shopId)
                    this.addError('shopId', 'shopId ne doit pas contenir d\'espaces')
                } else if (!npc.shopId.match(/^[a-zA-Z0-9_-]+$/)) {
                    this.log('warn', 'Format shopId non standard:', npc.shopId)
                    this.addWarning('shopId', 'Format d\'ID recommand√©: lettres, chiffres, _ et - uniquement')
                } else {
                    this.log('info', 'shopId valide:', npc.shopId)
                }
            }
        }
        
        // ‚úÖ MIGRATION : D√©tecter l'ancien format et avertir
        if (npc.shopConfig) {
            this.log('warn', 'Ancien format shopConfig d√©tect√©:', npc.shopConfig)
            this.addWarning('shopConfig', 'Ancien format shopConfig d√©tect√© - utilisez shopId directement')
            
            // Sugg√©rer la migration
            if (npc.shopConfig.shopId && !npc.shopId) {
                this.log('info', 'Migration sugg√©r√©e:', npc.shopConfig.shopId)
                this.addSuggestion('shopId', `Migrer shopConfig.shopId vers shopId: "${npc.shopConfig.shopId}"`)
            }
        }
        
        this.log('info', '=== FIN VALIDATION MERCHANT ===')
    }

    validateDialogueNPC(npc) {
        this.log('debug', 'validateDialogueNPC')
        // Pas de validation stricte pour les dialogues - compl√®tement libre
    }

    validateTrainerNPC(npc) {
        this.log('debug', 'validateTrainerNPC')
        // Validation trainer existante...
    }

    validateHealerNPC(npc) {
        this.log('debug', 'validateHealerNPC')
        // Validation healer existante...
    }

    validateGymLeaderNPC(npc) {
        this.log('debug', 'validateGymLeaderNPC')
        // Validation gym leader existante...
    }

    validateTransportNPC(npc) {
        this.log('debug', 'validateTransportNPC')
        // Validation transport existante...
    }

    validateServiceNPC(npc) {
        this.log('debug', 'validateServiceNPC')
        // Validation service existante...
    }

    // Validation de la logique m√©tier
    validateBusinessLogic(npc) {
        this.log('debug', 'validateBusinessLogic')
        // Logique existante...
    }

    // Validation des r√©f√©rences
    validateReferences(npc) {
        this.log('debug', 'validateReferences')
        // Logique existante...
    }

    // G√©n√©rer des suggestions d'am√©lioration
    generateSuggestions(npc) {
        this.log('debug', 'generateSuggestions')
        // Logique existante...
    }

    // M√©thodes utilitaires
    reset() {
        this.errors = []
        this.warnings = []
        this.suggestions = []
    }

    addError(field, message) {
        this.errors.push({ field, message, type: 'error' })
        this.log('error', `ERREUR AJOUT√âE [${field}]: ${message}`)
    }

    addWarning(field, message) {
        this.warnings.push({ field, message, type: 'warning' })
        this.log('warn', `AVERTISSEMENT AJOUT√â [${field}]: ${message}`)
    }

    addSuggestion(field, message) {
        this.suggestions.push({ field, message, type: 'suggestion' })
        this.log('info', `SUGGESTION AJOUT√âE [${field}]: ${message}`)
    }

    getResult() {
        const result = {
            valid: this.errors.length === 0,
            errors: this.errors,
            warnings: this.warnings,
            suggestions: this.suggestions,
            total: this.errors.length + this.warnings.length + this.suggestions.length
        }
        
        this.log('info', 'R√âSULTAT FINAL:', {
            valid: result.valid,
            errorsCount: result.errors.length,
            warningsCount: result.warnings.length,
            suggestionsCount: result.suggestions.length
        })
        
        return result
    }

    // Validation rapide (juste les erreurs critiques)
    quickValidate(npc) {
        this.reset()
        this.validateBasicFields(npc)
        
        if (npc.type && NPC_TYPES[npc.type]) {
            const typeConfig = NPC_TYPES[npc.type]
            if (typeConfig.fields && typeConfig.fields.required) {
                typeConfig.fields.required.forEach(field => {
                    if (!npc[field]) {
                        this.addError(field, `Champ obligatoire manquant: ${field}`)
                    }
                })
            }
        }

        return this.errors.length === 0
    }
}

// Validation par lot (pour valider plusieurs NPCs)
export class BatchNPCValidator {
    constructor() {
        this.validator = new NPCValidator()
        this.results = []
    }

    validateBatch(npcs) {
        this.results = []
        
        npcs.forEach((npc, index) => {
            const result = this.validator.validateNPC(npc)
            this.results.push({
                index,
                npc,
                ...result
            })
        })

        return this.getBatchSummary()
    }

    getBatchSummary() {
        const summary = {
            total: this.results.length,
            valid: this.results.filter(r => r.valid).length,
            invalid: this.results.filter(r => !r.valid).length,
            totalErrors: this.results.reduce((sum, r) => sum + r.errors.length, 0),
            totalWarnings: this.results.reduce((sum, r) => sum + r.warnings.length, 0),
            results: this.results
        }

        return summary
    }
}

// Fonction utilitaire pour validation rapide
export function validateNPC(npc) {
    const validator = new NPCValidator()
    return validator.validateNPC(npc)
}

export function quickValidateNPC(npc) {
    const validator = new NPCValidator()
    return validator.quickValidate(npc)
}

export default { NPCValidator, BatchNPCValidator, validateNPC, quickValidateNPC }
