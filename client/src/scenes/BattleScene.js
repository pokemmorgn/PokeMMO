// client/src/scenes/BattleScene.js - SOLUTION SPRITES 9x9 avec calcul automatique

export class BattleScene extends Phaser.Scene {
  constructor() {
    super({ key: 'BattleScene' });
    
    // Managers
    this.battleManager = null;
    this.gameManager = null;
    this.networkHandler = null;
    
    // √âtat de la sc√®ne
    this.isActive = false;
    this.isVisible = false;
    
    // üÜï SPRITES POK√âMON avec gestion 9x9
    this.playerPokemonSprite = null;
    this.opponentPokemonSprite = null;
    this.battleBackground = null;
    
    // üÜï CACHE DES TAILLES DE FRAMES
    this.frameSizeCache = new Map();
    
    // Donn√©es actuelles
    this.currentPlayerPokemon = null;
    this.currentOpponentPokemon = null;
    
    // üÜï POSITIONS DES POK√âMON (style Pok√©mon classique)
    this.pokemonPositions = {
      player: { x: 0.15, y: 0.75 },      // 15% gauche, 75% bas (premier plan)
      opponent: { x: 0.75, y: 0.35 }     // 75% droite, 35% haut (arri√®re-plan)
    };
    
    console.log('‚öîÔ∏è [BattleScene] Constructeur initialis√© - Sprites 9x9 Ready');
  }

  // === INITIALISATION ===

  init(data = {}) {
    console.log('üîß [BattleScene] Init avec data:', data);
    
    this.gameManager = data.gameManager || this.scene.get('GameScene')?.gameManager;
    this.networkHandler = data.networkHandler || this.scene.get('GameScene')?.networkHandler;
    
    if (!this.gameManager || !this.networkHandler) {
      console.warn('‚ö†Ô∏è [BattleScene] Managers partiellement manquants dans init');
    }
    
    console.log('‚úÖ [BattleScene] Init termin√©');
  }

  // ‚úÖ SOLUTION: PRELOAD avec calcul automatique 9x9
  preload() {
    console.log('üìÅ [BattleScene] Pr√©chargement sprites Pok√©mon 9x9...');
    
    // Background de combat
    if (!this.textures.exists('battlebg01')) {
      this.load.image('battlebg01', 'assets/battle/bg_battle_01.png');
    }
    
    // ‚úÖ SPRITES POK√âMON avec calcul automatique des frames
    this.loadPokemonSpritesheets9x9();
    
    // ‚úÖ √âv√©nement de completion pour debug
    this.load.on('complete', () => {
      console.log('‚úÖ [BattleScene] Chargement sprites termin√©');
      this.debugLoadedTextures();
    });
    
    console.log('‚úÖ [BattleScene] Pr√©chargement configur√© avec calcul 9x9');
  }

  // ‚úÖ SOLUTION PRINCIPALE: Chargement intelligent des sprites 9x9
  loadPokemonSpritesheets9x9() {
    console.log('üêæ [BattleScene] Chargement intelligent sprites 9x9...');
    
    // Liste des Pok√©mon avec leurs configurations sp√©cifiques
    const pokemonConfigs = [
      // Starters Kanto
      { id: 1, name: 'bulbasaur', commonSizes: [360, 405, 288] },
      { id: 4, name: 'charmander', commonSizes: [360, 405, 288] },
      { id: 7, name: 'squirtle', commonSizes: [360, 405, 288] },
      
      // Pikachu (tr√®s courant)
      { id: 25, name: 'pikachu', commonSizes: [360, 576, 288] },
      
      // Autres populaires
      { id: 39, name: 'jigglypuff', commonSizes: [288, 360] },
      { id: 52, name: 'meowth', commonSizes: [288, 360] },
      { id: 54, name: 'psyduck', commonSizes: [360, 405] },
      { id: 150, name: 'mewtwo', commonSizes: [576, 720] }
    ];
    
    // ‚úÖ Charger chaque Pok√©mon avec essai de tailles multiples
    pokemonConfigs.forEach(pokemon => {
      this.loadPokemonWithMultipleSizes(pokemon);
    });
    
    // ‚úÖ PLACEHOLDERS toujours disponibles
    this.loadPlaceholderSprites();
    
    console.log(`‚úÖ [BattleScene] ${pokemonConfigs.length} Pok√©mon configur√©s pour chargement 9x9`);
  }

  // ‚úÖ FONCTION CLEF: Chargement avec essai de tailles multiples
  loadPokemonWithMultipleSizes(pokemonConfig) {
    const { id, name, commonSizes } = pokemonConfig;
    
    // Pour front et back
    ['front', 'back'].forEach(view => {
      const spriteKey = `pokemon_${id}_${view}`;
      
      if (this.textures.exists(spriteKey)) {
        console.log(`‚è≠Ô∏è [BattleScene] Sprite ${spriteKey} d√©j√† charg√©`);
        return;
      }
      
      // ‚úÖ SOLUTION: Essayer les tailles communes pour ce Pok√©mon
      const imagePath = `assets/pokemon/${name}/${view}.png`;
      
      // Utiliser la premi√®re taille comme d√©faut, les autres comme fallback
      const primarySize = commonSizes[0] || 360;
      const frameSize = this.calculateFrameSize9x9(primarySize, primarySize);
      
      console.log(`üìä [BattleScene] ${spriteKey}: essai ${primarySize}x${primarySize} ‚Üí frames ${frameSize.frameWidth}x${frameSize.frameHeight}`);
      
      this.load.spritesheet(spriteKey, imagePath, {
        frameWidth: frameSize.frameWidth,
        frameHeight: frameSize.frameHeight
      });
      
      // Stocker dans le cache pour r√©f√©rence
      this.frameSizeCache.set(spriteKey, {
        imageSize: primarySize,
        frameWidth: frameSize.frameWidth,
        frameHeight: frameSize.frameHeight,
        calculated: true
      });
    });
  }

  // ‚úÖ FONCTION UTILITAIRE: Calcul frame size 9x9
  calculateFrameSize9x9(imageWidth, imageHeight) {
    const frameWidth = Math.floor(imageWidth / 9);
    const frameHeight = Math.floor(imageHeight / 9);
    
    return {
      frameWidth,
      frameHeight,
      totalFrames: 81,
      grid: '9x9'
    };
  }

  // ‚úÖ Placeholders toujours fonctionnels
  loadPlaceholderSprites() {
    const placeholderConfigs = [
      { key: 'pokemon_placeholder_front', size: 96 },
      { key: 'pokemon_placeholder_back', size: 96 }
    ];
    
    placeholderConfigs.forEach(config => {
      if (!this.textures.exists(config.key)) {
        // Cr√©er un placeholder proc√©dural si pas de fichier
        this.load.image(config.key, this.createPlaceholderData(config.size));
      }
    });
  }

  // ‚úÖ Cr√©ation de placeholder proc√©dural
  createPlaceholderData(size) {
    // Cr√©er une image canvas simple comme placeholder
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    
    // Gradient simple
    const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
    gradient.addColorStop(0, '#FFD700');
    gradient.addColorStop(1, '#FFA500');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);
    
    // Bordure
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(1, 1, size-2, size-2);
    
    // Texte "?"
    ctx.fillStyle = '#000000';
    ctx.font = `${size/3}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('?', size/2, size/2);
    
    return canvas.toDataURL();
  }

  create() {
    console.log('üé® [BattleScene] Cr√©ation de la sc√®ne...');
    
    try {
      // 1. Cr√©er le background
      this.createBattleBackground();
      
      // 2. Calculer les positions AVANT tout
      this.createPokemonPositions();
      
      // 3. Setup managers et √©v√©nements
      this.setupBasicBattleManager();
      this.setupBasicEvents();
      
      this.isActive = true;
      console.log('‚úÖ [BattleScene] Sc√®ne cr√©√©e - Sprites 9x9 pr√™ts');
      console.log('üêæ [BattleScene] Positions configur√©es:', this.pokemonPositions);
      
    } catch (error) {
      console.error('‚ùå [BattleScene] Erreur lors de la cr√©ation:', error);
    }
  }

  // === CR√âATION DU BACKGROUND ===

  createBattleBackground() {
    console.log('üñºÔ∏è [BattleScene] Cr√©ation background de combat...');
    
    const { width, height } = this.cameras.main;
    
    if (this.textures.exists('battlebg01')) {
      this.battleBackground = this.add.image(width/2, height/2, 'battlebg01');
      
      // Ajuster la taille pour couvrir l'√©cran
      const scaleX = width / this.battleBackground.width;
      const scaleY = height / this.battleBackground.height;
      const scale = Math.max(scaleX, scaleY);
      
      this.battleBackground.setScale(scale);
      this.battleBackground.setDepth(-100);
      
      console.log('‚úÖ [BattleScene] Background charg√© et mis √† l\'√©chelle');
    } else {
      console.warn('‚ö†Ô∏è [BattleScene] Background manquant, cr√©ation fallback...');
      this.createFallbackBackground();
    }
  }

  createFallbackBackground() {
    const { width, height } = this.cameras.main;
    
    const bg = this.add.graphics();
    
    // D√©grad√© style Pok√©mon authentique
    bg.fillGradientStyle(
      0x87CEEB, 0x87CEEB,  // Bleu ciel en haut
      0x32CD32, 0x228B22   // Vert herbe en bas
    );
    bg.fillRect(0, 0, width, height);
    bg.setDepth(-100);
    
    // Ligne d'horizon
    const horizonY = height * 0.55;
    bg.lineStyle(3, 0x2F4F2F, 0.6);
    bg.lineBetween(0, horizonY, width, horizonY);
    
    this.battleBackground = bg;
  }

  // === POSITIONS DES POK√âMON ===

  createPokemonPositions() {
    console.log('üêæ [BattleScene] Calcul positions Pok√©mon...');
    
    const { width, height } = this.cameras.main;
    
    // Calculer positions absolues
    this.pokemonPositions.playerAbsolute = {
      x: width * this.pokemonPositions.player.x,
      y: height * this.pokemonPositions.player.y
    };
    
    this.pokemonPositions.opponentAbsolute = {
      x: width * this.pokemonPositions.opponent.x,
      y: height * this.pokemonPositions.opponent.y
    };
    
    console.log('‚úÖ [BattleScene] Positions calcul√©es:', {
      player: this.pokemonPositions.playerAbsolute,
      opponent: this.pokemonPositions.opponentAbsolute,
      screen: { width, height }
    });
  }

  // ‚úÖ SOLUTION: AFFICHAGE POK√âMON JOUEUR avec frame 0
  displayPlayerPokemon(pokemonData) {
    console.log('üë§ [BattleScene] Affichage Pok√©mon joueur (9x9 frame 0):', pokemonData);
    
    // V√©rifier positions
    if (!this.pokemonPositions?.playerAbsolute) {
      this.createPokemonPositions();
    }
    
    // Nettoyer ancien sprite
    if (this.playerPokemonSprite) {
      this.playerPokemonSprite.destroy();
      this.playerPokemonSprite = null;
    }
    
    if (!pokemonData) {
      console.warn('‚ö†Ô∏è [BattleScene] Pas de donn√©es Pok√©mon joueur');
      return;
    }
    
    // ‚úÖ CLEF: Obtenir sprite avec gestion d'erreur
    const spriteKey = this.getPokemonSpriteKey(pokemonData.pokemonId || pokemonData.id, 'back');
    
    try {
      // ‚úÖ SOLUTION: Cr√©er sprite avec frame 0 EXPLICITE
      this.playerPokemonSprite = this.add.sprite(
        this.pokemonPositions.playerAbsolute.x,
        this.pokemonPositions.playerAbsolute.y,
        spriteKey,
        0  // ‚úÖ FRAME 0 pour spritesheet 9x9
      );
      
      // ‚úÖ V√©rifier que le sprite a bien la texture
      if (!this.playerPokemonSprite.texture || this.playerPokemonSprite.texture.key === '__MISSING') {
        throw new Error(`Texture manquante pour ${spriteKey}`);
      }
      
      // Configuration sp√©cialis√©e vue de dos
      this.playerPokemonSprite.setScale(2.8);  // Plus grand (premier plan)
      this.playerPokemonSprite.setDepth(20);
      this.playerPokemonSprite.setOrigin(0.5, 1);  // Ancr√© au sol
      
      // ‚úÖ Marquer le sprite pour debug
      this.playerPokemonSprite.setData('isPokemon', true);
      this.playerPokemonSprite.setData('pokemonType', 'player');
      this.playerPokemonSprite.setData('pokemonId', pokemonData.pokemonId);
      
      // Animation d'entr√©e depuis la gauche
      this.animatePokemonEntry(this.playerPokemonSprite, 'left');
      
      // Stocker les donn√©es
      this.currentPlayerPokemon = pokemonData;
      
      // ‚úÖ Log de succ√®s avec d√©tails
      const frameInfo = this.frameSizeCache.get(spriteKey);
      console.log(`‚úÖ [BattleScene] Pok√©mon joueur affich√©: ${pokemonData.name}`);
      console.log(`üìä [BattleScene] Sprite: ${spriteKey}, Frame: 0, Size: ${frameInfo?.frameWidth || '?'}x${frameInfo?.frameHeight || '?'}`);
      
    } catch (error) {
      console.error('‚ùå [BattleScene] Erreur affichage Pok√©mon joueur:', error);
      this.createPokemonPlaceholder('player', pokemonData);
    }
  }

  // ‚úÖ SOLUTION: AFFICHAGE POK√âMON ADVERSAIRE avec frame 0
  displayOpponentPokemon(pokemonData) {
    console.log('üëπ [BattleScene] Affichage Pok√©mon adversaire (9x9 frame 0):', pokemonData);
    
    // V√©rifier positions
    if (!this.pokemonPositions?.opponentAbsolute) {
      this.createPokemonPositions();
    }
    
    // Nettoyer ancien sprite
    if (this.opponentPokemonSprite) {
      this.opponentPokemonSprite.destroy();
      this.opponentPokemonSprite = null;
    }
    
    if (!pokemonData) {
      console.warn('‚ö†Ô∏è [BattleScene] Pas de donn√©es Pok√©mon adversaire');
      return;
    }
    
    // ‚úÖ CLEF: Obtenir sprite avec gestion d'erreur
    const spriteKey = this.getPokemonSpriteKey(pokemonData.pokemonId || pokemonData.id, 'front');
    
    try {
      // ‚úÖ SOLUTION: Cr√©er sprite avec frame 0 EXPLICITE
      this.opponentPokemonSprite = this.add.sprite(
        this.pokemonPositions.opponentAbsolute.x,
        this.pokemonPositions.opponentAbsolute.y,
        spriteKey,
        0  // ‚úÖ FRAME 0 pour spritesheet 9x9
      );
      
      // ‚úÖ V√©rifier que le sprite a bien la texture
      if (!this.opponentPokemonSprite.texture || this.opponentPokemonSprite.texture.key === '__MISSING') {
        throw new Error(`Texture manquante pour ${spriteKey}`);
      }
      
      // Configuration sp√©cialis√©e vue de face
      this.opponentPokemonSprite.setScale(2.2);  // Plus petit (arri√®re-plan)
      this.opponentPokemonSprite.setDepth(15);
      this.opponentPokemonSprite.setOrigin(0.5, 1);  // Ancr√© au sol
      
      // ‚úÖ Marquer le sprite pour debug
      this.opponentPokemonSprite.setData('isPokemon', true);
      this.opponentPokemonSprite.setData('pokemonType', 'opponent');
      this.opponentPokemonSprite.setData('pokemonId', pokemonData.pokemonId);
      
      // Effet shiny si applicable
      if (pokemonData.shiny) {
        this.addShinyEffect(this.opponentPokemonSprite);
      }
      
      // Animation d'entr√©e depuis la droite
      this.animatePokemonEntry(this.opponentPokemonSprite, 'right');
      
      // Stocker les donn√©es
      this.currentOpponentPokemon = pokemonData;
      
      // ‚úÖ Log de succ√®s avec d√©tails
      const frameInfo = this.frameSizeCache.get(spriteKey);
      console.log(`‚úÖ [BattleScene] Pok√©mon adversaire affich√©: ${pokemonData.name}`);
      console.log(`üìä [BattleScene] Sprite: ${spriteKey}, Frame: 0, Size: ${frameInfo?.frameWidth || '?'}x${frameInfo?.frameHeight || '?'}`);
      
    } catch (error) {
      console.error('‚ùå [BattleScene] Erreur affichage Pok√©mon adversaire:', error);
      this.createPokemonPlaceholder('opponent', pokemonData);
    }
  }

  // ‚úÖ SOLUTION: Gestion intelligente des clefs de sprites
  getPokemonSpriteKey(pokemonId, view = 'front') {
    const spriteKey = `pokemon_${pokemonId}_${view}`;
    
    // ‚úÖ V√©rification avec logs d√©taill√©s
    if (this.textures.exists(spriteKey)) {
      const texture = this.textures.get(spriteKey);
      console.log(`‚úÖ [BattleScene] Sprite trouv√©: ${spriteKey} (${texture.source[0].width}x${texture.source[0].height})`);
      return spriteKey;
    } else {
      console.warn(`‚ö†Ô∏è [BattleScene] Sprite manquant: ${spriteKey}, fallback placeholder`);
      
      // ‚úÖ Essayer placeholder sp√©cialis√©
      const placeholderKey = `pokemon_placeholder_${view}`;
      if (this.textures.exists(placeholderKey)) {
        return placeholderKey;
      } else {
        // Derni√®re option: placeholder g√©n√©rique
        return this.textures.exists('pokemon_placeholder_front') ? 
          'pokemon_placeholder_front' : '__DEFAULT';
      }
    }
  }

  // ‚úÖ PLACEHOLDER am√©lior√© avec informations
  createPokemonPlaceholder(type, pokemonData) {
    console.log(`üé≠ [BattleScene] Cr√©ation placeholder intelligent ${type}:`, pokemonData.name);
    
    if (!this.pokemonPositions?.playerAbsolute || !this.pokemonPositions?.opponentAbsolute) {
      this.createPokemonPositions();
    }
    
    const position = type === 'player' ? 
      this.pokemonPositions.playerAbsolute : 
      this.pokemonPositions.opponentAbsolute;
    
    if (!position) {
      console.error(`‚ùå [BattleScene] Position ${type} non disponible`);
      return;
    }
    
    // ‚úÖ Couleur selon le type avec meilleur mapping
    const primaryType = pokemonData.types?.[0] || 'normal';
    const typeColor = this.getTypeColor(primaryType);
    
    // ‚úÖ Placeholder plus d√©taill√©
    const placeholder = this.add.circle(position.x, position.y, 50, typeColor, 0.8);
    placeholder.setStroke(3, 0x000000);
    
    // Nom du Pok√©mon
    const nameText = this.add.text(
      position.x, position.y - 5,
      pokemonData.name || 'Pok√©mon',
      {
        fontSize: '14px',
        fontFamily: 'Arial, sans-serif',
        color: '#FFFFFF',
        fontWeight: 'bold',
        stroke: '#000000',
        strokeThickness: 2
      }
    ).setOrigin(0.5);
    
    // Niveau
    const levelText = this.add.text(
      position.x, position.y + 10,
      `Niv. ${pokemonData.level || '?'}`,
      {
        fontSize: '11px',
        fontFamily: 'Arial, sans-serif',
        color: '#FFFF99',
        fontWeight: 'bold',
        stroke: '#000000',
        strokeThickness: 1
      }
    ).setOrigin(0.5);
    
    // Configuration selon le type
    const scale = type === 'player' ? 2.8 : 2.2;
    const depth = type === 'player' ? 20 : 15;
    
    [placeholder, nameText, levelText].forEach(obj => {
      obj.setScale(scale * 0.4);
      obj.setDepth(depth);
    });
    
    // Animation d'entr√©e
    const direction = type === 'player' ? 'left' : 'right';
    this.animatePokemonEntry(placeholder, direction);
    
    // Stocker selon le type
    if (type === 'player') {
      this.playerPokemonSprite = placeholder;
      this.currentPlayerPokemon = pokemonData;
    } else {
      this.opponentPokemonSprite = placeholder;
      this.currentOpponentPokemon = pokemonData;
    }
    
    console.log(`‚úÖ [BattleScene] Placeholder ${type} cr√©√© pour ${pokemonData.name}`);
  }

  // === ANIMATIONS ===

  animatePokemonEntry(sprite, direction) {
    if (!sprite) return;
    
    const originalX = sprite.x;
    const originalY = sprite.y;
    
    // Position de d√©part
    const startX = direction === 'left' ? -150 : this.cameras.main.width + 150;
    sprite.setPosition(startX, originalY + 50);
    sprite.setAlpha(0);
    sprite.setScale(sprite.scaleX * 0.5);
    
    // Animation d'entr√©e dynamique
    this.tweens.add({
      targets: sprite,
      x: originalX,
      y: originalY,
      alpha: 1,
      scaleX: sprite.scaleX * 2,
      scaleY: sprite.scaleY * 2,
      duration: 1000,
      ease: 'Back.easeOut',
      onComplete: () => {
        // Animation d'atterrissage
        this.tweens.add({
          targets: sprite,
          y: originalY + 8,
          duration: 300,
          yoyo: true,
          ease: 'Bounce.easeOut'
        });
      }
    });
  }

  addShinyEffect(sprite) {
    if (!sprite) return;
    
    // Effet scintillant pour Pok√©mon shiny
    this.tweens.add({
      targets: sprite,
      tint: 0xFFD700,
      duration: 1200,
      yoyo: true,
      repeat: -1,
      ease: 'Sine.easeInOut'
    });
    
    console.log('‚ú® [BattleScene] Effet shiny appliqu√©');
  }

  // === UTILITAIRES ===

  getTypeColor(type) {
    const typeColors = {
      'normal': 0xA8A878,
      'fire': 0xF08030,
      'water': 0x6890F0,
      'electric': 0xF8D030,
      'grass': 0x78C850,
      'ice': 0x98D8D8,
      'fighting': 0xC03028,
      'poison': 0xA040A0,
      'ground': 0xE0C068,
      'flying': 0xA890F0,
      'psychic': 0xF85888,
      'bug': 0xA8B820,
      'rock': 0xB8A038,
      'ghost': 0x705898,
      'dragon': 0x7038F8,
      'dark': 0x705848,
      'steel': 0xB8B8D0,
      'fairy': 0xEE99AC
    };
    
    return typeColors[type.toLowerCase()] || 0xFFFFFF;
  }

  // === DEBUG ET DIAGNOSTIC ===

  debugLoadedTextures() {
    console.log('üîç [BattleScene] === DEBUG TEXTURES CHARG√âES ===');
    
    const pokemonTextures = [];
    this.textures.each((key, texture) => {
      if (key.includes('pokemon_')) {
        const size = texture.source[0];
        const frameInfo = this.frameSizeCache.get(key);
        
        pokemonTextures.push({
          key,
          size: `${size.width}x${size.height}`,
          frames: frameInfo?.totalFrames || 'inconnu',
          frameSize: frameInfo ? `${frameInfo.frameWidth}x${frameInfo.frameHeight}` : 'non calcul√©'
        });
      }
    });
    
    console.table(pokemonTextures);
    console.log('üîç === FIN DEBUG TEXTURES ===');
  }

  // === M√âTHODES PUBLIQUES DE TEST ===

  testDisplayPokemon() {
    console.log('üß™ [BattleScene] Test affichage Pok√©mon avec frames 9x9...');
    
    this.clearAllPokemonSprites();
    
    // Pok√©mon de test avec IDs courants
    const testPlayerPokemon = {
      pokemonId: 4,
      id: 'player_charmander',
      name: 'Charmander',
      level: 5,
      currentHp: 18,
      maxHp: 18,
      types: ['fire']
    };
    
    const testOpponentPokemon = {
      pokemonId: 25,
      id: 'wild_pikachu',
      name: 'Pikachu',
      level: 8,
      currentHp: 25,
      maxHp: 25,
      types: ['electric'],
      shiny: false
    };
    
    // Afficher avec d√©lais pour l'effet
    setTimeout(() => {
      this.displayPlayerPokemon(testPlayerPokemon);
    }, 500);
    
    setTimeout(() => {
      this.displayOpponentPokemon(testOpponentPokemon);
    }, 1200);
    
    // Debug apr√®s affichage
    setTimeout(() => {
      this.debugCurrentSprites();
    }, 2000);
  }

  debugCurrentSprites() {
    console.log('üîç [BattleScene] === DEBUG SPRITES ACTUELS ===');
    
    if (this.playerPokemonSprite) {
      console.log('üë§ Joueur:', {
        texture: this.playerPokemonSprite.texture.key,
        frame: this.playerPokemonSprite.frame.name,
        position: `${this.playerPokemonSprite.x}, ${this.playerPokemonSprite.y}`,
        scale: this.playerPokemonSprite.scale,
        visible: this.playerPokemonSprite.visible
      });
    }
    
    if (this.opponentPokemonSprite) {
      console.log('üëπ Adversaire:', {
        texture: this.opponentPokemonSprite.texture.key,
        frame: this.opponentPokemonSprite.frame.name,
        position: `${this.opponentPokemonSprite.x}, ${this.opponentPokemonSprite.y}`,
        scale: this.opponentPokemonSprite.scale,
        visible: this.opponentPokemonSprite.visible
      });
    }
    
    console.log('üîç === FIN DEBUG SPRITES ===');
  }

  clearAllPokemonSprites() {
    console.log('üßπ [BattleScene] Nettoyage sprites Pok√©mon...');
    
    // Supprimer sprites principaux
    if (this.playerPokemonSprite) {
      this.playerPokemonSprite.destroy();
      this.playerPokemonSprite = null;
    }
    
    if (this.opponentPokemonSprite) {
      this.opponentPokemonSprite.destroy();
      this.opponentPokemonSprite = null;
    }
    
    // ‚úÖ Nettoyer sprites orphelins avec tag 'isPokemon'
    const allChildren = this.children.list.slice();
    allChildren.forEach(child => {
      if (child.getData && child.getData('isPokemon')) {
        console.log('üóëÔ∏è [BattleScene] Suppression sprite orphelin:', child.getData('pokemonId'));
        child.destroy();
      }
    });
    
    // Nettoyer donn√©es
    this.currentPlayerPokemon = null;
    this.currentOpponentPokemon = null;
    
    console.log('‚úÖ [BattleScene] Nettoyage termin√©');
  }

  // === M√âTHODES PUBLIQUES ===

  handleEncounterStart(encounterData) {
    console.log('üêæ [BattleScene] handleEncounterStart avec sprites 9x9:', encounterData);
    
    if (!this.isActive) {
      console.warn('‚ö†Ô∏è [BattleScene] Sc√®ne non active, activation...');
      if (this.scene && this.scene.wake) {
        this.scene.wake();
      }
    }
    
    // S'assurer positions calcul√©es
    if (!this.pokemonPositions?.playerAbsolute) {
      this.createPokemonPositions();
    }
    
    // Afficher Pok√©mon de la rencontre
    if (encounterData.pokemon) {
      console.log('üëπ [BattleScene] Affichage Pok√©mon rencontre...');
      this.displayOpponentPokemon(encounterData.pokemon);
    }
    
    // Pok√©mon joueur par d√©faut si n√©cessaire
    if (!this.currentPlayerPokemon) {
      console.log('üë§ [BattleScene] Affichage Pok√©mon joueur par d√©faut...');
      const defaultPlayerPokemon = {
        pokemonId: 4,
        id: 'player_charmander_default',
        name: 'Charmander',
        level: 5,
        currentHp: 18,
        maxHp: 18,
        types: ['fire']
      };
      this.displayPlayerPokemon(defaultPlayerPokemon);
    }
    
    this.isVisible = true;
    console.log('‚úÖ [BattleScene] Rencontre trait√©e avec sprites 9x9');
  }

  startBattle(battleData) {
    console.log('‚öîÔ∏è [BattleScene] D√©marrage combat avec sprites 9x9:', battleData);
    
    if (!this.isActive) {
      console.error('‚ùå [BattleScene] Sc√®ne non active');
      return;
    }
    
    // R√©veiller sc√®ne si n√©cessaire
    if (this.scene && !this.scene.isActive()) {
      this.scene.wake();
    }
    
    // Afficher Pok√©mon avec frames 9x9
    if (battleData.playerPokemon) {
      this.displayPlayerPokemon(battleData.playerPokemon);
    }
    
    if (battleData.opponentPokemon) {
      this.displayOpponentPokemon(battleData.opponentPokemon);
    }
    
    this.isVisible = true;
  }

  hideBattle() {
    console.log('üñ•Ô∏è [BattleScene] Masquage combat...');
    
    this.isVisible = false;
    
    if (this.scene && this.scene.sleep) {
      this.scene.sleep();
    }
  }

  // === M√âTHODES DE BASE (temporaires) ===

  setupBasicBattleManager() {
    console.log('‚öîÔ∏è [BattleScene] Setup BattleManager basique');
    // Version simplifi√©e pour focus sur sprites
  }

  setupBasicEvents() {
    console.log('üîó [BattleScene] Setup √©v√©nements basiques');
    // Version simplifi√©e pour focus sur sprites
  }

  // === NETTOYAGE ===

  destroy() {
    console.log('üíÄ [BattleScene] Destruction...');
    
    // Nettoyer sprites
    this.clearAllPokemonSprites();
    
    if (this.battleBackground) {
      this.battleBackground.destroy();
      this.battleBackground = null;
    }
    
    // Nettoyer cache
    this.frameSizeCache.clear();
    
    super.destroy();
    
    console.log('‚úÖ [BattleScene] D√©truite');
  }
}

// ‚úÖ FONCTIONS GLOBALES DE TEST ET DEBUG

// Fonction utilitaire pour calcul 9x9
window.calculateFrameSize9x9 = function(imageWidth, imageHeight) {
  const frameWidth = Math.floor(imageWidth / 9);
  const frameHeight = Math.floor(imageHeight / 9);
  
  console.log(`üßÆ Calcul 9x9: ${imageWidth}x${imageHeight} ‚Üí ${frameWidth}x${frameHeight} par frame`);
  
  return {
    frameWidth,
    frameHeight,
    totalFrames: 81,
    grid: '9x9',
    coverage: {
      width: frameWidth * 9,
      height: frameHeight * 9,
      wastedWidth: imageWidth - (frameWidth * 9),
      wastedHeight: imageHeight - (frameHeight * 9)
    }
  };
};

// Test avec diff√©rentes tailles d'images
window.testFrameSizeCalculations = function() {
  console.log('üßÆ === TEST CALCULS FRAME SIZE 9x9 ===');
  
  const testSizes = [
    { w: 360, h: 360, desc: "Standard carr√©" },
    { w: 405, h: 405, desc: "Carr√© optimis√©" },
    { w: 288, h: 288, desc: "Petit carr√©" },
    { w: 576, h: 576, desc: "Grand carr√©" },
    { w: 720, h: 720, desc: "Tr√®s grand carr√©" },
    { w: 360, h: 450, desc: "Rectangle vertical" },
    { w: 450, h: 360, desc: "Rectangle horizontal" }
  ];
  
  testSizes.forEach(size => {
    console.log(`\nüìè ${size.desc} (${size.w}x${size.h}):`);
    const result = window.calculateFrameSize9x9(size.w, size.h);
    console.log(`   Frame: ${result.frameWidth}x${result.frameHeight}`);
    console.log(`   Couverture: ${result.coverage.width}x${result.coverage.height}`);
    if (result.coverage.wastedWidth > 0 || result.coverage.wastedHeight > 0) {
      console.log(`   ‚ö†Ô∏è Perte: ${result.coverage.wastedWidth}x${result.coverage.wastedHeight} pixels`);
    } else {
      console.log(`   ‚úÖ Couverture parfaite`);
    }
  });
  
  console.log('\nüéØ Tailles optimales recommand√©es pour 9x9:');
  console.log('   360x360 ‚Üí 40x40 (aucune perte)');
  console.log('   405x405 ‚Üí 45x45 (aucune perte)');
  console.log('   288x288 ‚Üí 32x32 (aucune perte)');
  console.log('   576x576 ‚Üí 64x64 (aucune perte)');
};

// Test recharge dynamique avec taille sp√©cifique
window.testSpecificFrameSize = function(pokemonId, view, frameWidth, frameHeight) {
  console.log(`üîÑ Test recharge ${pokemonId} ${view} avec frames ${frameWidth}x${frameHeight}`);
  
  const scene = window.game?.scene?.getScene('BattleScene');
  if (!scene) {
    console.error('‚ùå BattleScene non trouv√©e');
    return;
  }
  
  const spriteKey = `pokemon_${pokemonId}_${view}`;
  
  // Supprimer texture existante
  if (scene.textures.exists(spriteKey)) {
    scene.textures.remove(spriteKey);
    console.log(`üóëÔ∏è Texture ${spriteKey} supprim√©e`);
  }
  
  // Recharger avec nouvelle taille
  const pokemonNames = {
    1: 'bulbasaur', 4: 'charmander', 7: 'squirtle', 25: 'pikachu',
    39: 'jigglypuff', 52: 'meowth', 54: 'psyduck', 150: 'mewtwo'
  };
  
  const pokemonName = pokemonNames[pokemonId] || 'unknown';
  const imagePath = `assets/pokemon/${pokemonName}/${view}.png`;
  
  scene.load.spritesheet(spriteKey, imagePath, {
    frameWidth: frameWidth,
    frameHeight: frameHeight
  });
  
  scene.load.start();
  
  scene.load.once('complete', () => {
    console.log(`‚úÖ ${spriteKey} recharg√© avec frames ${frameWidth}x${frameHeight}`);
    
    // Mettre √† jour le cache
    scene.frameSizeCache.set(spriteKey, {
      frameWidth: frameWidth,
      frameHeight: frameHeight,
      totalFrames: 81,
      recalculated: true
    });
    
    // Relancer test d'affichage
    scene.testDisplayPokemon();
  });
};

// Test automatique avec tailles communes
window.testCommonPokemonSizes = function() {
  console.log('üß™ Test des tailles communes de Pok√©mon...');
  
  // Tester Charmander back avec 40x40 (image 360x360)
  window.testSpecificFrameSize(4, 'back', 40, 40);
  
  setTimeout(() => {
    // Tester Pikachu front avec 64x64 (image 576x576)
    window.testSpecificFrameSize(25, 'front', 64, 64);
  }, 2000);
};

// Test avec auto-d√©tection de taille optimale
window.testAutoDetectFrameSize = function(pokemonId, view) {
  console.log(`üîç Auto-d√©tection taille optimale pour Pok√©mon ${pokemonId} ${view}`);
  
  const scene = window.game?.scene?.getScene('BattleScene');
  if (!scene) {
    console.error('‚ùå BattleScene non trouv√©e');
    return;
  }
  
  const spriteKey = `pokemon_${pokemonId}_${view}`;
  
  // Si d√©j√† charg√©, obtenir la taille
  if (scene.textures.exists(spriteKey)) {
    const texture = scene.textures.get(spriteKey);
    const source = texture.source[0];
    const imageWidth = source.width;
    const imageHeight = source.height;
    
    console.log(`üìä Image actuelle: ${imageWidth}x${imageHeight}`);
    
    // Calculer taille optimale 9x9
    const optimal = window.calculateFrameSize9x9(imageWidth, imageHeight);
    
    console.log(`üéØ Taille optimale calcul√©e: ${optimal.frameWidth}x${optimal.frameHeight}`);
    
    // Recharger avec la taille optimale
    window.testSpecificFrameSize(pokemonId, view, optimal.frameWidth, optimal.frameHeight);
    
    return optimal;
  } else {
    console.warn(`‚ö†Ô∏è Texture ${spriteKey} non charg√©e`);
    return null;
  }
};

// Fonction de test compl√®te avec masquage UI
window.testBattleSprites = function() {
  console.log('üß™ === TEST COMPLET SPRITES 9x9 ===');
  
  // ‚úÖ Masquer compl√®tement l'UI
  if (window.hideAllUI) {
    const hiddenCount = window.hideAllUI();
    console.log(`‚úÖ ${hiddenCount} √©l√©ments UI masqu√©s`);
  }
  
  // Activer BattleScene
  setTimeout(() => {
    const battleScene = window.game?.scene?.getScene('BattleScene');
    if (battleScene) {
      // Activer si n√©cessaire
      if (!window.game.scene.isActive('BattleScene')) {
        console.log('üé¨ Activation BattleScene...');
        window.game.scene.start('BattleScene');
        
        setTimeout(() => {
          const activeBattleScene = window.game.scene.getScene('BattleScene');
          if (activeBattleScene) {
            activeBattleScene.testDisplayPokemon();
          }
        }, 500);
      } else {
        battleScene.testDisplayPokemon();
      }
      
      console.log('‚úÖ Test sprites 9x9 lanc√© avec UI masqu√©e');
    } else {
      console.error('‚ùå BattleScene non trouv√©e');
    }
  }, 300);
  
  // Debug apr√®s test
  setTimeout(() => {
    window.debugSpriteStatus();
  }, 4000);
};

// Debug status des sprites
window.debugSpriteStatus = function() {
  console.log('üîç === DEBUG STATUS SPRITES ===');
  
  const scene = window.game?.scene?.getScene('BattleScene');
  if (scene && scene.debugCurrentSprites) {
    scene.debugCurrentSprites();
  }
  
  if (scene && scene.debugLoadedTextures) {
    scene.debugLoadedTextures();
  }
  
  console.log('üîç === FIN DEBUG ===');
};

// Test sp√©cialis√© pour diff√©rentes configurations
window.testPokemonConfiguration = function(config) {
  console.log('üéÆ Test configuration Pok√©mon:', config);
  
  const scene = window.game?.scene?.getScene('BattleScene');
  if (!scene) {
    console.error('‚ùå BattleScene non trouv√©e');
    return;
  }
  
  // Configuration par d√©faut
  const defaultConfig = {
    playerId: 4,
    opponentId: 25,
    playerFrameSize: { width: 40, height: 40 },
    opponentFrameSize: { width: 64, height: 64 },
    showAnimations: true,
    clearFirst: true
  };
  
  const finalConfig = { ...defaultConfig, ...config };
  
  if (finalConfig.clearFirst) {
    scene.clearAllPokemonSprites();
  }
  
  // Test avec configuration sp√©cifique
  setTimeout(() => {
    const playerPokemon = {
      pokemonId: finalConfig.playerId,
      name: `TestPlayer${finalConfig.playerId}`,
      level: 5,
      types: ['fire']
    };
    scene.displayPlayerPokemon(playerPokemon);
  }, 500);
  
  setTimeout(() => {
    const opponentPokemon = {
      pokemonId: finalConfig.opponentId,
      name: `TestOpponent${finalConfig.opponentId}`,
      level: 8,
      types: ['electric']
    };
    scene.displayOpponentPokemon(opponentPokemon);
  }, 1200);
};

console.log('‚úÖ [BattleScene] Module charg√© avec support sprites 9x9');
console.log('üß™ Fonctions de test disponibles:');
console.log('   window.testBattleSprites() - Test complet');
console.log('   window.calculateFrameSize9x9(w, h) - Calcul frames');
console.log('   window.testFrameSizeCalculations() - Test calculs');
console.log('   window.testSpecificFrameSize(id, view, fw, fh) - Test taille sp√©cifique');
console.log('   window.testAutoDetectFrameSize(id, view) - Auto-d√©tection');
console.log('   window.testCommonPokemonSizes() - Tailles communes');
console.log('   window.debugSpriteStatus() - Debug sprites');
console.log('üéØ Utilisez testBattleSprites() pour commencer!');
