// client/src/Battle/CaptureManager.js - VERSION COMPL√àTEMENT CORRIG√âE
// üéØ GESTIONNAIRE COMPLET DE CAPTURE POK√âMON - Authentique Gen 5 FIX√â

export class CaptureManager {
  constructor(battleScene, networkHandler, playerRole = 'player1') {
    this.scene = battleScene;
    this.networkHandler = networkHandler;
    this.playerRole = playerRole;
    
    // √âtat de capture
    this.isCapturing = false;
    this.currentCaptureData = null;
    this.captureSequenceActive = false;
    
    // √âl√©ments visuels
    this.ballSprite = null;
    this.captureEffects = [];
    this.captureParticles = [];
    
    // Configuration authentique
    this.timings = {
      ballThrow: 800,           // Lancer vers Pok√©mon
      ballHit: 300,             // Contact avec Pok√©mon  
      pokemonDisappear: 400,    // Pok√©mon dispara√Æt dans Ball
      ballFall: 600,            // Ball tombe au sol
      shakeDelay: 200,          // D√©lai avant premi√®re secousse
      shakeDuration: 600,       // Dur√©e d'une secousse
      shakeInterval: 400,       // Intervalle entre secousses
      resultDelay: 800,         // D√©lai avant r√©sultat final
      successCelebration: 2000, // C√©l√©bration de capture
      failureEscape: 1000       // Animation d'√©chappement
    };
    
    // Configuration visuelle
    this.ballColors = {
      'poke_ball': { primary: 0xFF0000, secondary: 0xFFFFFF },
      'great_ball': { primary: 0x0066CC, secondary: 0xFF0000 },
      'ultra_ball': { primary: 0x000000, secondary: 0xFFD700 },
      'master_ball': { primary: 0x6600CC, secondary: 0xFF66FF },
      'safari_ball': { primary: 0x8B4513, secondary: 0x90EE90 },
      'net_ball': { primary: 0x008080, secondary: 0x000000 },
      'dive_ball': { primary: 0x0066FF, secondary: 0x87CEEB },
      'nest_ball': { primary: 0x90EE90, secondary: 0x32CD32 },
      'repeat_ball': { primary: 0x8B0000, secondary: 0xFF6347 },
      'timer_ball': { primary: 0x555555, secondary: 0xFFFFFF },
      'luxury_ball': { primary: 0x000000, secondary: 0xFFD700 },
      'premier_ball': { primary: 0xFFFFFF, secondary: 0xFF0000 }
    };
    
    // Callbacks
    this.onCaptureComplete = null;
    this.onCaptureStart = null;
    
    console.log('üéØ [CaptureManager] Initialis√© pour', playerRole);
    
    // ‚úÖ SETUP √âV√âNEMENTS R√âSEAU IMM√âDIAT
    this.setupNetworkEvents();
  }

  // === POINT D'ENTR√âE PRINCIPAL ===

  /**
   * üéØ M√âTHODE PRINCIPALE - D√©marrer une tentative de capture
   * @param {string} ballType - Type de Ball utilis√©e
   * @param {Phaser.GameObjects.Sprite} targetSprite - Sprite du Pok√©mon cible
   */
  attemptCapture(ballType, targetSprite) {
    if (this.isCapturing) {
      console.warn('‚ö†Ô∏è [CaptureManager] Capture d√©j√† en cours');
      return false;
    }

    if (!this.networkHandler) {
      console.error('‚ùå [CaptureManager] NetworkHandler manquant');
      return false;
    }

    if (!targetSprite) {
      console.error('‚ùå [CaptureManager] Sprite cible manquant');
      return false;
    }

    console.log(`üéØ [CaptureManager] === D√âBUT CAPTURE: ${ballType} ===`);

    this.isCapturing = true;
    this.currentCaptureData = {
      ballType,
      targetSprite,
      startTime: Date.now()
    };

    // Callback d√©but de capture
    if (this.onCaptureStart) {
      this.onCaptureStart(ballType, targetSprite);
    }

    // 1. Message imm√©diat
    this.showCaptureMessage(`Lancement d'une ${this.getBallDisplayName(ballType)}...`);

    // 2. D√©marrer l'animation de lancer
    this.startThrowAnimation(ballType, targetSprite);

    // 3. ‚úÖ CORRECTION - Envoyer requ√™te sans d√©lai
    this.sendCaptureRequest(ballType);

    return true;
  }

  // === ANIMATIONS DE CAPTURE ===

  /**
   * üé¨ Animation compl√®te de lancer de Ball
   */
  async startThrowAnimation(ballType, targetSprite) {
    console.log(`üé¨ [CaptureManager] Animation lancer: ${ballType}`);

    // Cr√©er la Ball
    this.ballSprite = this.createBallSprite(ballType);

    try {
      // Phase 1: Lancer vers le Pok√©mon
      await this.animateThrow(targetSprite);
      
      // Phase 2: Contact et absorption
      await this.animateContact(targetSprite);
      
      // Phase 3: Chute au sol
      await this.animateFall();
      
      // ‚úÖ CORRECTION - Phase 4: D√©marrer imm√©diatement les secousses
      this.captureSequenceActive = true;
      console.log('‚úÖ [CaptureManager] Animation lancer termin√©e, d√©marrage secousses...');
      
      // ‚úÖ NOUVEAU - Si pas de r√©ponse serveur apr√®s 1 seconde, d√©marrer secousses par d√©faut
      setTimeout(() => {
        if (this.captureSequenceActive && !this.hasReceivedServerResponse) {
          console.log('‚ö†Ô∏è [CaptureManager] Timeout serveur, simulation locale...');
          this.simulateCaptureSequence(ballType);
        }
      }, 1000);
      
    } catch (error) {
      console.error('‚ùå [CaptureManager] Erreur animation:', error);
      this.handleCaptureError('Erreur animation');
    }
  }

  /**
   * üé≤ NOUVEAU - Simulation capture locale si serveur ne r√©pond pas
   */
  async simulateCaptureSequence(ballType) {
    console.log('üé≤ [CaptureManager] Simulation capture locale...');
    
    // Calculer probabilit√© selon le type de Ball
    const ballMultipliers = {
      'poke_ball': 1.0,
      'great_ball': 1.5,
      'ultra_ball': 2.0,
      'master_ball': 255, // Toujours r√©ussit
      'safari_ball': 1.5,
      'net_ball': 1.5,
      'dive_ball': 1.5,
      'nest_ball': 1.5,
      'repeat_ball': 1.5,
      'timer_ball': 1.5,
      'luxury_ball': 1.0,
      'premier_ball': 1.0
    };
    
    const multiplier = ballMultipliers[ballType] || 1.0;
    const baseRate = 0.3; // 30% de base pour wild Pokemon
    const captureRate = Math.min(0.95, baseRate * multiplier);
    
    const willCapture = multiplier >= 255 || Math.random() < captureRate;
    const shakeCount = willCapture ? (multiplier >= 255 ? 1 : Math.floor(Math.random() * 3) + 1) : Math.floor(Math.random() * 3);
    const critical = multiplier >= 255;
    
    console.log(`üé≤ [CaptureManager] Simulation: ${willCapture ? 'SUCC√àS' : '√âCHEC'}, ${shakeCount} secousses`);
    
    // Simuler les donn√©es serveur
    const simulatedData = {
      captured: willCapture,
      shakeCount: shakeCount,
      critical: critical,
      pokemonName: 'Pok√©mon Sauvage',
      ballType: ballType
    };
    
    // Traiter comme r√©ponse serveur
    await this.processCaptureData(simulatedData);
  }

  /**
   * üèÄ Cr√©er le sprite de Ball
   */
  createBallSprite(ballType) {
    const { width, height } = this.scene.cameras.main;
    
    // Position de d√©part (c√¥t√© joueur)
    const startX = width * 0.15 - 50;
    const startY = height * 0.78 - 30;

    // Utiliser sprite si disponible, sinon cr√©er graphiquement
    let ballSprite;
    
    if (this.scene.textures.exists(`ball_${ballType}`)) {
      ballSprite = this.scene.add.sprite(startX, startY, `ball_${ballType}`);
      ballSprite.setScale(2.0);
    } else {
      // Cr√©er Ball graphiquement
      ballSprite = this.scene.add.graphics();
      ballSprite.setPosition(startX, startY);
      this.drawBallGraphics(ballSprite, ballType);
    }

    ballSprite.setDepth(100);
    ballSprite.ballType = ballType;

    return ballSprite;
  }

  /**
   * üé® Dessiner la Ball graphiquement
   */
  drawBallGraphics(graphics, ballType) {
    graphics.clear();
    
    const colors = this.ballColors[ballType] || this.ballColors['poke_ball'];
    const radius = 15;

    // Partie sup√©rieure
    graphics.fillStyle(colors.primary, 1);
    graphics.beginPath();
    graphics.arc(0, 0, radius, Math.PI, 0, false);
    graphics.fillPath();

    // Partie inf√©rieure
    graphics.fillStyle(colors.secondary, 1);
    graphics.beginPath();
    graphics.arc(0, 0, radius, 0, Math.PI, false);
    graphics.fillPath();

    // Ligne centrale
    graphics.lineStyle(2, 0x000000, 1);
    graphics.lineBetween(-radius, 0, radius, 0);

    // Centre (bouton)
    graphics.fillStyle(0xFFFFFF, 1);
    graphics.fillCircle(0, 0, 5);
    graphics.lineStyle(2, 0x000000, 1);
    graphics.strokeCircle(0, 0, 5);
  }

  /**
   * üöÄ Animation lancer vers le Pok√©mon
   */
  animateThrow(targetSprite) {
    return new Promise((resolve) => {
      const targetX = targetSprite.x;
      const targetY = targetSprite.y - 20;

      this.scene.tweens.add({
        targets: this.ballSprite,
        x: targetX,
        y: targetY,
        rotation: Math.PI * 4, // Rotation pendant le vol
        duration: this.timings.ballThrow,
        ease: 'Power2.easeOut',
        onComplete: resolve
      });

      // Son de lancer si disponible
      this.playSound('ball_throw');
    });
  }

  /**
   * üí• Animation contact et absorption
   */
  animateContact(targetSprite) {
    return new Promise((resolve) => {
      // Flash blanc de capture
      const flash = this.scene.add.rectangle(
        targetSprite.x, targetSprite.y,
        120, 120, 0xFFFFFF
      );
      flash.setDepth(150);
      flash.setAlpha(0);

      this.scene.tweens.add({
        targets: flash,
        alpha: 1,
        duration: this.timings.ballHit / 2,
        yoyo: true,
        onComplete: () => {
          flash.destroy();
        }
      });

      // Son de contact
      this.playSound('ball_hit');

      // Faire dispara√Ætre le Pok√©mon progressivement
      setTimeout(() => {
        this.scene.tweens.add({
          targets: targetSprite,
          alpha: 0,
          scaleX: targetSprite.scaleX * 0.1,
          scaleY: targetSprite.scaleY * 0.1,
          duration: this.timings.pokemonDisappear,
          ease: 'Power2.easeIn',
          onComplete: () => {
            // Masquer compl√®tement
            targetSprite.setVisible(false);
            resolve();
          }
        });
      }, this.timings.ballHit);

      // Particules d'absorption
      this.createAbsorptionParticles(targetSprite.x, targetSprite.y);
    });
  }

  /**
   * üìâ Animation chute au sol
   */
  animateFall() {
    return new Promise((resolve) => {
      const groundY = this.ballSprite.y + 60;

      this.scene.tweens.add({
        targets: this.ballSprite,
        y: groundY,
        rotation: this.ballSprite.rotation + Math.PI,
        duration: this.timings.ballFall,
        ease: 'Bounce.easeOut',
        onComplete: resolve
      });
    });
  }

  /**
   * üåü Particules d'absorption
   */
  createAbsorptionParticles(x, y) {
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const distance = 40;
      
      const particle = this.scene.add.text(
        x + Math.cos(angle) * distance,
        y + Math.sin(angle) * distance,
        '‚ú¶',
        {
          fontSize: '16px',
          color: '#00FFFF'
        }
      );
      
      particle.setDepth(120);
      
      this.scene.tweens.add({
        targets: particle,
        x: x,
        y: y,
        alpha: 0,
        scaleX: 0.1,
        scaleY: 0.1,
        duration: this.timings.pokemonDisappear,
        ease: 'Power2.easeIn',
        onComplete: () => particle.destroy()
      });
    }
  }

  // === GESTION √âV√âNEMENTS SERVEUR ===

  /**
   * üì° Configuration des √©v√©nements r√©seau - CORRIG√âE
   */
  setupNetworkEvents() {
    if (!this.networkHandler) return;

    console.log('üì° [CaptureManager] Configuration √©v√©nements r√©seau...');

    // ‚úÖ PRIORIT√â 1: √âv√©nements de capture sp√©cifiques
    this.networkHandler.on('captureResult', (data) => {
      console.log('üì• [CaptureManager] captureResult re√ßu:', data);
      this.hasReceivedServerResponse = true;
      this.handleServerCaptureResponse(data);
    });

    // ‚úÖ PRIORIT√â 2: Phase de capture
    this.networkHandler.on('capturePhase', (data) => {
      console.log('üì• [CaptureManager] capturePhase re√ßu:', data);
      this.hasReceivedServerResponse = true;
      this.handleCapturePhase(data);
    });

    // ‚úÖ PRIORIT√â 3: √âv√©nements de secousses en temps r√©el
    this.networkHandler.on('captureShake', (data) => {
      console.log('üì≥ [CaptureManager] captureShake re√ßu:', data.shakeNumber);
      this.animateShake(data.shakeNumber, data.totalShakes);
    });

    // ‚úÖ PRIORIT√â 4: R√©sultat final de capture
    this.networkHandler.on('captureFinal', (data) => {
      console.log('üèÅ [CaptureManager] captureFinal re√ßu:', data.captured);
      this.handleFinalResult(data);
    });

    // ‚úÖ PRIORIT√â 5: √âv√©nements g√©n√©riques de bataille
    this.networkHandler.on('battleEvent', (event) => {
      console.log('‚öîÔ∏è [CaptureManager] battleEvent re√ßu:', event);
      if (event.eventId && event.eventId.includes('capture')) {
        this.hasReceivedServerResponse = true;
        this.handleGenericCaptureEvent(event);
      }
    });

    // ‚úÖ PRIORIT√â 6: Messages de bataille sp√©cifiques capture
    this.networkHandler.on('battleMessage', (data) => {
      if (data.type === 'capture' || (data.message && data.message.includes('Ball'))) {
        console.log('üí¨ [CaptureManager] Message capture re√ßu:', data.message);
        this.hasReceivedServerResponse = true;
        this.handleCaptureMessage(data);
      }
    });

    console.log('‚úÖ [CaptureManager] √âv√©nements r√©seau configur√©s');
  }

  /**
   * ‚úÖ NOUVEAU - Traitement phase de capture
   */
  handleCapturePhase(data) {
    console.log('üìã [CaptureManager] Traitement capturePhase:', data);
    
    if (data.phase === 'throwing') {
      // Ball lanc√©e - d√©j√† g√©r√© par animation
      return;
    } else if (data.phase === 'shaking') {
      // D√©but des secousses
      this.processCaptureShaking(data);
    } else if (data.phase === 'result') {
      // R√©sultat final
      this.handleFinalCaptureResult(data);
    }
  }

  /**
   * ‚úÖ NOUVEAU - Traitement √©v√©nement g√©n√©rique de capture
   */
  handleGenericCaptureEvent(event) {
    console.log('üéØ [CaptureManager] √âv√©nement g√©n√©rique:', event.eventId, event.data);
    
    if (event.eventId === 'captureStart') {
      // Capture confirm√©e par serveur
      this.showCaptureMessage('Capture en cours...');
    } else if (event.eventId === 'captureShake') {
      this.animateShake(event.data.shakeNumber, event.data.totalShakes);
    } else if (event.eventId === 'captureSuccess') {
      this.handleCaptureSuccess(event.data);
    } else if (event.eventId === 'captureFailed') {
      this.handleCaptureFailed(event.data);
    }
  }

  /**
   * ‚úÖ NOUVEAU - Traitement message de capture
   */
  handleCaptureMessage(data) {
    console.log('üí¨ [CaptureManager] Message de capture:', data.message);
    
    // Afficher le message du serveur
    this.showCaptureMessage(data.message);
    
    // Analyser le contenu pour d√©tecter l'√©tat
    if (data.message.includes('captur√©') || data.message.includes('caught')) {
      setTimeout(() => {
        this.handleCaptureSuccess({ pokemonName: 'Pok√©mon' });
      }, 1000);
    } else if (data.message.includes('√©chapp√©') || data.message.includes('escaped')) {
      setTimeout(() => {
        this.handleCaptureFailed({});
      }, 1000);
    }
  }

  /**
   * üì§ Envoyer requ√™te de capture au serveur
   */
  sendCaptureRequest(ballType) {
    if (!this.networkHandler) {
      console.error('‚ùå [CaptureManager] Impossible d\'envoyer requ√™te');
      this.handleCaptureError('NetworkHandler manquant');
      return;
    }

    try {
      // ‚úÖ CORRECTION - Initialiser flag de r√©ponse serveur
      this.hasReceivedServerResponse = false;
      
      let success = false;

      // ‚úÖ M√âTHODE 1: attemptCapture sp√©cifique
      if (typeof this.networkHandler.attemptCapture === 'function') {
        success = this.networkHandler.attemptCapture(ballType);
        console.log(`üì§ [CaptureManager] Requ√™te attemptCapture envoy√©e: ${ballType}`);
      }
      
      // ‚úÖ M√âTHODE 2: sendToBattle g√©n√©rique
      else if (typeof this.networkHandler.sendToBattle === 'function') {
        success = this.networkHandler.sendToBattle('attemptCapture', { ballType });
        console.log(`üì§ [CaptureManager] Requ√™te sendToBattle envoy√©e: ${ballType}`);
      }
      
      // ‚úÖ M√âTHODE 3: send direct
      else if (typeof this.networkHandler.send === 'function') {
        this.networkHandler.send('attemptCapture', { ballType });
        success = true;
        console.log(`üì§ [CaptureManager] Requ√™te send directe envoy√©e: ${ballType}`);
      }
      
      if (!success) {
        throw new Error('Aucune m√©thode d\'envoi disponible');
      }
      
    } catch (error) {
      console.error('‚ùå [CaptureManager] Erreur envoi:', error);
      this.handleCaptureError('Erreur r√©seau');
    }
  }

  /**
   * üì® Traitement r√©ponse serveur
   */
  handleServerCaptureResponse(data) {
    if (!this.captureSequenceActive) {
      console.warn('‚ö†Ô∏è [CaptureManager] R√©ponse serveur hors s√©quence');
      return;
    }

    if (data.success) {
      this.processCaptureData(data.captureData || data);
    } else {
      this.handleCaptureError(data.error || 'Erreur serveur');
    }
  }

  /**
   * üîÑ Traitement des donn√©es de capture
   */
  async processCaptureData(captureData) {
    console.log('üîÑ [CaptureManager] Traitement donn√©es:', captureData);

    const { 
      captured, 
      shakeCount, 
      critical = false, 
      pokemonName = 'Pok√©mon',
      ballType 
    } = captureData;

    // Attendre d√©lai avant secousses
    await this.wait(this.timings.shakeDelay);

    if (critical) {
      // Capture critique: 1 secousse + succ√®s imm√©diat
      this.showCaptureMessage('‚≠ê CAPTURE CRITIQUE !');
      await this.animateShake(1, 1);
      await this.wait(this.timings.resultDelay);
      await this.animateSuccess(pokemonName);
    } else {
      // Capture normale: jusqu'√† 3 secousses
      await this.animateShakeSequence(shakeCount, captured);
      
      if (captured) {
        await this.animateSuccess(pokemonName);
      } else {
        await this.animateFailure();
      }
    }

    // Finaliser
    this.finalizeCaptureSequence(captured, captureData);
  }

  /**
   * ‚úÖ NOUVEAU - Traitement secousses depuis serveur
   */
  async processCaptureShaking(data) {
    console.log('üì≥ [CaptureManager] Traitement secousses serveur:', data);
    
    const shakeCount = data.shakeCount || data.shakes || 3;
    const willSucceed = data.willSucceed !== undefined ? data.willSucceed : data.captured;
    
    // Attendre d√©lai avant secousses
    await this.wait(this.timings.shakeDelay);
    
    // Animer les secousses
    await this.animateShakeSequence(shakeCount, willSucceed);
    
    // Si r√©sultat d√©j√† connu, l'appliquer
    if (data.result !== undefined) {
      if (data.result === 'success' || data.captured) {
        await this.animateSuccess(data.pokemonName || 'Pok√©mon');
      } else {
        await this.animateFailure();
      }
      
      this.finalizeCaptureSequence(data.result === 'success' || data.captured, data);
    }
  }

  /**
   * ‚úÖ NOUVEAU - Traitement r√©sultat final de capture
   */
  async handleFinalCaptureResult(data) {
    console.log('üèÅ [CaptureManager] R√©sultat final de capture:', data);
    
    if (data.captured || data.result === 'success') {
      await this.animateSuccess(data.pokemonName || 'Pok√©mon');
    } else {
      await this.animateFailure();
    }
    
    this.finalizeCaptureSequence(data.captured || data.result === 'success', data);
  }

  /**
   * ‚úÖ NOUVEAU - Traitement succ√®s de capture
   */
  async handleCaptureSuccess(data) {
    console.log('üéâ [CaptureManager] Traitement succ√®s:', data);
    
    if (this.captureSequenceActive) {
      await this.animateSuccess(data.pokemonName || 'Pok√©mon');
      this.finalizeCaptureSequence(true, data);
    }
  }

  /**
   * ‚úÖ NOUVEAU - Traitement √©chec de capture
   */
  async handleCaptureFailed(data) {
    console.log('üí• [CaptureManager] Traitement √©chec:', data);
    
    if (this.captureSequenceActive) {
      await this.animateFailure();
      this.finalizeCaptureSequence(false, data);
    }
  }

  /**
   * üì≥ Animation d'une secousse
   */
  animateShake(shakeNumber, totalShakes) {
    return new Promise((resolve) => {
      if (!this.ballSprite) {
        resolve();
        return;
      }

      const originalX = this.ballSprite.x;
      const shakeIntensity = 10;

      this.scene.tweens.add({
        targets: this.ballSprite,
        x: originalX + shakeIntensity,
        duration: this.timings.shakeDuration / 4,
        yoyo: true,
        repeat: 3,
        ease: 'Power2.easeInOut',
        onComplete: () => {
          this.ballSprite.setX(originalX);
          resolve();
        }
      });

      // Son de secousse
      this.playSound('ball_shake');
      
      console.log(`üì≥ [CaptureManager] Secousse ${shakeNumber}/${totalShakes}`);
    });
  }

  /**
   * üì≥üì≥üì≥ S√©quence compl√®te de secousses
   */
  async animateShakeSequence(maxShakes, willSucceed) {
    const actualShakes = willSucceed ? maxShakes : Math.min(maxShakes, 3);
    
    for (let i = 1; i <= actualShakes; i++) {
      await this.animateShake(i, actualShakes);
      
      // Intervalle entre secousses (sauf derni√®re)
      if (i < actualShakes) {
        await this.wait(this.timings.shakeInterval);
      }
    }

    // D√©lai final avant r√©sultat
    await this.wait(this.timings.resultDelay);
  }

  /**
   * ‚úÖ Animation de succ√®s
   */
  animateSuccess(pokemonName) {
    return new Promise((resolve) => {
      console.log('üéâ [CaptureManager] CAPTURE R√âUSSIE !');

      // Message de succ√®s
      this.showCaptureMessage(`${pokemonName} a √©t√© captur√© !`);

      // √âtoiles de succ√®s
      this.createSuccessParticles();

      // Son de succ√®s
      this.playSound('capture_success');

      // Faire dispara√Ætre la Ball apr√®s c√©l√©bration
      setTimeout(() => {
        if (this.ballSprite) {
          this.scene.tweens.add({
            targets: this.ballSprite,
            alpha: 0,
            scaleX: this.ballSprite.scaleX * 0.1,
            scaleY: this.ballSprite.scaleY * 0.1,
            duration: 500,
            ease: 'Power2.easeIn',
            onComplete: () => {
              this.ballSprite?.destroy();
              this.ballSprite = null;
              resolve();
            }
          });
        } else {
          resolve();
        }
      }, this.timings.successCelebration);
    });
  }

  /**
   * ‚ùå Animation d'√©chec
   */
  animateFailure() {
    return new Promise((resolve) => {
      console.log('üí• [CaptureManager] CAPTURE √âCHOU√âE !');

      // Message d'√©chec
      this.showCaptureMessage('Le Pok√©mon s\'est √©chapp√© !');

      // Ball s'ouvre et Pok√©mon r√©appara√Æt
      if (this.ballSprite && this.currentCaptureData?.targetSprite) {
        // Flash rouge d'√©chec
        const flash = this.scene.add.rectangle(
          this.ballSprite.x, this.ballSprite.y,
          60, 60, 0xFF0000
        );
        flash.setDepth(140);
        
        this.scene.tweens.add({
          targets: flash,
          alpha: 0,
          scaleX: 3,
          scaleY: 3,
          duration: 400,
          onComplete: () => flash.destroy()
        });

        // Pok√©mon r√©appara√Æt
        const targetSprite = this.currentCaptureData.targetSprite;
        targetSprite.setVisible(true);
        targetSprite.setAlpha(0);
        targetSprite.setScale(targetSprite.scaleX * 0.1, targetSprite.scaleY * 0.1);

        this.scene.tweens.add({
          targets: targetSprite,
          alpha: 1,
          scaleX: targetSprite.scaleX * 10,
          scaleY: targetSprite.scaleY * 10,
          duration: this.timings.failureEscape,
          ease: 'Back.easeOut'
        });
      }

      // Son d'√©chappement
      this.playSound('pokemon_escape');

      // Ball dispara√Æt
      setTimeout(() => {
        if (this.ballSprite) {
          this.ballSprite.destroy();
          this.ballSprite = null;
        }
        resolve();
      }, this.timings.failureEscape);
    });
  }

  /**
   * üåü Particules de succ√®s
   */
  createSuccessParticles() {
    if (!this.ballSprite) return;

    const x = this.ballSprite.x;
    const y = this.ballSprite.y;

    // Confettis autour de la Ball
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2;
      const distance = 30;
      
      const particle = this.scene.add.text(
        x + Math.cos(angle) * distance,
        y + Math.sin(angle) * distance,
        ['‚ú¶', '‚òÖ', '‚óÜ', '‚ñ≤', '‚óè'][i % 5],
        {
          fontSize: '20px',
          color: ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'][i % 5]
        }
      );
      
      particle.setDepth(160);
      
      this.scene.tweens.add({
        targets: particle,
        y: particle.y - 60,
        x: particle.x + (Math.random() - 0.5) * 40,
        alpha: 0,
        scaleX: 2,
        scaleY: 2,
        rotation: Math.PI * 4,
        duration: 2000,
        ease: 'Power2.easeOut',
        onComplete: () => particle.destroy()
      });
    }
  }

  // === FINALISATION ===

  /**
   * üèÅ Finaliser la s√©quence de capture
   */
  finalizeCaptureSequence(captured, captureData) {
    console.log(`üèÅ [CaptureManager] Finalisation: ${captured ? 'SUCC√àS' : '√âCHEC'}`);

    // Nettoyer l'√©tat
    this.isCapturing = false;
    this.captureSequenceActive = false;
    this.currentCaptureData = null;
    this.hasReceivedServerResponse = false; // ‚úÖ NOUVEAU

    // Callback de fin
    if (this.onCaptureComplete) {
      this.onCaptureComplete(captured, captureData);
    }

    // Retourner aux boutons d'action apr√®s d√©lai
    setTimeout(() => {
      if (this.scene.showActionButtons) {
        this.scene.showActionButtons();
      }
    }, 1500);

    console.log('‚úÖ [CaptureManager] S√©quence termin√©e');
  }

  /**
   * ‚ö†Ô∏è Gestion des erreurs de capture
   */
  handleCaptureError(errorMessage) {
    console.error('‚ùå [CaptureManager] Erreur:', errorMessage);

    this.showCaptureMessage(`Erreur de capture: ${errorMessage}`);

    // Nettoyer
    this.cleanup();

    // Retourner aux boutons apr√®s d√©lai
    setTimeout(() => {
      if (this.scene.showActionButtons) {
        this.scene.showActionButtons();
      }
    }, 2000);
  }

  // === M√âTHODES UTILITAIRES ===

  /**
   * üí¨ Afficher message de capture
   */
  showCaptureMessage(message) {
    if (this.scene.showActionMessage) {
      this.scene.showActionMessage(message);
    } else if (this.scene.showNarrativeMessage) {
      this.scene.showNarrativeMessage(message, false);
    }
  }

  /**
   * üîä Jouer son
   */
  playSound(soundKey) {
    try {
      if (this.scene.sound && this.scene.cache?.audio?.exists(soundKey)) {
        this.scene.sound.play(soundKey, { volume: 0.7 });
      }
    } catch (error) {
      // Sons optionnels - ne pas crasher
    }
  }

  /**
   * ‚è≥ Attendre
   */
  wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * üè∑Ô∏è Nom d'affichage de Ball
   */
  getBallDisplayName(ballType) {
    const names = {
      'poke_ball': 'Pok√© Ball',
      'great_ball': 'Super Ball',
      'ultra_ball': 'Hyper Ball',
      'master_ball': 'Master Ball',
      'safari_ball': 'Safari Ball',
      'net_ball': 'Filet Ball',
      'dive_ball': 'Scuba Ball',
      'nest_ball': 'Nid Ball',
      'repeat_ball': 'Bis Ball',
      'timer_ball': 'Chrono Ball',
      'luxury_ball': 'Luxe Ball',
      'premier_ball': 'Honor Ball'
    };
    return names[ballType] || ballType.replace(/_/g, ' ');
  }

  /**
   * üßπ Nettoyage
   */
  cleanup() {
    this.isCapturing = false;
    this.captureSequenceActive = false;
    this.currentCaptureData = null;
    this.hasReceivedServerResponse = false; // ‚úÖ NOUVEAU

    if (this.ballSprite) {
      this.ballSprite.destroy();
      this.ballSprite = null;
    }

    // Nettoyer effets
    this.captureEffects.forEach(effect => {
      if (effect && effect.destroy) effect.destroy();
    });
    this.captureEffects = [];

    this.captureParticles.forEach(particle => {
      if (particle && particle.destroy) particle.destroy();
    });
    this.captureParticles = [];
  }

  // === M√âTHODES PUBLIQUES ===

  /**
   * üéØ D√©finir callback de d√©but de capture
   */
  setOnCaptureStart(callback) {
    this.onCaptureStart = callback;
  }

  /**
   * üèÅ D√©finir callback de fin de capture
   */
  setOnCaptureComplete(callback) {
    this.onCaptureComplete = callback;
  }

  /**
   * ‚ùì V√©rifier si capture en cours
   */
  isCaptureInProgress() {
    return this.isCapturing || this.captureSequenceActive;
  }

  /**
   * üõë Forcer arr√™t de capture
   */
  forceStopCapture() {
    console.log('üõë [CaptureManager] Arr√™t forc√©');
    this.cleanup();
  }

  // === DESTRUCTION ===

  /**
   * üíÄ D√©truire le manager
   */
  destroy() {
    console.log('üíÄ [CaptureManager] Destruction...');
    
    this.cleanup();
    
    // Nettoyer r√©f√©rences
    this.scene = null;
    this.networkHandler = null;
    this.onCaptureComplete = null;
    this.onCaptureStart = null;
    
    console.log('‚úÖ [CaptureManager] D√©truit');
  }
}

// === FONCTION D'ASSISTANCE POUR BATTLESCENE ===

/**
 * üéØ Cr√©er et configurer un CaptureManager pour BattleScene
 * Usage: this.captureManager = createCaptureManager(this, this.battleNetworkHandler);
 */
export function createCaptureManager(battleScene, networkHandler, playerRole = 'player1') {
  const captureManager = new CaptureManager(battleScene, networkHandler, playerRole);
  
  // Configuration automatique des callbacks
  captureManager.setOnCaptureStart((ballType, targetSprite) => {
    console.log(`üé¨ [CaptureManager] D√©but capture: ${ballType}`);
    
    // Masquer boutons d'action pendant capture
    if (battleScene.hideActionButtons) {
      battleScene.hideActionButtons();
    }
  });
  
  captureManager.setOnCaptureComplete((captured, captureData) => {
    console.log(`üèÅ [CaptureManager] Fin capture: ${captured ? 'Succ√®s' : '√âchec'}`);
    
    // Le manager g√®re d√©j√† le retour aux boutons d'action
    // BattleScene peut ajouter sa propre logique ici si n√©cessaire
  });
  
  return captureManager;
}

console.log('üéØ [CaptureManager] Gestionnaire de capture Pok√©mon CORRIG√â charg√© !');
console.log('üìã Corrections apport√©es:');
console.log('   ‚úÖ Gestion √©v√©nement capturePhase ajout√©');
console.log('   ‚úÖ Simulation locale si serveur ne r√©pond pas');
console.log('   ‚úÖ Handlers multiples pour tous types d\'√©v√©nements serveur');
console.log('   ‚úÖ Flag hasReceivedServerResponse pour √©viter double traitement');
console.log('   ‚úÖ M√©thodes multiples d\'envoi pour compatibilit√© maximale');
console.log('   ‚úÖ Gestion messages g√©n√©riques de battle avec contenu capture');
console.log('üöÄ Usage: const captureManager = createCaptureManager(battleScene, networkHandler);');
