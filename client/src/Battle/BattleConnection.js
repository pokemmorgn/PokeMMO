// client/src/Battle/BattleConnection.js - Version refactoris√©e utilisant BattleNetworkHandler
import { BattleNetworkHandler } from '../network/BattleNetworkHandler.js';

/**
 * Interface simplifi√©e pour le syst√®me de combat
 * Utilise BattleNetworkHandler pour toute la logique r√©seau
 */
export class BattleConnection {
  constructor(gameManager) {
    this.gameManager = gameManager;
    
    // Handler r√©seau d√©di√©
    this.networkHandler = null;
    
    // √âtat simplifi√©
    this.isInitialized = false;
    
    // Callbacks pour le BattleManager
    this.eventCallbacks = new Map();
    
    console.log('üîó [BattleConnection] Initialis√© (version refactoris√©e)');
  }

  // === INITIALISATION ===

  /**
   * Initialise avec le NetworkManager principal
   */
  initialize(networkManager) {
    console.log('üîß [BattleConnection] Initialisation...');
    
    if (!networkManager || !networkManager.worldRoom || !networkManager.client) {
      console.error('‚ùå [BattleConnection] NetworkManager incomplet');
      return false;
    }
    
    // Cr√©er le handler r√©seau sp√©cialis√©
    this.networkHandler = new BattleNetworkHandler(networkManager);
    
    // L'initialiser avec les connexions existantes
    const success = this.networkHandler.initialize(
      networkManager.worldRoom,
      networkManager.client
    );
    
    if (!success) {
      console.error('‚ùå [BattleConnection] √âchec initialisation BattleNetworkHandler');
      return false;
    }
    
    // Setup des √©v√©nements
    this.setupNetworkEvents();
    
    this.isInitialized = true;
    console.log('‚úÖ [BattleConnection] Initialis√© avec BattleNetworkHandler');
    return true;
  }

  /**
   * Alternative : initialiser directement avec WorldRoom (compatibilit√©)
   */
  initializeWithRoom(worldRoom) {
    console.log('üîß [BattleConnection] Initialisation directe avec WorldRoom...');
    
    if (!worldRoom) {
      console.error('‚ùå [BattleConnection] WorldRoom manquante');
      return false;
    }
    
    // Extraire le client de la WorldRoom
    const client = worldRoom.connection?.transport?.ws ? worldRoom.connection : null;
    if (!client) {
      console.error('‚ùå [BattleConnection] Client Colyseus non trouv√© dans WorldRoom');
      return false;
    }
    
    // Cr√©er un NetworkManager temporaire pour compatibilit√©
    const mockNetworkManager = {
      worldRoom: worldRoom,
      client: client
    };
    
    return this.initialize(mockNetworkManager);
  }

  // === CONFIGURATION DES √âV√âNEMENTS ===

  setupNetworkEvents() {
    if (!this.networkHandler) return;
    
    console.log('üì° [BattleConnection] Configuration des √©v√©nements r√©seau...');
    
    // Rediriger tous les √©v√©nements du BattleNetworkHandler vers les callbacks
    this.networkHandler.on('wildEncounterStart', (data) => {
      this.triggerEvent('wildEncounterStart', data);
    });
    
    this.networkHandler.on('battleRoomCreated', (data) => {
      this.triggerEvent('battleRoomCreated', data);
    });
    
    this.networkHandler.on('battleRoomConnected', (data) => {
      this.triggerEvent('joinBattleRoom', data);
    });
    
    this.networkHandler.on('battleJoined', (data) => {
      this.triggerEvent('battleJoined', data);
    });
    
    this.networkHandler.on('battleStart', (data) => {
      this.triggerEvent('battleStart', data);
    });
    
    this.networkHandler.on('turnChange', (data) => {
      this.triggerEvent('turnChange', data);
    });
    
    this.networkHandler.on('battleMessage', (data) => {
      this.triggerEvent('battleMessage', data);
    });
    
    this.networkHandler.on('battleEnd', (data) => {
      this.triggerEvent('battleEnd', data);
    });
    
    this.networkHandler.on('battleLeft', (data) => {
      this.triggerEvent('battleLeft', data);
    });
    
    this.networkHandler.on('battleError', (data) => {
      this.triggerEvent('battleError', data);
    });
    
    this.networkHandler.on('battleStateChange', (data) => {
      this.triggerEvent('battleStateChange', data);
    });
    
    // √âv√©nements sp√©cifiques aux actions
    this.networkHandler.on('attackResult', (data) => {
      this.triggerEvent('attackResult', data);
    });
    
    this.networkHandler.on('captureShake', (data) => {
      this.triggerEvent('captureShake', data);
    });
    
    this.networkHandler.on('pokemonFainted', (data) => {
      this.triggerEvent('pokemonFainted', data);
    });
    
    this.networkHandler.on('statusEffectApplied', (data) => {
      this.triggerEvent('statusEffectApplied', data);
    });
    
    console.log('‚úÖ [BattleConnection] √âv√©nements r√©seau configur√©s');
  }

  // === M√âTHODES D'ACTION (D√©l√©gation vers BattleNetworkHandler) ===

  /**
   * Demander un combat sauvage
   */
  requestWildBattle(wildPokemonData) {
    if (!this.networkHandler) {
      console.error('‚ùå [BattleConnection] NetworkHandler non initialis√©');
      return false;
    }
    
    return this.networkHandler.requestWildBattle(wildPokemonData);
  }

  /**
   * Choisir le Pok√©mon de d√©part
   */
  choosePokemon(pokemonId) {
    if (!this.networkHandler) return false;
    return this.networkHandler.choosePokemon(pokemonId);
  }

  /**
   * Effectuer une action de combat
   */
  performBattleAction(actionType, actionData = {}) {
    if (!this.networkHandler) return false;
    return this.networkHandler.performBattleAction(actionType, actionData);
  }

  /**
   * Utiliser une attaque
   */
  useMove(moveId) {
    if (!this.networkHandler) return false;
    return this.networkHandler.useMove(moveId);
  }

  /**
   * Utiliser un objet
   */
  useItem(itemId, targetId = null) {
    if (!this.networkHandler) return false;
    return this.networkHandler.useItem(itemId, targetId);
  }

  /**
   * Changer de Pok√©mon
   */
  switchPokemon(newPokemonId) {
    if (!this.networkHandler) return false;
    return this.networkHandler.switchPokemon(newPokemonId);
  }

  /**
   * Tenter de fuir
   */
  attemptRun() {
    if (!this.networkHandler) return false;
    return this.networkHandler.attemptRun();
  }

  /**
   * Tenter une capture
   */
  attemptCapture(ballType) {
    if (!this.networkHandler) return false;
    return this.networkHandler.attemptCapture(ballType);
  }

  /**
   * Quitter le combat
   */
  leaveBattle(reason = 'manual') {
    if (!this.networkHandler) return false;
    return this.networkHandler.leaveBattle(reason);
  }

  // === M√âTHODES D'INFORMATION ===

  /**
   * V√©rifier si on peut combattre
   */
  checkCanBattle() {
    if (!this.networkHandler) return false;
    return this.networkHandler.checkCanBattle();
  }

  /**
   * Obtenir le statut du combat
   */
  getBattleStatus() {
    if (!this.networkHandler) return false;
    return this.networkHandler.getBattleStatus();
  }

  /**
   * Obtenir l'√©tat de la BattleRoom
   */
  getBattleState() {
    if (!this.networkHandler) return null;
    return this.networkHandler.getBattleState();
  }

  // === M√âTHODES POUR COMPATIBILIT√â AVEC L'ANCIEN SYST√àME ===

  /**
   * Envoyer un message (pour compatibilit√© - d√©l√®gue vers le bon handler)
   */
  send(messageType, data = {}) {
    console.log(`üì§ [BattleConnection] Envoi message: ${messageType}`);
    
    if (!this.networkHandler) {
      console.error('‚ùå [BattleConnection] NetworkHandler non disponible');
      return false;
    }
    
    // D√©terminer si c'est pour WorldRoom ou BattleRoom selon le type de message
    const worldMessages = [
      'startWildBattle', 'leaveBattle', 'canBattle', 'getBattleStatus'
    ];
    
    const battleMessages = [
      'choosePokemon', 'battleAction', 'attemptCapture', 'attemptFlee', 
      'switchPokemon', 'getBattleState'
    ];
    
    if (worldMessages.includes(messageType)) {
      return this.networkHandler.sendToWorld(messageType, data);
    } else if (battleMessages.includes(messageType)) {
      return this.networkHandler.sendToBattle(messageType, data);
    } else {
      // Par d√©faut, essayer BattleRoom
      return this.networkHandler.sendToBattle(messageType, data);
    }
  }

  /**
   * Rejoindre room (pour compatibilit√©)
   */
  async joinRoom(roomId) {
    console.log(`üö™ [BattleConnection] Rejoindre room: ${roomId}`);
    
    if (!this.networkHandler) {
      console.error('‚ùå [BattleConnection] NetworkHandler non disponible');
      return false;
    }
    
    // Si c'est un battleRoomId, se connecter via le handler
    return await this.networkHandler.connectToBattleRoom(roomId);
  }

  // === GETTERS POUR COMPATIBILIT√â ===

  /**
   * V√©rifie si connect√© au combat
   */
  get isConnected() {
    return this.networkHandler?.canSendBattleActions() || false;
  }

  /**
   * ID de la BattleRoom actuelle
   */
  get currentBattleRoomId() {
    return this.networkHandler?.battleRoomId || null;
  }

  /**
   * √âtat du combat
   */
  get battleState() {
    return this.networkHandler?.battleRoom?.state || null;
  }

  /**
   * V√©rifier si WorldRoom connect√©e
   */
  get worldRoomConnected() {
    return this.networkHandler?.worldRoom ? true : false;
  }

  // === √âTAT ET CONNEXIONS ===

  /**
   * Obtenir l'√©tat complet des connexions
   */
  getConnectionStatus() {
    if (!this.networkHandler) {
      return {
        initialized: false,
        worldRoom: { connected: false },
        battleRoom: { connected: false }
      };
    }
    
    return {
      initialized: this.isInitialized,
      ...this.networkHandler.getConnectionStatus()
    };
  }

  /**
   * V√©rifier si on peut envoyer des actions de combat
   */
  canSendBattleActions() {
    return this.networkHandler?.canSendBattleActions() || false;
  }

  // === SYST√àME D'√âV√âNEMENTS (Inchang√© pour compatibilit√©) ===

  /**
   * Enregistrer un callback d'√©v√©nement
   */
  on(eventName, callback) {
    if (!this.eventCallbacks.has(eventName)) {
      this.eventCallbacks.set(eventName, []);
    }
    this.eventCallbacks.get(eventName).push(callback);
  }

  /**
   * Supprimer un callback d'√©v√©nement
   */
  off(eventName, callback) {
    if (this.eventCallbacks.has(eventName)) {
      const callbacks = this.eventCallbacks.get(eventName);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  /**
   * D√©clencher un √©v√©nement
   */
  triggerEvent(eventName, data = {}) {
    if (this.eventCallbacks.has(eventName)) {
      this.eventCallbacks.get(eventName).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`‚ùå [BattleConnection] Erreur callback ${eventName}:`, error);
        }
      });
    }
  }

  // === DEBUG ===

  /**
   * Debug des connexions
   */
  debugConnections() {
    console.log('üîç [BattleConnection] === DEBUG CONNEXIONS ===');
    
    if (this.networkHandler) {
      return this.networkHandler.debug();
    } else {
      console.log('‚ùå NetworkHandler non initialis√©');
      return { error: 'NetworkHandler not initialized' };
    }
  }

  /**
   * Test de fonctionnalit√©
   */
  test() {
    console.log('üß™ [BattleConnection] Test du syst√®me...');
    
    const status = this.getConnectionStatus();
    console.log('üìä √âtat:', status);
    
    if (this.networkHandler) {
      // Test de connexion
      const canSend = this.canSendBattleActions();
      console.log('üì§ Peut envoyer actions:', canSend);
      
      // Test d'√©v√©nements
      const eventCount = this.eventCallbacks.size;
      console.log('üì° √âv√©nements enregistr√©s:', eventCount);
      
      return {
        status,
        canSendActions: canSend,
        eventCount,
        networkHandler: 'available'
      };
    } else {
      return {
        status,
        error: 'NetworkHandler not available'
      };
    }
  }

  // === NETTOYAGE ===

  /**
   * Nettoie et d√©truit la connexion
   */
  async destroy() {
    console.log('üíÄ [BattleConnection] Destruction...');
    
    // D√©truire le handler r√©seau
    if (this.networkHandler) {
      await this.networkHandler.destroy();
      this.networkHandler = null;
    }
    
    // Nettoyer les callbacks
    this.eventCallbacks.clear();
    
    // Nettoyer les r√©f√©rences
    this.gameManager = null;
    
    this.isInitialized = false;
    
    console.log('‚úÖ [BattleConnection] D√©truit');
  }
}
