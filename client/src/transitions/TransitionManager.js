// client/src/transitions/TransitionManager.js
// ‚úÖ CORRECTIONS POUR SPAWNS CORRECTS

export class TransitionManager {
  constructor(scene) {
    this.scene = scene;
    this.isActive = false;
    this.debugMode = true;
    this.isTransitioning = false;
    
    // Collections des √©l√©ments de transition
    this.teleport = new Map();
    this.spawns = new Map(); // ‚úÖ AJOUT: Collection des spawns
    this.zones = new Map();
    
    // ‚úÖ AJOUT: Mapping des spawns par zone
    this.spawnsByZone = new Map();
    
    // Mapping zone ‚Üî scene (existant)
    this.zoneToScene = {
      'beach': 'BeachScene',
      'village': 'VillageScene',
      'villagelab': 'VillageLabScene',
      'road1': 'Road1Scene',
      'villagehouse1': 'VillageHouse1Scene',
      'lavandia': 'LavandiaScene'
    };
    
    this.sceneToZone = {};
    Object.keys(this.zoneToScene).forEach(zone => {
      this.sceneToZone[this.zoneToScene[zone]] = zone;
    });
    
    this.currentZone = this.sceneToZone[scene.scene.key] || 'unknown';
    
    console.log(`üåÄ [TransitionManager] Syst√®me initialis√© pour ${this.currentZone}`);
  }

  // ‚úÖ INITIALISATION AM√âLIOR√âE: Scanner teleports ET spawns
  initialize() {
    console.log(`üåÄ [TransitionManager] === INITIALISATION COMPL√àTE ===`);
    
    if (!this.scene.map) {
      console.error(`üåÄ [TransitionManager] ‚ùå Aucune map trouv√©e!`);
      return false;
    }

    // Chercher les layers contenant les objets
    const objectLayers = [
      this.scene.map.getObjectLayer('Worlds'),
      this.scene.map.getObjectLayer('Objects'),
      this.scene.map.getObjectLayer('Teleports')
    ].filter(layer => layer !== null);

    if (objectLayers.length === 0) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è Aucun layer d'objets trouv√©`);
      return false;
    }

    console.log(`üåÄ [TransitionManager] üìã ${objectLayers.length} layers d'objets trouv√©s`);

    // ‚úÖ SCAN COMPLET: teleports ET spawns
    objectLayers.forEach(layer => {
      console.log(`üåÄ [TransitionManager] üìÇ Scan layer "${layer.name}" (${layer.objects.length} objets)`);
      
      layer.objects.forEach((obj, index) => {
        const objName = (obj.name || '').toLowerCase();
        const objType = (obj.type || '').toLowerCase();
        
        if (objName === 'teleport' || objType === 'teleport') {
          this.processTeleport(obj, index, layer.name);
        } else if (objName.includes('spawn') || objType === 'spawn') {
          this.processSpawn(obj, index, layer.name);
        }
      });
    });

    console.log(`üåÄ [TransitionManager] ‚úÖ Scan termin√©:`);
    console.log(`  üìç ${this.teleport.size} teleports trouv√©s`);
    console.log(`  üéØ ${this.spawns.size} spawns trouv√©s`);

    // Organiser les spawns par zone
    this.organizeSpawnsByZone();

    // Cr√©er les zones physiques pour collision
    this.createPhysicalZones();
    
    if (this.debugMode) {
      this.debugInfo();
    }

    this.isActive = true;
    return true;
  }

  // ‚úÖ NOUVELLE M√âTHODE: Traiter les spawns
  processSpawn(obj, index, layerName) {
    const targetZone = this.getProperty(obj, 'targetzone') || this.currentZone;
    const spawnName = this.getProperty(obj, 'spawn') || obj.name || `spawn_${index}`;

    const spawn = {
      id: `spawn_${layerName}_${index}`,
      name: spawnName,
      zone: targetZone,
      x: obj.x,
      y: obj.y,
      width: obj.width || 32,
      height: obj.height || 32
    };

    this.spawns.set(spawn.id, spawn);
    
    console.log(`üåÄ [TransitionManager] üéØ Spawn "${spawnName}": ${targetZone} √† (${spawn.x}, ${spawn.y})`);
  }

  // ‚úÖ NOUVELLE M√âTHODE: Organiser les spawns par zone
  organizeSpawnsByZone() {
    console.log(`üåÄ [TransitionManager] === ORGANISATION SPAWNS PAR ZONE ===`);
    
    this.spawns.forEach((spawn) => {
      if (!this.spawnsByZone.has(spawn.zone)) {
        this.spawnsByZone.set(spawn.zone, new Map());
      }
      
      this.spawnsByZone.get(spawn.zone).set(spawn.name, spawn);
      console.log(`üéØ Spawn organis√©: ${spawn.zone}.${spawn.name} ‚Üí (${spawn.x}, ${spawn.y})`);
    });

    // Debug des spawns organis√©s
    this.spawnsByZone.forEach((zoneSpawns, zoneName) => {
      const spawnNames = Array.from(zoneSpawns.keys());
      console.log(`üåç Zone ${zoneName}: ${spawnNames.length} spawns [${spawnNames.join(', ')}]`);
    });
  }

  // ‚úÖ NOUVELLE M√âTHODE: Trouver une position de spawn
  findSpawnPosition(targetZone, targetSpawn) {
    console.log(`üîç [TransitionManager] Recherche spawn: ${targetZone}.${targetSpawn}`);
    
    // 1. Chercher le spawn exact
    if (this.spawnsByZone.has(targetZone)) {
      const zoneSpawns = this.spawnsByZone.get(targetZone);
      
      if (targetSpawn && zoneSpawns.has(targetSpawn)) {
        const spawn = zoneSpawns.get(targetSpawn);
        console.log(`‚úÖ Spawn exact trouv√©: ${targetSpawn} ‚Üí (${spawn.x}, ${spawn.y})`);
        return { x: spawn.x, y: spawn.y };
      }
      
      // 2. Chercher un spawn "default" ou "d√©faut"
      const defaultSpawns = ['default', 'd√©faut', 'main', 'principal'];
      for (const defaultName of defaultSpawns) {
        if (zoneSpawns.has(defaultName)) {
          const spawn = zoneSpawns.get(defaultName);
          console.log(`üéØ Spawn par d√©faut trouv√©: ${defaultName} ‚Üí (${spawn.x}, ${spawn.y})`);
          return { x: spawn.x, y: spawn.y };
        }
      }
      
      // 3. Prendre le premier spawn disponible
      if (zoneSpawns.size > 0) {
        const firstSpawn = Array.from(zoneSpawns.values())[0];
        console.log(`üîÑ Premier spawn disponible: ${firstSpawn.name} ‚Üí (${firstSpawn.x}, ${firstSpawn.y})`);
        return { x: firstSpawn.x, y: firstSpawn.y };
      }
    }
    
    // 4. Position par d√©faut de la sc√®ne
    const defaultPos = this.getSceneDefaultPosition(targetZone);
    console.warn(`‚ö†Ô∏è Aucun spawn trouv√©, position par d√©faut: (${defaultPos.x}, ${defaultPos.y})`);
    return defaultPos;
  }

  // ‚úÖ NOUVELLE M√âTHODE: Position par d√©faut par sc√®ne
  getSceneDefaultPosition(targetZone) {
    const defaults = {
      'beach': { x: 52, y: 48 },
      'village': { x: 200, y: 150 },
      'villagelab': { x: 100, y: 100 },
      'road1': { x: 50, y: 200 },
      'villagehouse1': { x: 80, y: 80 },
      'lavandia': { x: 300, y: 200 }
    };
    
    return defaults[targetZone] || { x: 100, y: 100 };
  }

  // ‚úÖ D√âCLENCHER TRANSITION CORRIG√âE
  async triggerTransition(teleportData) {
    if (this.isTransitioning) {
      console.log(`üåÄ [TransitionManager] ‚ö†Ô∏è Transition d√©j√† en cours`);
      return;
    }

    console.log(`üåÄ [TransitionManager] === DEMANDE TRANSITION SERVEUR ===`);
    console.log(`üìç De: ${teleportData.fromZone}`);
    console.log(`üìç Vers: ${teleportData.targetZone}`);
    console.log(`üéØ Spawn demand√©: ${teleportData.targetSpawn || 'd√©faut'}`);

    this.isTransitioning = true;

    const myPlayer = this.scene.playerManager?.getMyPlayer();
    if (!myPlayer) {
      console.error(`üåÄ [TransitionManager] ‚ùå Joueur local introuvable`);
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ SAUVEGARDE POUR ROLLBACK
    const originalState = {
      zone: this.currentZone,
      scene: this.scene.scene.key,
      player: {
        x: myPlayer.x,
        y: myPlayer.y,
        targetX: myPlayer.targetX,
        targetY: myPlayer.targetY,
        visible: myPlayer.visible,
        active: myPlayer.active
      }
    };

    const targetScene = this.zoneToScene[teleportData.targetZone];
    if (!targetScene) {
      console.error(`üåÄ [TransitionManager] ‚ùå Scene inconnue pour zone: ${teleportData.targetZone}`);
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ CALCUL DE LA VRAIE POSITION DE SPAWN
    const spawnPosition = this.findSpawnPosition(teleportData.targetZone, teleportData.targetSpawn);
    
    console.log(`üéØ [TransitionManager] Position calcul√©e: (${spawnPosition.x}, ${spawnPosition.y})`);
    
    const transitionData = {
      fromZone: this.currentZone,
      fromTransition: true,
      localTransition: true,
      spawnX: spawnPosition.x, // ‚úÖ VRAIE position, pas temporaire
      spawnY: spawnPosition.y, // ‚úÖ VRAIE position, pas temporaire
      targetSpawn: teleportData.targetSpawn, // ‚úÖ AJOUT: Garder l'info du spawn
      networkManager: this.scene.networkManager,
      mySessionId: this.scene.mySessionId,
      forcePlayerSync: true,
      pendingValidation: true
    };

    // ‚úÖ SETUP LISTENER POUR VALIDATION
    this.setupValidationListener(teleportData, originalState, targetScene, transitionData);

    // ‚úÖ ENVOYER DEMANDE AU SERVEUR
    if (this.scene.networkManager && this.scene.networkManager.isConnected) {
      const validationRequest = {
        fromZone: teleportData.fromZone,
        targetZone: teleportData.targetZone,
        targetSpawn: teleportData.targetSpawn,
        playerX: myPlayer.x,
        playerY: myPlayer.y,
        teleportId: teleportData.id,
        requestedSpawnPosition: spawnPosition // ‚úÖ AJOUT: Position demand√©e
      };

      console.log(`üì§ [TransitionManager] Envoi demande validation:`, validationRequest);
      this.scene.networkManager.room.send("validateTransition", validationRequest);
    }

    // ‚úÖ D√âMARRER LA NOUVELLE SC√àNE avec la bonne position
    console.log(`üöÄ [TransitionManager] Transition vers ${targetScene} avec position (${spawnPosition.x}, ${spawnPosition.y})`);
    this.scene.scene.start(targetScene, transitionData);
  }

  // ‚úÖ SETUP LISTENER VALIDATION (am√©lior√©)
  setupValidationListener(teleportData, originalState, targetScene, transitionData) {
    console.log(`üëÇ [TransitionManager] Setup listener de validation...`);
    
    const validationTimeout = setTimeout(() => {
      console.warn(`‚è∞ [TransitionManager] Timeout validation - utilisation position calcul√©e`);
      this.isTransitioning = false;
    }, 5000);

    if (this.scene.networkManager?.room) {
      const validationHandler = (result) => {
        console.log(`üì® [TransitionManager] R√©sultat validation re√ßu:`, result);
        
        clearTimeout(validationTimeout);
        this.isTransitioning = false;

        if (result.success) {
          console.log(`‚úÖ [TransitionManager] Transition valid√©e par le serveur`);
          
          // ‚úÖ PRIORIT√â: Position serveur > Position calcul√©e > Position par d√©faut
          if (result.position) {
            const currentPlayer = this.scene.playerManager?.getMyPlayer();
            if (currentPlayer) {
              console.log(`üéØ [TransitionManager] Position serveur utilis√©e: (${result.position.x}, ${result.position.y})`);
              currentPlayer.x = result.position.x;
              currentPlayer.y = result.position.y;
              currentPlayer.targetX = result.position.x;
              currentPlayer.targetY = result.position.y;
            }
          } else {
            console.log(`üéØ [TransitionManager] Position calcul√©e conserv√©e: (${transitionData.spawnX}, ${transitionData.spawnY})`);
          }
        } else {
          console.error(`‚ùå [TransitionManager] Transition refus√©e: ${result.reason}`);
          
          if (result.rollback) {
            this.performRollbackImproved(originalState);
          }
          
          this.showTransitionError(result.reason);
        }
      };

      this.scene.networkManager.onTransitionValidation = validationHandler;
    }
  }

  // ‚úÖ DEBUG AM√âLIOR√â
  debugInfo() {
    console.log(`üåÄ [TransitionManager] === DEBUG COMPLET ===`);
    console.log(`Zone actuelle: ${this.currentZone}`);
    
    console.log(`üìç TELEPORTS (${this.teleport.size}):`);
    this.teleport.forEach((teleport, id) => {
      console.log(`  - ${id}: (${teleport.x}, ${teleport.y}) ‚Üí ${teleport.targetZone} ${teleport.targetSpawn || ''}`);
    });
    
    console.log(`üéØ SPAWNS (${this.spawns.size}):`);
    this.spawns.forEach((spawn, id) => {
      console.log(`  - ${spawn.name}: ${spawn.zone} √† (${spawn.x}, ${spawn.y})`);
    });
    
    console.log(`üåç SPAWNS PAR ZONE:`);
    this.spawnsByZone.forEach((zoneSpawns, zoneName) => {
      const spawnList = Array.from(zoneSpawns.entries()).map(([name, spawn]) => 
        `${name}(${spawn.x},${spawn.y})`
      ).join(', ');
      console.log(`  - ${zoneName}: ${spawnList}`);
    });
    
    console.log(`‚ö° ZONES COLLISION (${this.zones.size}):`);
    this.zones.forEach((zone, id) => {
      console.log(`  - ${id}: zone collision active`);
    });
  }

  // Helper method (existant, inchang√©)
  getProperty(object, propertyName) {
    if (!object.properties) return null;
    
    const prop = object.properties.find(p => p.name === propertyName);
    return prop ? prop.value : null;
  }

  // Autres m√©thodes existantes inchang√©es...
  createPhysicalZones() {
    console.log(`üåÄ [TransitionManager] === CR√âATION ZONES COLLISION ===`);

    this.teleport.forEach((teleportData) => {
      const zone = this.scene.add.zone(
        teleportData.x + teleportData.width / 2,
        teleportData.y + teleportData.height / 2,
        teleportData.width,
        teleportData.height
      );

      this.scene.physics.world.enableBody(zone, Phaser.Physics.Arcade.STATIC_BODY);
      zone.body.setSize(teleportData.width, teleportData.height);
      zone.transitionData = teleportData;
      
      if (this.debugMode) {
        this.createDebugRect(zone, teleportData);
      }

      this.zones.set(teleportData.id, zone);
      console.log(`üåÄ [TransitionManager] ‚úÖ Zone collision "${teleportData.id}" cr√©√©e`);
    });

    console.log(`üåÄ [TransitionManager] ‚úÖ ${this.zones.size} zones collision cr√©√©es`);
  }

  createDebugRect(zone, teleportData) {
    const debugRect = this.scene.add.rectangle(
      zone.x, zone.y,
      zone.displayWidth, zone.displayHeight,
      0xff0000, 0.3
    );
    debugRect.setDepth(999);
    
    const debugText = this.scene.add.text(
      zone.x, zone.y - 20,
      `‚Üí ${teleportData.targetZone}${teleportData.targetSpawn ? '\n' + teleportData.targetSpawn : ''}`,
      {
        fontSize: '10px',
        fill: '#ffffff',
        backgroundColor: '#000000',
        padding: { x: 4, y: 2 },
        align: 'center'
      }
    );
    debugText.setDepth(1000);
    debugText.setOrigin(0.5);
  }

  checkCollisions(player) {
    if (!this.isActive || !player || this.isTransitioning) return;

    this.zones.forEach((zone) => {
      if (!zone.transitionData) return;

      const playerBounds = player.getBounds();
      const zoneBounds = zone.getBounds();

      if (Phaser.Geom.Rectangle.Overlaps(playerBounds, zoneBounds)) {
        this.triggerTransition(zone.transitionData);
      }
    });
  }

  performRollbackImproved(originalState) {
    console.log(`üîÑ [TransitionManager] === ROLLBACK AM√âLIOR√â ===`);
    console.log(`üìç Retour vers: ${originalState.scene} (${originalState.zone})`);
    
    const rollbackData = {
      fromTransition: true,
      isRollback: true,
      spawnX: originalState.player.x,
      spawnY: originalState.player.y,
      networkManager: this.scene.networkManager,
      mySessionId: this.scene.mySessionId,
      forcePlayerSync: true,
      restorePlayerState: originalState.player
    };

    console.log(`üîÑ [TransitionManager] Rollback vers ${originalState.scene}`);
    this.scene.scene.start(originalState.scene, rollbackData);
  }

  showTransitionError(reason) {
    console.error(`üö´ [TransitionManager] ${reason}`);
    
    if (typeof this.scene.showNotification === 'function') {
      this.scene.showNotification(`Transition refus√©e: ${reason}`, 'error');
    } else {
      if (this.scene.add && this.scene.cameras && this.scene.cameras.main) {
        const notification = this.scene.add.text(
          this.scene.cameras.main.worldView.centerX || this.scene.scale.width / 2,
          50,
          `Transition refus√©e: ${reason}`,
          {
            fontSize: '16px',
            fontFamily: 'Arial',
            color: '#ff4444',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            padding: { x: 10, y: 5 }
          }
        ).setOrigin(0.5).setScrollFactor(0).setDepth(2000);

        if (this.scene.time) {
          this.scene.time.delayedCall(3000, () => {
            if (notification && notification.scene) {
              notification.destroy();
            }
          });
        }
      }
    }
  }

  destroy() {
    console.log(`üåÄ [TransitionManager] Nettoyage...`);
    
    this.zones.forEach((zone) => {
      if (zone && zone.destroy) {
        zone.destroy();
      }
    });
    
    this.teleport.clear();
    this.spawns.clear();
    this.spawnsByZone.clear();
    this.zones.clear();
    this.isActive = false;
    this.isTransitioning = false;
    
    console.log(`üåÄ [TransitionManager] ‚úÖ Nettoy√©`);
  }

  setActive(active) {
    this.isActive = active;
    console.log(`üåÄ [TransitionManager] ${active ? 'Activ√©' : 'D√©sactiv√©'}`);
  }
}
