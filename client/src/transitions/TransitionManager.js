// client/src/transitions/TransitionManager.js
// ‚úÖ VERSION DYNAMIQUE - SYNC AVEC SYST√àME SERVEUR

export class TransitionManager {
  constructor(scene) {
    this.scene = scene;
    this.isActive = false;
    this.debugMode = true;
    this.isTransitioning = false;
    
    // Collections locales (pour collision seulement)
    this.teleportZones = new Map(); // Zones de collision pour t√©l√©ports
    this.currentZone = this.getZoneFromScene(scene.scene.key);
    
    // Loading overlay
    this.loadingOverlay = null;
    this.transitionStartTime = 0;
    this.transitionTimeout = 10000; // 10 secondes max
    
    console.log(`üåÄ [TransitionManager] Syst√®me dynamique initialis√© pour zone: ${this.currentZone}`);
  }

  // ‚úÖ INITIALISATION: Scanner les t√©l√©ports pour collision locale
  initialize() {
    console.log(`üåÄ [TransitionManager] === SCAN T√âL√âPORTS POUR COLLISION ===`);
    
    if (!this.scene.map) {
      console.error(`üåÄ [TransitionManager] ‚ùå Aucune map trouv√©e!`);
      return false;
    }

    // Chercher le layer "Worlds" (ou autres)
    const worldsLayer = this.scene.map.getObjectLayer('Worlds');
    if (!worldsLayer) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è Layer "Worlds" introuvable`);
      return false;
    }

    console.log(`üåÄ [TransitionManager] üìÇ Scan layer "Worlds" (${worldsLayer.objects.length} objets)`);

    // Scanner SEULEMENT les t√©l√©ports
    let teleportCount = 0;
    worldsLayer.objects.forEach((obj, index) => {
      const objName = (obj.name || '').toLowerCase();
      
      if (objName === 'teleport') {
        this.processTeleport(obj, index);
        teleportCount++;
      }
      // ‚úÖ IGNORER les spawns - le serveur g√®re tout
    });

    console.log(`üåÄ [TransitionManager] ‚úÖ ${teleportCount} t√©l√©ports trouv√©s`);

    // Cr√©er les zones de collision
    this.createCollisionZones();
    
    if (this.debugMode) {
      this.debugInfo();
    }

    this.isActive = true;
    return true;
  }

  // ‚úÖ TRAITER UN T√âL√âPORT (r√©cup√©ration des propri√©t√©s)
  processTeleport(obj, index) {
    const targetZone = this.getProperty(obj, 'targetzone');
    const targetSpawn = this.getProperty(obj, 'targetspawn');

    if (!targetZone) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è T√©l√©port ${index} sans 'targetzone'`);
      return;
    }

    if (!targetSpawn) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è T√©l√©port ${index} sans 'targetspawn'`);
      return;
    }

    const teleport = {
      id: `teleport_${index}`,
      x: obj.x,
      y: obj.y,
      width: obj.width || 32,
      height: obj.height || 32,
      targetZone: targetZone,
      targetSpawn: targetSpawn,
      fromZone: this.currentZone
    };

    this.teleportZones.set(teleport.id, teleport);
    
    console.log(`üåÄ [TransitionManager] üìç T√©l√©port "${teleport.id}": ${this.currentZone} ‚Üí ${targetZone}[${targetSpawn}]`);
  }

  // ‚úÖ CR√âER ZONES DE COLLISION PHASER
  createCollisionZones() {
    console.log(`üåÄ [TransitionManager] === CR√âATION ZONES COLLISION ===`);

    this.teleportZones.forEach((teleportData) => {
      // Zone invisible pour collision
      const zone = this.scene.add.zone(
        teleportData.x + teleportData.width / 2,
        teleportData.y + teleportData.height / 2,
        teleportData.width,
        teleportData.height
      );

      // Physique
      this.scene.physics.world.enableBody(zone, Phaser.Physics.Arcade.STATIC_BODY);
      zone.body.setSize(teleportData.width, teleportData.height);
      zone.transitionData = teleportData;

      // Debug visuel
      if (this.debugMode) {
        this.createDebugVisuals(zone, teleportData);
      }

      console.log(`üåÄ [TransitionManager] ‚úÖ Zone collision cr√©√©e: ${teleportData.id}`);
    });

    console.log(`üåÄ [TransitionManager] ‚úÖ ${this.teleportZones.size} zones collision actives`);
  }

  // ‚úÖ DEBUG VISUEL STYLE POK√âMON
  createDebugVisuals(zone, teleportData) {
    // Rectangle de zone
    const debugRect = this.scene.add.rectangle(
      zone.x, zone.y,
      zone.displayWidth, zone.displayHeight,
      0x00ff00, 0.2
    );
    debugRect.setDepth(999);
    debugRect.setStrokeStyle(2, 0x00aa00);
    
    // Texte avec zone de destination
    const debugText = this.scene.add.text(
      zone.x, zone.y - 20,
      `‚Üí ${teleportData.targetZone}`,
      {
        fontSize: '12px',
        fill: '#ffffff',
        backgroundColor: '#000000',
        padding: { x: 4, y: 2 }
      }
    );
    debugText.setDepth(1000);
    debugText.setOrigin(0.5);
  }

  // ‚úÖ V√âRIFIER COLLISIONS √Ä CHAQUE FRAME
  checkCollisions(player) {
    if (!this.isActive || !player || this.isTransitioning) return;

    this.teleportZones.forEach((teleportData) => {
      if (this.isPlayerCollidingWithTeleport(player, teleportData)) {
        this.triggerTransition(teleportData);
      }
    });
  }

  // ‚úÖ COLLISION SIMPLE RECTANGLE/RECTANGLE
  isPlayerCollidingWithTeleport(player, teleportData) {
    const playerBounds = {
      x: player.x - 16,
      y: player.y - 32,
      width: 32,
      height: 32
    };

    const teleportBounds = {
      x: teleportData.x,
      y: teleportData.y,
      width: teleportData.width,
      height: teleportData.height
    };

    return (
      playerBounds.x < teleportBounds.x + teleportBounds.width &&
      playerBounds.x + playerBounds.width > teleportBounds.x &&
      playerBounds.y < teleportBounds.y + teleportBounds.height &&
      playerBounds.y + playerBounds.height > teleportBounds.y
    );
  }

  // ‚úÖ D√âCLENCHER TRANSITION AVEC LOADING
  async triggerTransition(teleportData) {
    if (this.isTransitioning) {
      console.log(`üåÄ [TransitionManager] ‚ö†Ô∏è Transition d√©j√† en cours`);
      return;
    }

    console.log(`üåÄ [TransitionManager] === D√âBUT TRANSITION ===`);
    console.log(`üìç De: ${teleportData.fromZone}`);
    console.log(`üìç Vers: ${teleportData.targetZone}`);
    console.log(`üéØ TargetSpawn: ${teleportData.targetSpawn}`);

    this.isTransitioning = true;
    this.transitionStartTime = Date.now();

    // ‚úÖ AFFICHER LE LOADING
    this.showLoadingOverlay(teleportData);

    // Obtenir la position du joueur
    const myPlayer = this.scene.playerManager?.getMyPlayer();
    if (!myPlayer) {
      console.error(`üåÄ [TransitionManager] ‚ùå Joueur local introuvable`);
      this.hideLoadingOverlay();
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ SETUP TIMEOUT DE S√âCURIT√â
    const timeoutHandle = setTimeout(() => {
      console.error(`üåÄ [TransitionManager] ‚è∞ TIMEOUT DE TRANSITION`);
      this.hideLoadingOverlay();
      this.showErrorPopup("Timeout de transition (10s)");
      this.isTransitioning = false;
    }, this.transitionTimeout);

    // ‚úÖ SETUP LISTENER DE VALIDATION
    this.setupTransitionListener(teleportData, timeoutHandle);

    // ‚úÖ ENVOYER DEMANDE AU SERVEUR
    if (this.scene.networkManager?.room) {
      const request = {
        fromZone: teleportData.fromZone,
        targetZone: teleportData.targetZone,
        playerX: myPlayer.x,
        playerY: myPlayer.y,
        teleportId: teleportData.id
      };

      console.log(`üì§ [TransitionManager] Envoi demande serveur:`, request);
      this.scene.networkManager.room.send("validateTransition", request);
    } else {
      console.error(`üåÄ [TransitionManager] ‚ùå Pas de connexion serveur`);
      clearTimeout(timeoutHandle);
      this.hideLoadingOverlay();
      this.showErrorPopup("Pas de connexion serveur");
      this.isTransitioning = false;
    }
  }

  // ‚úÖ SETUP LISTENER POUR R√âPONSE SERVEUR
  setupTransitionListener(teleportData, timeoutHandle) {
    console.log(`üëÇ [TransitionManager] Setup listener validation...`);

    if (!this.scene.networkManager?.room) return;

    // Handler pour la r√©ponse du serveur
    const handleTransitionResult = (result) => {
      console.log(`üì® [TransitionManager] R√©sultat serveur re√ßu:`, result);
      
      clearTimeout(timeoutHandle);
      
      if (result.success) {
        console.log(`‚úÖ [TransitionManager] Transition valid√©e!`);
        this.handleTransitionSuccess(result, teleportData);
      } else {
        console.error(`‚ùå [TransitionManager] Transition refus√©e: ${result.reason}`);
        this.handleTransitionError(result);
      }
    };

    // ‚úÖ UTILISER LE CALLBACK DU NETWORKMANAGER
    this.scene.networkManager.onTransitionValidation = handleTransitionResult;
  }

  // ‚úÖ SUCC√àS DE TRANSITION
  handleTransitionSuccess(result, teleportData) {
    const targetScene = this.getSceneFromZone(teleportData.targetZone);
    
    if (!targetScene) {
      console.error(`üåÄ [TransitionManager] ‚ùå Scene introuvable pour zone: ${teleportData.targetZone}`);
      this.hideLoadingOverlay();
      this.showErrorPopup(`Zone inconnue: ${teleportData.targetZone}`);
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ PAS DE CHANGEMENT DE SC√àNE = REPOSITIONNEMENT LOCAL
    if (targetScene === this.scene.scene.key) {
      console.log(`üìç [TransitionManager] Repositionnement dans la m√™me sc√®ne`);
      this.repositionPlayer(result);
      this.hideLoadingOverlay();
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ CHANGEMENT DE SC√àNE
    console.log(`üöÄ [TransitionManager] Changement vers: ${targetScene}`);
    
    const transitionData = {
      fromZone: this.currentZone,
      fromTransition: true,
      networkManager: this.scene.networkManager,
      mySessionId: this.scene.mySessionId,
      spawnX: result.position?.x,
      spawnY: result.position?.y,
      preservePlayer: true
    };

    // ‚úÖ LE LOADING SERA MASQU√â PAR LA NOUVELLE SC√àNE
    this.scene.scene.start(targetScene, transitionData);
  }

  // ‚úÖ ERREUR DE TRANSITION
  handleTransitionError(result) {
    this.hideLoadingOverlay();
    this.showErrorPopup(result.reason || "Erreur de transition");
    this.isTransitioning = false;
  }

  // ‚úÖ REPOSITIONNEMENT LOCAL
  repositionPlayer(result) {
    const myPlayer = this.scene.playerManager?.getMyPlayer();
    if (myPlayer && result.position) {
      console.log(`üìç [TransitionManager] Repositionnement: (${result.position.x}, ${result.position.y})`);
      
      myPlayer.x = result.position.x;
      myPlayer.y = result.position.y;
      myPlayer.targetX = result.position.x;
      myPlayer.targetY = result.position.y;

      // Snap cam√©ra
      if (this.scene.cameraManager) {
        this.scene.cameraManager.snapToPlayer();
      }
    }
  }

  // ‚úÖ LOADING OVERLAY STYLE POK√âMON
  showLoadingOverlay(teleportData) {
    // Conteneur principal
    this.loadingOverlay = this.scene.add.container(0, 0).setDepth(9999).setScrollFactor(0);

    // Fond semi-transparent
    const overlay = this.scene.add.rectangle(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      this.scene.cameras.main.width,
      this.scene.cameras.main.height,
      0x1a1a2e,
      0.9
    );

    // Conteneur du modal (style de ton UI)
    const modalWidth = 400;
    const modalHeight = 200;
    const modalBg = this.scene.add.rectangle(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      modalWidth,
      modalHeight,
      0x2d3748
    ).setStrokeStyle(2, 0x4a5568);

    // Bordure externe (style bleu de ton UI)
    const borderBg = this.scene.add.rectangle(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      modalWidth + 8,
      modalHeight + 8,
      0x4299e1
    );

    // Titre
    const titleText = this.scene.add.text(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY - 50,
      'Transition en cours...',
      {
        fontSize: '20px',
        fontFamily: 'Arial, sans-serif',
        color: '#ffffff',
        fontStyle: 'bold'
      }
    ).setOrigin(0.5);

    // Destination
    const destText = this.scene.add.text(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY - 20,
      `Vers: ${teleportData.targetZone}`,
      {
        fontSize: '16px',
        fontFamily: 'Arial, sans-serif',
        color: '#a0aec0'
      }
    ).setOrigin(0.5);

    // Spinner simple (rotation)
    const spinner = this.scene.add.text(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY + 20,
      '‚ü≥',
      {
        fontSize: '24px',
        color: '#4299e1'
      }
    ).setOrigin(0.5);

    // Animation rotation
    this.scene.tweens.add({
      targets: spinner,
      rotation: Math.PI * 2,
      duration: 1000,
      repeat: -1,
      ease: 'Linear'
    });

    // Ajouter au conteneur
    this.loadingOverlay.add([borderBg, modalBg, overlay, titleText, destText, spinner]);

    console.log(`üîÑ [TransitionManager] Loading affich√©`);
  }

  // ‚úÖ MASQUER LOADING
  hideLoadingOverlay() {
    if (this.loadingOverlay) {
      this.loadingOverlay.destroy();
      this.loadingOverlay = null;
      console.log(`üîÑ [TransitionManager] Loading masqu√©`);
    }
  }

  // ‚úÖ POPUP D'ERREUR SIMPLE
  showErrorPopup(message) {
    // Cr√©er popup temporaire
    const errorPopup = this.scene.add.container(0, 0).setDepth(10000).setScrollFactor(0);

    const popupBg = this.scene.add.rectangle(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      350, 120,
      0xdc2626
    ).setStrokeStyle(2, 0x991b1b);

    const errorText = this.scene.add.text(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      `Erreur de transition:\n${message}`,
      {
        fontSize: '14px',
        fontFamily: 'Arial, sans-serif',
        color: '#ffffff',
        align: 'center',
        wordWrap: { width: 300 }
      }
    ).setOrigin(0.5);

    errorPopup.add([popupBg, errorText]);

    // Auto-destruction apr√®s 3 secondes
    this.scene.time.delayedCall(3000, () => {
      if (errorPopup) {
        errorPopup.destroy();
      }
    });

    console.log(`üö´ [TransitionManager] Erreur affich√©e: ${message}`);
  }

  // ‚úÖ HELPER: R√©cup√©rer propri√©t√© d'objet Tiled
  getProperty(object, propertyName) {
    if (!object.properties) return null;
    const prop = object.properties.find(p => p.name === propertyName);
    return prop ? prop.value : null;
  }

  // ‚úÖ MAPPING ZONE ‚Üî SC√àNE
  getZoneFromScene(sceneName) {
    const mapping = {
      'BeachScene': 'beach',
      'VillageScene': 'village',
      'VillageLabScene': 'villagelab',
      'Road1Scene': 'road1',
      'VillageHouse1Scene': 'villagehouse1',
      'LavandiaScene': 'lavandia'
    };
    return mapping[sceneName] || sceneName.toLowerCase();
  }

  getSceneFromZone(zoneName) {
    const mapping = {
      'beach': 'BeachScene',
      'village': 'VillageScene',
      'villagelab': 'VillageLabScene',
      'road1': 'Road1Scene',
      'villagehouse1': 'VillageHouse1Scene',
      'lavandia': 'LavandiaScene'
    };
    return mapping[zoneName] || null;
  }

  // ‚úÖ DEBUG INFO
  debugInfo() {
    console.log(`üåÄ [TransitionManager] === DEBUG TRANSITION DYNAMIQUE ===`);
    console.log(`Zone actuelle: ${this.currentZone}`);
    console.log(`√âtat: ${this.isActive ? 'ACTIF' : 'INACTIF'}`);
    console.log(`En transition: ${this.isTransitioning}`);
    
    console.log(`üìç T√âL√âPORTS (${this.teleportZones.size}):`);
    this.teleportZones.forEach((teleport, id) => {
      console.log(`  - ${id}: (${teleport.x}, ${teleport.y}) ‚Üí ${teleport.targetZone}[${teleport.targetSpawn}]`);
    });
  }

  // ‚úÖ NETTOYAGE
  destroy() {
    console.log(`üåÄ [TransitionManager] Nettoyage...`);
    
    this.hideLoadingOverlay();
    this.teleportZones.clear();
    this.isActive = false;
    this.isTransitioning = false;
    
    console.log(`üåÄ [TransitionManager] ‚úÖ Nettoy√©`);
  }

  // ‚úÖ CONTR√îLE EXTERNE
  setActive(active) {
    this.isActive = active;
    console.log(`üåÄ [TransitionManager] ${active ? 'Activ√©' : 'D√©sactiv√©'}`);
  }
}
