// client/src/transitions/TransitionManager.js
// ‚úÖ VERSION AVEC FIX POUR RET√âL√âPORTATION VERS ZONES VISIT√âES

export class TransitionManager {
  constructor(scene) {
    this.scene = scene;
    this.isActive = false;
    this.debugMode = true;
    this.isTransitioning = false;
    
    // Collections locales (pour collision seulement)
    this.teleportZones = new Map(); // Zones de collision pour t√©l√©ports
    this.currentZone = this.getZoneFromScene(scene.scene.key);
    
    // Loading overlay
    this.loadingOverlay = null;
    this.transitionStartTime = 0;
    this.transitionTimeout = 10000; // 10 secondes max
    
    // ‚úÖ Strat√©gies de transition disponibles
    this.transitionStrategy = 'aggressive'; // 'clean', 'aggressive', ou 'recreate'
    
    console.log(`üåÄ [TransitionManager] Syst√®me dynamique initialis√© pour zone: ${this.currentZone}`);
  }

  // ‚úÖ INITIALISATION: Scanner les t√©l√©ports pour collision locale
  initialize() {
    console.log(`üåÄ [TransitionManager] === SCAN T√âL√âPORTS POUR COLLISION ===`);
    
    if (!this.scene.map) {
      console.error(`üåÄ [TransitionManager] ‚ùå Aucune map trouv√©e!`);
      return false;
    }

    // Chercher le layer "Worlds" (ou autres)
    const worldsLayer = this.scene.map.getObjectLayer('Worlds');
    if (!worldsLayer) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è Layer "Worlds" introuvable`);
      return false;
    }

    console.log(`üåÄ [TransitionManager] üìÇ Scan layer "Worlds" (${worldsLayer.objects.length} objets)`);

    // Scanner SEULEMENT les t√©l√©ports
    let teleportCount = 0;
    worldsLayer.objects.forEach((obj, index) => {
      const objName = (obj.name || '').toLowerCase();
      
      if (objName === 'teleport') {
        this.processTeleport(obj, index);
        teleportCount++;
      }
      // ‚úÖ IGNORER les spawns - le serveur g√®re tout
    });

    console.log(`üåÄ [TransitionManager] ‚úÖ ${teleportCount} t√©l√©ports trouv√©s`);

    // Cr√©er les zones de collision
    this.createCollisionZones();
    
    if (this.debugMode) {
      this.debugInfo();
    }

    this.isActive = true;
    return true;
  }

  // ‚úÖ TRAITER UN T√âL√âPORT (r√©cup√©ration des propri√©t√©s)
  processTeleport(obj, index) {
    const targetZone = this.getProperty(obj, 'targetzone');
    const targetSpawn = this.getProperty(obj, 'targetspawn');

    if (!targetZone) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è T√©l√©port ${index} sans 'targetzone'`);
      return;
    }

    if (!targetSpawn) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è T√©l√©port ${index} sans 'targetspawn'`);
      return;
    }

    const teleport = {
      id: `teleport_${index}`,
      x: obj.x,
      y: obj.y,
      width: obj.width || 32,
      height: obj.height || 32,
      targetZone: targetZone,
      targetSpawn: targetSpawn,
      fromZone: this.currentZone
    };

    this.teleportZones.set(teleport.id, teleport);
    
    console.log(`üåÄ [TransitionManager] üìç T√©l√©port "${teleport.id}": ${this.currentZone} ‚Üí ${targetZone}[${targetSpawn}]`);
  }

  // ‚úÖ CR√âER ZONES DE COLLISION PHASER
  createCollisionZones() {
    console.log(`üåÄ [TransitionManager] === CR√âATION ZONES COLLISION ===`);

    this.teleportZones.forEach((teleportData) => {
      // Zone invisible pour collision
      const zone = this.scene.add.zone(
        teleportData.x + teleportData.width / 2,
        teleportData.y + teleportData.height / 2,
        teleportData.width,
        teleportData.height
      );

      // Physique
      this.scene.physics.world.enableBody(zone, Phaser.Physics.Arcade.STATIC_BODY);
      zone.body.setSize(teleportData.width, teleportData.height);
      zone.transitionData = teleportData;

      // Debug visuel
      if (this.debugMode) {
        this.createDebugVisuals(zone, teleportData);
      }

      console.log(`üåÄ [TransitionManager] ‚úÖ Zone collision cr√©√©e: ${teleportData.id}`);
    });

    console.log(`üåÄ [TransitionManager] ‚úÖ ${this.teleportZones.size} zones collision actives`);
  }

  // ‚úÖ DEBUG VISUEL STYLE POK√âMON
  createDebugVisuals(zone, teleportData) {
    // Rectangle de zone
    const debugRect = this.scene.add.rectangle(
      zone.x, zone.y,
      zone.displayWidth, zone.displayHeight,
      0x00ff00, 0.2
    );
    debugRect.setDepth(999);
    debugRect.setStrokeStyle(2, 0x00aa00);
    
    // Texte avec zone de destination
    const debugText = this.scene.add.text(
      zone.x, zone.y - 20,
      `‚Üí ${teleportData.targetZone}`,
      {
        fontSize: '12px',
        fill: '#ffffff',
        backgroundColor: '#000000',
        padding: { x: 4, y: 2 }
      }
    );
    debugText.setDepth(1000);
    debugText.setOrigin(0.5);
  }

  // ‚úÖ V√âRIFIER COLLISIONS √Ä CHAQUE FRAME
  checkCollisions(player) {
    if (!this.isActive || !player || this.isTransitioning) return;
    if (this.scene.justArrivedAtZone) return;

    this.teleportZones.forEach((teleportData) => {
      if (this.isPlayerCollidingWithTeleport(player, teleportData)) {
        this.triggerTransition(teleportData);
      }
    });
  }

  // ‚úÖ COLLISION SIMPLE RECTANGLE/RECTANGLE
  isPlayerCollidingWithTeleport(player, teleportData) {
    const playerBounds = {
      x: player.x - 16,
      y: player.y - 32,
      width: 32,
      height: 32
    };

    const teleportBounds = {
      x: teleportData.x,
      y: teleportData.y,
      width: teleportData.width,
      height: teleportData.height
    };

    return (
      playerBounds.x < teleportBounds.x + teleportBounds.width &&
      playerBounds.x + playerBounds.width > teleportBounds.x &&
      playerBounds.y < teleportBounds.y + teleportBounds.height &&
      playerBounds.y + playerBounds.height > teleportBounds.y
    );
  }

  // ‚úÖ D√âCLENCHER TRANSITION AVEC LOADING
  async triggerTransition(teleportData) {
    if (this.isTransitioning) {
      console.log(`üåÄ [TransitionManager] ‚ö†Ô∏è Transition d√©j√† en cours`);
      return;
    }

    console.log(`üåÄ [TransitionManager] === D√âBUT TRANSITION ===`);
    console.log(`üìç De: ${teleportData.fromZone}`);
    console.log(`üìç Vers: ${teleportData.targetZone}`);
    console.log(`üéØ TargetSpawn: ${teleportData.targetSpawn}`);

    this.isTransitioning = true;
    this.transitionStartTime = Date.now();

    // ‚úÖ AFFICHER LE LOADING IMM√âDIATEMENT (avant toute validation)
    this.showLoadingOverlay(teleportData);

    // ‚úÖ NOUVEAU: V√©rifier et corriger la d√©synchronisation AVANT d'envoyer
    const correctionResult = await this.checkAndCorrectZoneDesync(teleportData);
    if (!correctionResult.success) {
      this.hideLoadingOverlay();
      this.showErrorPopup(correctionResult.reason);
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ Utiliser les donn√©es corrig√©es
    const correctedTeleportData = correctionResult.correctedData;

    // Obtenir la position du joueur
    const myPlayer = this.scene.playerManager?.getMyPlayer();
    if (!myPlayer) {
      console.error(`üåÄ [TransitionManager] ‚ùå Joueur local introuvable`);
      this.hideLoadingOverlay();
      this.showErrorPopup("Joueur local introuvable");
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ SETUP TIMEOUT DE S√âCURIT√â
    const timeoutHandle = setTimeout(() => {
      console.error(`üåÄ [TransitionManager] ‚è∞ TIMEOUT DE TRANSITION`);
      this.hideLoadingOverlay();
      this.showErrorPopup("Timeout de transition (10s)");
      this.isTransitioning = false;
    }, this.transitionTimeout);

    // ‚úÖ SETUP LISTENER DE VALIDATION
    this.setupTransitionListener(correctedTeleportData, timeoutHandle);

    // ‚úÖ ENVOYER DEMANDE AU SERVEUR AVEC DONN√âES CORRIG√âES
    if (this.scene.networkManager?.room) {
      const request = {
        fromZone: correctedTeleportData.fromZone, // ‚úÖ Zone corrig√©e
        targetZone: correctedTeleportData.targetZone,
        playerX: myPlayer.x,
        playerY: myPlayer.y,
        teleportId: correctedTeleportData.id
      };

      console.log(`üì§ [TransitionManager] Envoi demande serveur (corrig√©e):`, request);
      this.scene.networkManager.room.send("validateTransition", request);
    } else {
      console.error(`üåÄ [TransitionManager] ‚ùå Pas de connexion serveur`);
      clearTimeout(timeoutHandle);
      this.hideLoadingOverlay();
      this.showErrorPopup("Pas de connexion serveur");
      this.isTransitioning = false;
    }
  }

  // ‚úÖ NOUVELLE M√âTHODE: V√©rifier et corriger la d√©synchronisation
  async checkAndCorrectZoneDesync(teleportData) {
    console.log(`üîÑ [TransitionManager] === V√âRIFICATION D√âSYNC ===`);
    
    // Obtenir la zone serveur et client
    const clientZone = this.scene.zoneName; // Zone de la sc√®ne actuelle
    const serverZone = this.scene.networkManager?.getCurrentZone(); // Zone du serveur
    
    console.log(`üîç [TransitionManager] Client zone: ${clientZone}`);
    console.log(`üîç [TransitionManager] Server zone: ${serverZone}`);
    console.log(`üîç [TransitionManager] Teleport fromZone: ${teleportData.fromZone}`);
    
    // Si tout est synchronis√©, pas de probl√®me
    if (clientZone === serverZone && serverZone === teleportData.fromZone) {
      console.log(`‚úÖ [TransitionManager] Zones synchronis√©es`);
      return {
        success: true,
        correctedData: teleportData
      };
    }
    
    // ‚úÖ CORRECTION AUTOMATIQUE
    console.warn(`‚ö†Ô∏è [TransitionManager] D√âSYNCHRONISATION D√âTECT√âE - CORRECTION AUTO`);
    console.warn(`   Client: ${clientZone}`);
    console.warn(`   Serveur: ${serverZone}`);
    console.warn(`   T√©l√©port: ${teleportData.fromZone}`);
    
    // Utiliser la zone du serveur comme r√©f√©rence (plus fiable)
    const correctedFromZone = serverZone || clientZone;
    
    // Mettre √† jour le NetworkManager
    if (this.scene.networkManager) {
      this.scene.networkManager.currentZone = correctedFromZone;
      console.log(`üîß [TransitionManager] Zone NetworkManager mise √† jour: ${correctedFromZone}`);
    }
    
    // Cr√©er les donn√©es de t√©l√©port corrig√©es
    const correctedTeleportData = {
      ...teleportData,
      fromZone: correctedFromZone
    };
    
    console.log(`‚úÖ [TransitionManager] Correction appliqu√©e: ${teleportData.fromZone} ‚Üí ${correctedFromZone}`);
    
    return {
      success: true,
      correctedData: correctedTeleportData
    };
  }

  // ‚úÖ SETUP LISTENER POUR R√âPONSE SERVEUR
  setupTransitionListener(teleportData, timeoutHandle) {
    console.log(`üëÇ [TransitionManager] Setup listener validation...`);

    if (!this.scene.networkManager?.room) {
      console.error(`‚ùå [TransitionManager] Pas de NetworkManager pour listener`);
      clearTimeout(timeoutHandle);
      this.hideLoadingOverlay();
      this.showErrorPopup("Pas de connexion r√©seau");
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ NETTOYER L'ANCIEN LISTENER S'IL EXISTE
    if (this.scene.networkManager.onTransitionValidation) {
      console.log(`üßπ [TransitionManager] Nettoyage ancien listener`);
      this.scene.networkManager.onTransitionValidation = null;
    }

    // ‚úÖ Handler pour la r√©ponse du serveur
    const handleTransitionResult = (result) => {
      console.log(`üì® [TransitionManager] R√©sultat serveur re√ßu:`, result);
      
      // Nettoyer le timeout
      clearTimeout(timeoutHandle);
      
      // Nettoyer le listener pour √©viter les fuites
      this.scene.networkManager.onTransitionValidation = null;
      
      if (result.success) {
        console.log(`‚úÖ [TransitionManager] Transition valid√©e!`);
        this.handleTransitionSuccess(result, teleportData);
      } else {
        console.error(`‚ùå [TransitionManager] Transition refus√©e: ${result.reason}`);
        this.handleTransitionError(result);
      }
    };

    // ‚úÖ ASSIGNER LE CALLBACK AU NETWORKMANAGER
    this.scene.networkManager.onTransitionValidation = handleTransitionResult;
    
    console.log(`‚úÖ [TransitionManager] Listener de validation configur√©`);
  }
waitForQueueToBeEmpty() {
  // Petite pause, permet √† Phaser de finir d‚Äô√©teindre les sc√®nes avant de red√©marrer.
  return new Promise(resolve => setTimeout(resolve, 0));
}
  // ‚úÖ SUCC√àS DE TRANSITION - VERSION AGGRESSIVE POUR ZONES VISIT√âES
  async handleTransitionSuccess(result, teleportData) {
    try {
      const targetZone = teleportData.targetZone;
      const targetSceneKey = this.getSceneFromZone(targetZone);

      if (!targetSceneKey) {
        console.error(`[TransitionManager] ‚ùå Scene introuvable pour zone: ${targetZone}`);
        this.hideLoadingOverlay();
        this.showErrorPopup(`Zone inconnue: ${targetZone}`);
        this.isTransitioning = false;
        return;
      }

      console.log(`üéØ [TransitionManager] Transition vers: ${targetZone} (${targetSceneKey})`);

      // ‚úÖ STRAT√âGIE AGGRESSIVE POUR RET√âL√âPORTATION
      if (this.transitionStrategy === 'aggressive') {
    await this.cleanSceneRestart(targetSceneKey, result); // ‚Üê Force clean au lieu d'aggressive
} else if (this.transitionStrategy === 'recreate') {
        await this.fullSceneRecreation(targetSceneKey, result);
      } else {
        await this.cleanSceneRestart(targetSceneKey, result);
      }

    } catch (error) {
      console.error(`‚ùå [TransitionManager] Erreur lors de la transition:`, error);
      this.hideLoadingOverlay();
      this.showErrorPopup(`Erreur technique: ${error.message}`);
      this.isTransitioning = false;
    }
  }

  // ‚úÖ NOUVELLE M√âTHODE: Transition aggressive pour zones visit√©es
  async aggressiveSceneTransition(targetSceneKey, result) {
    console.log(`‚ö° [TransitionManager] === TRANSITION AGGRESSIVE ===`);
    console.log(`üéØ Vers: ${targetSceneKey}`);

    const sceneManager = this.scene.scene;

    // ‚úÖ √âTAPE 1: Forcer l'arr√™t de TOUTES les sc√®nes actives sauf LoaderScene
    const activeScenes = sceneManager.getScenes(true);
    console.log(`üõë [TransitionManager] Arr√™t de ${activeScenes.length} sc√®nes actives...`);
    
    activeScenes.forEach(scene => {
      if (scene.scene.key !== 'LoaderScene' && scene.scene.key !== targetSceneKey) {
        console.log(`‚èπÔ∏è [TransitionManager] Stop ${scene.scene.key}`);
     //   sceneManager.stop(scene.scene.key);
      }
    });

    // ‚úÖ √âTAPE 2: Attendre que les sc√®nes s'arr√™tent
    await this.waitForAllScenesStop(targetSceneKey);

    // ‚úÖ √âTAPE 3: V√©rifier si la sc√®ne cible existe
    const targetScene = sceneManager.get(targetSceneKey);
    
    if (!targetScene) {
      console.error(`‚ùå [TransitionManager] Sc√®ne ${targetSceneKey} n'existe pas dans Phaser!`);
      console.error(`üí° Les sc√®nes disponibles:`, Object.keys(sceneManager.keys));
      this.hideLoadingOverlay();
      this.showErrorPopup(`Sc√®ne ${targetSceneKey} non trouv√©e dans le jeu`);
      this.isTransitioning = false;
      return;
    }

    // ‚úÖ √âTAPE 4: Forcer l'arr√™t de la sc√®ne cible si elle est active
    if (sceneManager.isActive(targetSceneKey)) {
      console.log(`‚èπÔ∏è [TransitionManager] Arr√™t forc√© de ${targetSceneKey}...`);
      sceneManager.stop(targetSceneKey);
      await this.waitForSceneState(targetSceneKey, 'stopped');
    }

    // ‚úÖ √âTAPE 5: Si la sc√®ne est sleeping, la r√©veiller d'abord puis l'arr√™ter
    if (sceneManager.isSleeping(targetSceneKey)) {
      console.log(`üò¥ [TransitionManager] R√©veil de ${targetSceneKey}...`);
      sceneManager.wake(targetSceneKey);
      await this.waitForSceneState(targetSceneKey, 'active');
      
      console.log(`‚èπÔ∏è [TransitionManager] Arr√™t apr√®s r√©veil de ${targetSceneKey}...`);
      sceneManager.stop(targetSceneKey);
      await this.waitForSceneState(targetSceneKey, 'stopped');
    }

    // ‚úÖ √âTAPE 6: D√©marrer avec un d√©lai pour s'assurer que tout est propre
   await this.waitForQueueToBeEmpty();
this.startSceneWithData(targetSceneKey, result);
  }

  // ‚úÖ NOUVELLE M√âTHODE: Attendre que toutes les sc√®nes s'arr√™tent
  async waitForAllScenesStop(exceptSceneKey, maxWait = 3000) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      
      const checkAllStopped = () => {
        const elapsed = Date.now() - startTime;
        
        if (elapsed > maxWait) {
          console.warn(`‚è∞ [TransitionManager] Timeout arr√™t toutes sc√®nes`);
          resolve(false);
          return;
        }
        
        const activeScenes = this.scene.scene.getScenes(true);
        const problematicScenes = activeScenes.filter(scene => 
          scene.scene.key !== 'LoaderScene' && 
          scene.scene.key !== exceptSceneKey
        );
        
        if (problematicScenes.length === 0) {
          console.log(`‚úÖ [TransitionManager] Toutes les sc√®nes sont arr√™t√©es`);
          resolve(true);
        } else {
          console.log(`‚è≥ [TransitionManager] ${problematicScenes.length} sc√®nes encore actives...`);
          setTimeout(checkAllStopped, 100);
        }
      };
      
      checkAllStopped();
    });
  }

  // ‚úÖ M√âTHODE 1: Red√©marrage propre (pour sc√®nes non visit√©es)
  async cleanSceneRestart(targetSceneKey, result) {
    console.log(`üîÑ [TransitionManager] === RED√âMARRAGE PROPRE ===`);
    console.log(`üéØ Vers: ${targetSceneKey}`);

    const sceneManager = this.scene.scene;

    // ‚úÖ V√©rifier si la sc√®ne existe
    const targetScene = sceneManager.get(targetSceneKey);
    
    if (targetScene) {
      console.log(`‚ôªÔ∏è [TransitionManager] Sc√®ne ${targetSceneKey} existe, red√©marrage...`);
      
      // Stopper si active
      if (sceneManager.isActive(targetSceneKey)) {
        console.log(`‚èπÔ∏è [TransitionManager] Stop de ${targetSceneKey}...`);
        sceneManager.stop(targetSceneKey);
        await this.waitForSceneState(targetSceneKey, 'stopped');
      }
      
      // D√©marrer avec nouvelles donn√©es
await this.waitForQueueToBeEmpty();
this.startSceneWithData(targetSceneKey, result);      
    } else {
      console.error(`‚ùå [TransitionManager] Sc√®ne ${targetSceneKey} n'existe pas dans Phaser!`);
      console.error(`üí° Les sc√®nes disponibles:`, Object.keys(sceneManager.keys));
      this.hideLoadingOverlay();
      this.showErrorPopup(`Sc√®ne ${targetSceneKey} non trouv√©e dans le jeu`);
      this.isTransitioning = false;
    }
  }

  // ‚úÖ M√âTHODE 2: Recreation compl√®te (si probl√®mes persistants)
  async fullSceneRecreation(targetSceneKey, result) {
    console.log(`üèóÔ∏è [TransitionManager] === RECREATION COMPL√àTE ===`);
    console.log(`‚ö†Ô∏è Cette m√©thode n√©cessite que toutes les sc√®nes soient pr√©-enregistr√©es dans Phaser`);

    const sceneManager = this.scene.scene;

    // Supprimer si existe
    if (sceneManager.get(targetSceneKey)) {
      console.log(`üóëÔ∏è [TransitionManager] Suppression ${targetSceneKey}...`);
      
      // Stopper d'abord
      if (sceneManager.isActive(targetSceneKey)) {
        sceneManager.stop(targetSceneKey);
        await this.waitForSceneState(targetSceneKey, 'stopped');
      }
      
      // Supprimer
      sceneManager.remove(targetSceneKey);
      await this.waitForSceneRemoval(targetSceneKey);
    }

    // ‚úÖ RECREATION - N√©cessite un registry des classes
    if (window.sceneRegistry) {
      try {
        console.log(`üè≠ [TransitionManager] Cr√©ation via SceneRegistry...`);
        const SceneClass = await window.sceneRegistry.getSceneClass(
          this.getZoneFromScene(targetSceneKey)
        );
        
        const sceneInstance = new SceneClass();
        sceneManager.add(targetSceneKey, sceneInstance, false);
        
        await this.waitForSceneRegistration(targetSceneKey);
        this.startSceneWithData(targetSceneKey, result);
        
      } catch (error) {
        console.error(`‚ùå [TransitionManager] Erreur cr√©ation via registry:`, error);
        this.hideLoadingOverlay();
        this.showErrorPopup(`Impossible de cr√©er la sc√®ne: ${error.message}`);
        this.isTransitioning = false;
      }
    } else {
      console.error(`‚ùå [TransitionManager] SceneRegistry non disponible!`);
      this.hideLoadingOverlay();
      this.showErrorPopup("Registry des sc√®nes non configur√©");
      this.isTransitioning = false;
    }
  }

  // ‚úÖ D√©marrer sc√®ne avec donn√©es de transition
  startSceneWithData(targetSceneKey, result) {
    const transitionData = {
      fromZone: this.currentZone,
      fromTransition: true,
      networkManager: this.scene.networkManager,
      mySessionId: this.scene.mySessionId,
      spawnX: result.position?.x,
      spawnY: result.position?.y,
      preservePlayer: true,
      transitionId: Date.now() // Pour debug
    };

    console.log(`üöÄ [TransitionManager] D√©marrage ${targetSceneKey} avec data:`, transitionData);
    this.scene.scene.start(targetSceneKey, transitionData);
  }

  // ‚úÖ Attendre qu'une sc√®ne soit dans un √©tat donn√©
  async waitForSceneState(sceneKey, targetState, maxWait = 2000) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      
      const checkState = () => {
        const elapsed = Date.now() - startTime;
        
        if (elapsed > maxWait) {
          console.warn(`‚è∞ [TransitionManager] Timeout attente √©tat ${targetState} pour ${sceneKey}`);
          resolve(false);
          return;
        }
        
        let currentState = 'unknown';
        const scene = this.scene.scene.get(sceneKey);
        
        if (!scene) {
          currentState = 'removed';
        } else if (this.scene.scene.isActive(sceneKey)) {
          currentState = 'active';
        } else if (this.scene.scene.isSleeping(sceneKey)) {
          currentState = 'sleeping';
        } else {
          currentState = 'stopped';
        }
        
        if (currentState === targetState) {
          console.log(`‚úÖ [TransitionManager] Sc√®ne ${sceneKey} √©tat: ${currentState}`);
          resolve(true);
        } else {
          setTimeout(checkState, 50);
        }
      };
      
      checkState();
    });
  }

  // ‚úÖ Attendre la suppression compl√®te
  async waitForSceneRemoval(sceneKey, maxWait = 2000) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      
      const checkRemoval = () => {
        const elapsed = Date.now() - startTime;
        
        if (elapsed > maxWait) {
          console.warn(`‚è∞ [TransitionManager] Timeout suppression ${sceneKey}`);
          resolve(false);
          return;
        }
        
        const scene = this.scene.scene.get(sceneKey);
        if (!scene) {
          console.log(`‚úÖ [TransitionManager] Sc√®ne ${sceneKey} supprim√©e`);
          resolve(true);
        } else {
          setTimeout(checkRemoval, 50);
        }
      };
      
      checkRemoval();
    });
  }

  // ‚úÖ Attendre l'enregistrement
  async waitForSceneRegistration(sceneKey, maxWait = 2000) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      
      const checkRegistration = () => {
        const elapsed = Date.now() - startTime;
        
        if (elapsed > maxWait) {
          console.warn(`‚è∞ [TransitionManager] Timeout enregistrement ${sceneKey}`);
          resolve(false);
          return;
        }
        
        const scene = this.scene.scene.get(sceneKey);
        if (scene) {
          console.log(`‚úÖ [TransitionManager] Sc√®ne ${sceneKey} enregistr√©e`);
          resolve(true);
        } else {
          setTimeout(checkRegistration, 50);
        }
      };
      
      checkRegistration();
    });
  }

  // ‚úÖ ERREUR DE TRANSITION
  handleTransitionError(result) {
    this.hideLoadingOverlay();
    this.showErrorPopup(result.reason || "Erreur de transition");
    this.isTransitioning = false;
  }

  // ‚úÖ LOADING OVERLAY STYLE POK√âMON
  showLoadingOverlay(teleportData) {
    // Conteneur principal
    this.loadingOverlay = this.scene.add.container(0, 0).setDepth(9999).setScrollFactor(0);

    // Fond semi-transparent
    const overlay = this.scene.add.rectangle(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      this.scene.cameras.main.width,
      this.scene.cameras.main.height,
      0x1a1a2e,
      0.9
    );

    // Conteneur du modal (style de ton UI)
    const modalWidth = 400;
    const modalHeight = 200;
    const modalBg = this.scene.add.rectangle(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      modalWidth,
      modalHeight,
      0x2d3748
    ).setStrokeStyle(2, 0x4a5568);

    // Bordure externe (style bleu de ton UI)
    const borderBg = this.scene.add.rectangle(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      modalWidth + 8,
      modalHeight + 8,
      0x4299e1
    );

    // Titre
    const titleText = this.scene.add.text(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY - 50,
      'Transition en cours...',
      {
        fontSize: '20px',
        fontFamily: 'Arial, sans-serif',
        color: '#ffffff',
        fontStyle: 'bold'
      }
    ).setOrigin(0.5);

    // Destination
    const destText = this.scene.add.text(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY - 20,
      `Vers: ${teleportData.targetZone}`,
      {
        fontSize: '16px',
        fontFamily: 'Arial, sans-serif',
        color: '#a0aec0'
      }
    ).setOrigin(0.5);

    // Spinner simple (rotation)
    const spinner = this.scene.add.text(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY + 20,
      '‚ü≥',
      {
        fontSize: '24px',
        color: '#4299e1'
      }
    ).setOrigin(0.5);

    // Animation rotation
    this.scene.tweens.add({
      targets: spinner,
      rotation: Math.PI * 2,
      duration: 1000,
      repeat: -1,
      ease: 'Linear'
    });

    // Ajouter au conteneur
    this.loadingOverlay.add([borderBg, modalBg, overlay, titleText, destText, spinner]);

    console.log(`üîÑ [TransitionManager] Loading affich√©`);
  }

  // ‚úÖ MASQUER LOADING
  hideLoadingOverlay() {
    if (this.loadingOverlay) {
      this.loadingOverlay.destroy();
      this.loadingOverlay = null;
      console.log(`üîÑ [TransitionManager] Loading masqu√©`);
    }
  }

  // ‚úÖ POPUP D'ERREUR SIMPLE
  showErrorPopup(message) {
    // Cr√©er popup temporaire
    const errorPopup = this.scene.add.container(0, 0).setDepth(10000).setScrollFactor(0);

    const popupBg = this.scene.add.rectangle(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      350, 120,
      0xdc2626
    ).setStrokeStyle(2, 0x991b1b);

    const errorText = this.scene.add.text(
      this.scene.cameras.main.centerX,
      this.scene.cameras.main.centerY,
      `Erreur de transition:\n${message}`,
      {
        fontSize: '14px',
        fontFamily: 'Arial, sans-serif',
        color: '#ffffff',
        align: 'center',
        wordWrap: { width: 300 }
      }
    ).setOrigin(0.5);

    errorPopup.add([popupBg, errorText]);

    // Auto-destruction apr√®s 3 secondes
    this.scene.time.delayedCall(3000, () => {
      if (errorPopup) {
        errorPopup.destroy();
      }
    });

    console.log(`üö´ [TransitionManager] Erreur affich√©e: ${message}`);
  }

  // ‚úÖ HELPER: R√©cup√©rer propri√©t√© d'objet Tiled
  getProperty(object, propertyName) {
    if (!object.properties) return null;
    const prop = object.properties.find(p => p.name === propertyName);
    return prop ? prop.value : null;
  }

  // ‚úÖ MAPPING ZONE ‚Üî SC√àNE
 getZoneFromScene(sceneName) {
  const mapping = {
    // Zones existantes
    'BeachScene': 'beach',
    'VillageScene': 'village',
    'VillageLabScene': 'villagelab',
    'Road1Scene': 'road1',
    'VillageHouse1Scene': 'villagehouse1',
    'LavandiaScene': 'lavandia',
    
    // Zones Lavandia
    'LavandiaAnalysisScene': 'lavandiaanalysis',
    'LavandiaBossRoomScene': 'lavandiabossroom',
    'LavandiaCelibTempleScene': 'lavandiacelebitemple',
    'LavandiaEquipmentScene': 'lavandiaequipment',
    'LavandiaFurnitureScene': 'lavandiafurniture',
    'LavandiaHealingCenterScene': 'lavandiahealingcenter',
    'LavandiaHouse1Scene': 'lavandiahouse1',
    'LavandiaHouse2Scene': 'lavandiahouse2',
    'LavandiaHouse3Scene': 'lavandiahouse3',
    'LavandiaHouse4Scene': 'lavandiahouse4',
    'LavandiaHouse5Scene': 'lavandiahouse5',
    'LavandiaHouse6Scene': 'lavandiahouse6',
    'LavandiaHouse7Scene': 'lavandiahouse7',
    'LavandiaHouse8Scene': 'lavandiahouse8',
    'LavandiaHouse9Scene': 'lavandiahouse9',
    'LavandiaResearchLabScene': 'lavandiaresearchlab',
    'LavandiaShopScene': 'lavandiashop',
    
    // Zones Village suppl√©mentaires
    'VillageFloristScene': 'villageflorist',
    'VillageHouse2Scene': 'villagehouse2',
    
    // Zones Road
    'Road1HouseScene': 'road1house',
        'Road1HiddenScene': 'road1hidden',

    'Road2Scene': 'road2',
    'Road3Scene': 'road3',
    
    // Zones Nocther Cave
    'NoctherCave1Scene': 'nocthercave1',
    'NoctherCave2Scene': 'nocthercave2',
    'NoctherCave2BisScene': 'nocthercave2bis'
  };
  return mapping[sceneName] || sceneName.toLowerCase();
}

getSceneFromZone(zoneName) {
  const mapping = {
    // Zones existantes
    'beach': 'BeachScene',
    'village': 'VillageScene',
    'villagelab': 'VillageLabScene',
    'road1': 'Road1Scene',
    'villagehouse1': 'VillageHouse1Scene',
    'lavandia': 'LavandiaScene',
    
    // Zones Lavandia
    'lavandiaanalysis': 'LavandiaAnalysisScene',
    'lavandiabossroom': 'LavandiaBossRoomScene',
    'lavandiacelebitemple': 'LavandiaCelibTempleScene',
    'lavandiaequipment': 'LavandiaEquipmentScene',
    'lavandiafurniture': 'LavandiaFurnitureScene',
    'lavandiahealingcenter': 'LavandiaHealingCenterScene',
    'lavandiahouse1': 'LavandiaHouse1Scene',
    'lavandiahouse2': 'LavandiaHouse2Scene',
    'lavandiahouse3': 'LavandiaHouse3Scene',
    'lavandiahouse4': 'LavandiaHouse4Scene',
    'lavandiahouse5': 'LavandiaHouse5Scene',
    'lavandiahouse6': 'LavandiaHouse6Scene',
    'lavandiahouse7': 'LavandiaHouse7Scene',
    'lavandiahouse8': 'LavandiaHouse8Scene',
    'lavandiahouse9': 'LavandiaHouse9Scene',
    'lavandiaresearchlab': 'LavandiaResearchLabScene',
    'lavandiashop': 'LavandiaShopScene',
    
    // Zones Village suppl√©mentaires
    'villageflorist': 'VillageFloristScene',
    'villagehouse2': 'VillageHouse2Scene',
    
    // Zones Road
    'road1house': 'Road1HouseScene',
        'road1hidden': 'Road1HiddenScene',

    'road2': 'Road2Scene',
    'road3': 'Road3Scene',
    
    // Zones Nocther Cave
    'nocthercave1': 'NoctherCave1Scene',
    'nocthercave2': 'NoctherCave2Scene',
    'nocthercave2bis': 'NoctherCave2BisScene'
  };
  return mapping[zoneName.toLowerCase()] || null;
}

  // ‚úÖ CONFIGURATION
  setTransitionStrategy(strategy = 'aggressive') {
    this.transitionStrategy = strategy;
    console.log(`üîß [TransitionManager] Strat√©gie transition: ${strategy}`);
    console.log(`üí° [TransitionManager] Strat√©gies disponibles: 'clean', 'aggressive', 'recreate'`);
  }

  setDebugMode(enabled) {
    this.debugMode = enabled;
    console.log(`üîß [TransitionManager] Debug mode: ${enabled ? 'ON' : 'OFF'}`);
  }

  // ‚úÖ DEBUG INFO
  debugInfo() {
    console.log(`üåÄ [TransitionManager] === DEBUG TRANSITION DYNAMIQUE ===`);
    console.log(`Zone actuelle: ${this.currentZone}`);
    console.log(`√âtat: ${this.isActive ? 'ACTIF' : 'INACTIF'}`);
    console.log(`En transition: ${this.isTransitioning}`);
    console.log(`Strat√©gie: ${this.transitionStrategy}`);
    console.log(`Debug mode: ${this.debugMode}`);
    
    console.log(`üìç T√âL√âPORTS (${this.teleportZones.size}):`);
    this.teleportZones.forEach((teleport, id) => {
      console.log(`  - ${id}: (${teleport.x}, ${teleport.y}) ‚Üí ${teleport.targetZone}[${teleport.targetSpawn}]`);
    });
    
    // Debug des sc√®nes disponibles
    if (this.scene?.scene?.manager?.keys) {
      console.log(`üé¨ SC√àNES DISPONIBLES:`, Object.keys(this.scene.scene.manager.keys));
      
      // √âtat de chaque sc√®ne
      Object.keys(this.scene.scene.manager.keys).forEach(sceneKey => {
        const isActive = this.scene.scene.isActive(sceneKey);
        const isSleeping = this.scene.scene.isSleeping(sceneKey);
        let status = 'STOPPED';
        if (isActive) status = 'ACTIVE';
        else if (isSleeping) status = 'SLEEPING';
        
        console.log(`    ${sceneKey}: ${status}`);
      });
    }
    
    // Debug du SceneRegistry s'il existe
    if (window.sceneRegistry) {
      console.log(`üìã SCENE REGISTRY DISPONIBLE:`);
      window.sceneRegistry.debugInfo();
    } else {
      console.log(`‚ö†Ô∏è AUCUN SCENE REGISTRY GLOBAL`);
    }
  }

  // ‚úÖ NETTOYAGE
  destroy() {
    console.log(`üåÄ [TransitionManager] Nettoyage...`);
    
    this.hideLoadingOverlay();
    this.teleportZones.clear();
    this.isActive = false;
    this.isTransitioning = false;
    
    // Nettoyer les listeners du NetworkManager
    if (this.scene.networkManager?.onTransitionValidation) {
      this.scene.networkManager.onTransitionValidation = null;
    }
    
    console.log(`üåÄ [TransitionManager] ‚úÖ Nettoy√©`);
  }

  // ‚úÖ CONTR√îLE EXTERNE
  setActive(active) {
    this.isActive = active;
    console.log(`üåÄ [TransitionManager] ${active ? 'Activ√©' : 'D√©sactiv√©'}`);
  }

  // ‚úÖ M√âTHODES UTILITAIRES POUR DEBUG ET TESTING
  
  // Forcer une transition (pour debug)
  forceTransition(targetZone, spawnX = 100, spawnY = 100) {
    console.log(`üöÄ [TransitionManager] === TRANSITION FORC√âE (DEBUG) ===`);
    
    const fakeTeleportData = {
      id: 'debug_teleport',
      targetZone: targetZone,
      targetSpawn: 'debug_spawn',
      fromZone: this.currentZone,
      x: 0, y: 0, width: 32, height: 32
    };
    
    this.triggerTransition(fakeTeleportData);
  }

  // V√©rifier l'√©tat des sc√®nes
  checkScenesHealth() {
    console.log(`üè• [TransitionManager] === SANT√â DES SC√àNES ===`);
    
    const sceneManager = this.scene.scene;
    const allScenes = Object.keys(sceneManager.keys);
    
    console.log(`üìä Total sc√®nes enregistr√©es: ${allScenes.length}`);
    
    allScenes.forEach(sceneKey => {
      const scene = sceneManager.get(sceneKey);
      const isActive = sceneManager.isActive(sceneKey);
      const isSleeping = sceneManager.isSleeping(sceneKey);
      
      let status = 'UNKNOWN';
      if (isActive) status = 'ACTIVE';
      else if (isSleeping) status = 'SLEEPING';
      else status = 'STOPPED';
      
      console.log(`  üìã ${sceneKey}: ${status} ${scene ? '‚úÖ' : '‚ùå'}`);
    });
    
    // V√©rifier si toutes nos zones ont leur sc√®ne
    const expectedZones = ['beach', 'village', 'villagelab', 'road1', 'villagehouse1', 'lavandia'];
    
    console.log(`üåç V√©rification des zones attendues:`);
    expectedZones.forEach(zone => {
      const sceneKey = this.getSceneFromZone(zone);
      const hasScene = !!sceneManager.get(sceneKey);
      console.log(`  üó∫Ô∏è ${zone} (${sceneKey}): ${hasScene ? '‚úÖ' : '‚ùå'}`);
    });
  }

  // ‚úÖ NOUVELLE M√âTHODE: Forcer l'arr√™t de toutes les sc√®nes probl√©matiques
  forceStopAllScenes(exceptSceneKey = null) {
    console.log(`üõë [TransitionManager] === ARR√äT FORC√â TOUTES SC√àNES ===`);
    
    const sceneManager = this.scene.scene;
    const allScenes = sceneManager.getScenes(true);
    
    console.log(`üõë [TransitionManager] ${allScenes.length} sc√®nes actives trouv√©es`);
    
    allScenes.forEach(scene => {
      if (scene.scene.key !== 'LoaderScene' && scene.scene.key !== exceptSceneKey) {
        console.log(`‚èπÔ∏è [TransitionManager] Arr√™t forc√©: ${scene.scene.key}`);
        sceneManager.stop(scene.scene.key);
      }
    });
    
    // V√©rifier aussi les sc√®nes sleeping
    const sleepingScenes = sceneManager.getScenes(false).filter(scene => 
      sceneManager.isSleeping(scene.scene.key) && 
      scene.scene.key !== 'LoaderScene' && 
      scene.scene.key !== exceptSceneKey
    );
    
    console.log(`üò¥ [TransitionManager] ${sleepingScenes.length} sc√®nes sleeping trouv√©es`);
    
    sleepingScenes.forEach(scene => {
      console.log(`‚èπÔ∏è [TransitionManager] R√©veil + arr√™t: ${scene.scene.key}`);
      sceneManager.wake(scene.scene.key);
      sceneManager.stop(scene.scene.key);
    });
    
    console.log(`‚úÖ [TransitionManager] Arr√™t forc√© termin√©`);
  }

  // Lister toutes les transitions possibles depuis la zone actuelle
  listAvailableTransitions() {
    console.log(`üîç [TransitionManager] === TRANSITIONS DISPONIBLES ===`);
    console.log(`üìç Zone actuelle: ${this.currentZone}`);
    
    if (this.teleportZones.size === 0) {
      console.log(`‚ö†Ô∏è Aucun t√©l√©port trouv√© dans cette zone`);
      return [];
    }
    
    const transitions = [];
    this.teleportZones.forEach((teleport, id) => {
      const transition = {
        id: id,
        from: teleport.fromZone,
        to: teleport.targetZone,
        spawn: teleport.targetSpawn,
        position: { x: teleport.x, y: teleport.y }
      };
      transitions.push(transition);
      
      console.log(`  üö™ ${id}: ${teleport.fromZone} ‚Üí ${teleport.targetZone}[${teleport.targetSpawn}] @ (${teleport.x}, ${teleport.y})`);
    });
    
    return transitions;
  }

  // Obtenir des statistiques de performance
  getPerformanceStats() {
    return {
      isActive: this.isActive,
      isTransitioning: this.isTransitioning,
      teleportCount: this.teleportZones.size,
      currentZone: this.currentZone,
      strategy: this.transitionStrategy,
      debugMode: this.debugMode,
      hasLoadingOverlay: !!this.loadingOverlay,
      lastTransitionTime: this.transitionStartTime,
      uptime: Date.now() - (this.initTime || Date.now())
    };
  }

  // R√©initialiser compl√®tement le syst√®me
  reset() {
    console.log(`üîÑ [TransitionManager] === RESET COMPLET ===`);
    
    this.destroy();
    
    // R√©initialiser les √©tats
    this.teleportZones = new Map();
    this.currentZone = this.getZoneFromScene(this.scene.scene.key);
    this.isActive = false;
    this.isTransitioning = false;
    this.loadingOverlay = null;
    this.transitionStartTime = 0;
    
    console.log(`‚úÖ [TransitionManager] Reset termin√©`);
  }

  // M√©thode pour tester la connectivit√© r√©seau
  testNetworkConnectivity() {
    console.log(`üåê [TransitionManager] === TEST CONNECTIVIT√â ===`);
    
    const hasNetworkManager = !!this.scene.networkManager;
    const hasRoom = !!this.scene.networkManager?.room;
    const isConnected = this.scene.networkManager?.isConnected;
    const roomState = this.scene.networkManager?.room?.state;
    
    console.log(`üì° NetworkManager: ${hasNetworkManager ? '‚úÖ' : '‚ùå'}`);
    console.log(`üè† Room: ${hasRoom ? '‚úÖ' : '‚ùå'}`);
    console.log(`üîå Connect√©: ${isConnected ? '‚úÖ' : '‚ùå'}`);
    console.log(`üìä State: ${roomState ? '‚úÖ' : '‚ùå'}`);
    
    if (hasRoom) {
      console.log(`üÜî Session ID: ${this.scene.networkManager.room.sessionId}`);
      console.log(`üåç Zone serveur: ${this.scene.networkManager.getCurrentZone()}`);
    }
    
    return {
      hasNetworkManager,
      hasRoom,
      isConnected,
      hasState: !!roomState
    };
  }
}
