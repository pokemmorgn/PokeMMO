// client/src/transitions/TransitionManager.js
// ‚úÖ VERSION SIMPLIFI√âE ET CLARIFI√âE

export class TransitionManager {
  constructor(scene) {
    this.scene = scene;
    this.isActive = false;
    this.debugMode = true; // ‚úÖ DEBUG TOUJOURS ACTIV√â
    this.isTransitioning = false;
    
    // Collections locales pour collision
    this.teleportZones = new Map();
    this.currentZone = this.getZoneFromScene(scene.scene.key);
    
    // Loading et timeout
    this.loadingOverlay = null;
    this.transitionTimeout = 8000; // 8 secondes max
    this.transitionTimeoutHandle = null;
    
    console.log(`üåÄ [TransitionManager] üìç INIT zone: ${this.currentZone} (sc√®ne: ${scene.scene.key})`);
  }

  // ‚úÖ √âTAPE 1 : Initialisation avec logs d√©taill√©s
  initialize() {
    console.log(`üåÄ [TransitionManager] === √âTAPE 1: SCAN T√âL√âPORTS ===`);
    
    if (!this.scene.map) {
      console.error(`üåÄ [TransitionManager] ‚ùå ERREUR: Aucune map dans la sc√®ne!`);
      return false;
    }

    console.log(`üåÄ [TransitionManager] ‚úÖ Map trouv√©e:`, {
      width: this.scene.map.width,
      height: this.scene.map.height,
      layers: this.scene.map.layers.length,
      objectLayers: this.scene.map.objects?.length || 0
    });

    // Chercher le layer "Worlds"
    const worldsLayer = this.scene.map.getObjectLayer('Worlds');
    if (!worldsLayer) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è WARN: Layer "Worlds" introuvable`);
      console.log(`üåÄ [TransitionManager] üìÇ Layers disponibles:`, 
        this.scene.map.objects?.map(layer => layer.name) || []
      );
      return false;
    }

    console.log(`üåÄ [TransitionManager] ‚úÖ Layer "Worlds" trouv√© avec ${worldsLayer.objects.length} objets`);

    // Scanner SEULEMENT les t√©l√©ports
    this.scanTeleports(worldsLayer);
    
    // Cr√©er les zones de collision
    this.createCollisionZones();
    
    this.isActive = true;
    this.logInitializationSummary();
    return true;
  }

  // ‚úÖ √âTAPE 2 : Scanner les t√©l√©ports avec logs d√©taill√©s
  scanTeleports(worldsLayer) {
    console.log(`üåÄ [TransitionManager] === √âTAPE 2: SCAN OBJETS ===`);
    
    let teleportCount = 0;
    let ignoredCount = 0;

    worldsLayer.objects.forEach((obj, index) => {
      const objName = (obj.name || '').toLowerCase();
      const objType = (obj.type || '').toLowerCase();
      
      console.log(`üåÄ [TransitionManager] üì¶ Objet ${index}: name="${obj.name}" type="${obj.type}" x=${obj.x} y=${obj.y}`);
      
      if (objName === 'teleport' || objType === 'teleport') {
        const success = this.processTeleport(obj, index);
        if (success) {
          teleportCount++;
        } else {
          ignoredCount++;
        }
      } else {
        console.log(`üåÄ [TransitionManager] ‚è≠Ô∏è Objet "${obj.name}" ignor√© (pas un t√©l√©port)`);
        ignoredCount++;
      }
    });

    console.log(`üåÄ [TransitionManager] üìä R√âSULTAT SCAN:`);
    console.log(`  - ‚úÖ T√©l√©ports trouv√©s: ${teleportCount}`);
    console.log(`  - ‚è≠Ô∏è Objets ignor√©s: ${ignoredCount}`);
    console.log(`  - üìç Total objets: ${worldsLayer.objects.length}`);
  }

  // ‚úÖ √âTAPE 3 : Traitement d'un t√©l√©port avec validation
  processTeleport(obj, index) {
    console.log(`üåÄ [TransitionManager] === √âTAPE 3: PROCESS T√âL√âPORT ${index} ===`);
    
    const targetZone = this.getProperty(obj, 'targetzone');
    const targetSpawn = this.getProperty(obj, 'targetspawn');

    console.log(`üåÄ [TransitionManager] üîç Propri√©t√©s trouv√©es:`);
    console.log(`  - targetzone: "${targetZone}"`);
    console.log(`  - targetspawn: "${targetSpawn}"`);
    console.log(`  - position: (${obj.x}, ${obj.y})`);
    console.log(`  - taille: ${obj.width}x${obj.height}`);

    // Validation
    if (!targetZone) {
      console.error(`üåÄ [TransitionManager] ‚ùå ERREUR: T√©l√©port ${index} sans 'targetzone'`);
      console.log(`üåÄ [TransitionManager] üìã Propri√©t√©s disponibles:`, obj.properties);
      return false;
    }

    if (!targetSpawn) {
      console.error(`üåÄ [TransitionManager] ‚ùå ERREUR: T√©l√©port ${index} sans 'targetspawn'`);
      return false;
    }

    // Cr√©er l'objet t√©l√©port
    const teleport = {
      id: `teleport_${index}`,
      x: obj.x,
      y: obj.y,
      width: obj.width || 32,
      height: obj.height || 32,
      targetZone: targetZone,
      targetSpawn: targetSpawn,
      fromZone: this.currentZone
    };

    this.teleportZones.set(teleport.id, teleport);
    
    console.log(`üåÄ [TransitionManager] ‚úÖ T√âL√âPORT CR√â√â: "${teleport.id}"`);
    console.log(`  - Route: ${this.currentZone} ‚Üí ${targetZone}[${targetSpawn}]`);
    console.log(`  - Zone: (${teleport.x}, ${teleport.y}) ${teleport.width}x${teleport.height}`);
    
    return true;
  }

  // ‚úÖ √âTAPE 4 : Cr√©ation zones collision avec debug visuel
  createCollisionZones() {
    console.log(`üåÄ [TransitionManager] === √âTAPE 4: CR√âATION COLLISIONS ===`);

    this.teleportZones.forEach((teleportData) => {
      console.log(`üåÄ [TransitionManager] üî® Cr√©ation zone: ${teleportData.id}`);
      
      // Zone invisible pour collision
      const zone = this.scene.add.zone(
        teleportData.x + teleportData.width / 2,
        teleportData.y + teleportData.height / 2,
        teleportData.width,
        teleportData.height
      );

      // Physique
      this.scene.physics.world.enableBody(zone, Phaser.Physics.Arcade.STATIC_BODY);
      zone.body.setSize(teleportData.width, teleportData.height);
      zone.transitionData = teleportData;

      // ‚úÖ DEBUG VISUEL TOUJOURS ACTIV√â
      this.createDebugVisuals(zone, teleportData);

      console.log(`üåÄ [TransitionManager] ‚úÖ Zone collision active: ${teleportData.id}`);
    });

    console.log(`üåÄ [TransitionManager] ‚úÖ ${this.teleportZones.size} zones collision cr√©√©es`);
  }

  // ‚úÖ DEBUG VISUEL AM√âLIOR√â
  createDebugVisuals(zone, teleportData) {
    // Rectangle de zone - TOUJOURS VISIBLE
    const debugRect = this.scene.add.rectangle(
      zone.x, zone.y,
      zone.displayWidth, zone.displayHeight,
      0x00ff00, 0.3 // ‚úÖ Plus visible
    );
    debugRect.setDepth(999);
    debugRect.setStrokeStyle(3, 0x00aa00); // ‚úÖ Plus √©pais
    
    // Texte avec zone de destination - TOUJOURS VISIBLE
    const debugText = this.scene.add.text(
      zone.x, zone.y - 25,
      `üö™ ‚Üí ${teleportData.targetZone}`,
      {
        fontSize: '14px', // ‚úÖ Plus gros
        fill: '#ffffff',
        backgroundColor: '#000000',
        padding: { x: 6, y: 4 }
      }
    );
    debugText.setDepth(1000);
    debugText.setOrigin(0.5);
    
    console.log(`üåÄ [TransitionManager] üé® Debug visuel cr√©√© pour ${teleportData.id}`);
  }

  // ‚úÖ √âTAPE 5 : V√©rification collision avec logs
  checkCollisions(player) {
    if (!this.isActive || !player || this.isTransitioning) return;

    // ‚úÖ LOG P√âRIODIQUE DE LA POSITION DU JOUEUR (toutes les 2 secondes)
    if (!this.lastPlayerLogTime || Date.now() - this.lastPlayerLogTime > 2000) {
      console.log(`üåÄ [TransitionManager] üë§ Position joueur: (${Math.round(player.x)}, ${Math.round(player.y)})`);
      this.lastPlayerLogTime = Date.now();
    }

    this.teleportZones.forEach((teleportData) => {
      if (this.isPlayerCollidingWithTeleport(player, teleportData)) {
        console.log(`üåÄ [TransitionManager] üí• COLLISION D√âTECT√âE avec ${teleportData.id}!`);
        this.triggerTransition(teleportData);
      }
    });
  }

  // ‚úÖ COLLISION AVEC LOGS
  isPlayerCollidingWithTeleport(player, teleportData) {
    const playerBounds = {
      x: player.x - 16,
      y: player.y - 32,
      width: 32,
      height: 32
    };

    const teleportBounds = {
      x: teleportData.x,
      y: teleportData.y,
      width: teleportData.width,
      height: teleportData.height
    };

    const isColliding = (
      playerBounds.x < teleportBounds.x + teleportBounds.width &&
      playerBounds.x + playerBounds.width > teleportBounds.x &&
      playerBounds.y < teleportBounds.y + teleportBounds.height &&
      playerBounds.y + playerBounds.height > teleportBounds.y
    );

    // ‚úÖ LOG D√âTAILL√â SEULEMENT SI COLLISION
    if (isColliding) {
      console.log(`üåÄ [TransitionManager] üéØ COLLISION ${teleportData.id}:`);
      console.log(`  - Joueur: (${playerBounds.x}, ${playerBounds.y}) ${playerBounds.width}x${playerBounds.height}`);
      console.log(`  - T√©l√©port: (${teleportBounds.x}, ${teleportBounds.y}) ${teleportBounds.width}x${teleportBounds.height}`);
    }

    return isColliding;
  }

  // ‚úÖ √âTAPE 6 : D√©clenchement transition avec timeout
  async triggerTransition(teleportData) {
    if (this.isTransitioning) {
      console.warn(`üåÄ [TransitionManager] ‚ö†Ô∏è Transition d√©j√† en cours, annulation`);
      return;
    }

    console.log(`üåÄ [TransitionManager] === √âTAPE 6: D√âBUT TRANSITION ===`);
    console.log(`üìç De: ${teleportData.fromZone}`);
    console.log(`üìç Vers: ${teleportData.targetZone}`);
    console.log(`üéØ Spawn: ${teleportData.targetSpawn}`);

    this.isTransitioning = true;

    // ‚úÖ LOADING IMM√âDIAT
    this.showLoadingOverlay(teleportData);

    // ‚úÖ TIMEOUT DE S√âCURIT√â
    this.transitionTimeoutHandle = setTimeout(() => {
      console.error(`üåÄ [TransitionManager] ‚è∞ TIMEOUT TRANSITION (${this.transitionTimeout}ms)`);
      this.handleTransitionError({ reason: "Timeout de transition" });
    }, this.transitionTimeout);

    // ‚úÖ VALIDATION ZONE AVANT ENVOI
    const correctionResult = await this.validateAndCorrectZone(teleportData);
    if (!correctionResult.success) {
      this.handleTransitionError(correctionResult);
      return;
    }

    // ‚úÖ ENVOI AU SERVEUR
    this.sendTransitionRequest(correctionResult.correctedData);
  }

  // ‚úÖ VALIDATION ET CORRECTION DE ZONE
  async validateAndCorrectZone(teleportData) {
    console.log(`üåÄ [TransitionManager] === VALIDATION ZONE ===`);
    
    const clientZone = this.scene.zoneName;
    const serverZone = this.scene.networkManager?.getCurrentZone();
    
    console.log(`üîç Zone client: "${clientZone}"`);
    console.log(`üîç Zone serveur: "${serverZone}"`);
    console.log(`üîç Zone t√©l√©port: "${teleportData.fromZone}"`);
    
    // Si tout est sync, OK
    if (clientZone === serverZone && serverZone === teleportData.fromZone) {
      console.log(`‚úÖ Zones synchronis√©es`);
      return { success: true, correctedData: teleportData };
    }
    
    // Correction automatique
    console.warn(`‚ö†Ô∏è D√âSYNCHRONISATION D√âTECT√âE - CORRECTION AUTO`);
    const correctedFromZone = serverZone || clientZone;
    
    const correctedData = {
      ...teleportData,
      fromZone: correctedFromZone
    };
    
    console.log(`üîß Zone corrig√©e: ${teleportData.fromZone} ‚Üí ${correctedFromZone}`);
    
    return { success: true, correctedData };
  }

  // ‚úÖ ENVOI REQU√äTE AU SERVEUR
  sendTransitionRequest(teleportData) {
    console.log(`üåÄ [TransitionManager] === ENVOI SERVEUR ===`);
    
    if (!this.scene.networkManager?.room) {
      console.error(`‚ùå Pas de connexion serveur`);
      this.handleTransitionError({ reason: "Pas de connexion serveur" });
      return;
    }

    const myPlayer = this.scene.playerManager?.getMyPlayer();
    if (!myPlayer) {
      console.error(`‚ùå Joueur local introuvable`);
      this.handleTransitionError({ reason: "Joueur local introuvable" });
      return;
    }

    const request = {
      fromZone: teleportData.fromZone,
      targetZone: teleportData.targetZone,
      targetSpawn: teleportData.targetSpawn,
      playerX: myPlayer.x,
      playerY: myPlayer.y,
      teleportId: teleportData.id
    };

    console.log(`üì§ Envoi requ√™te:`, request);
    
    // ‚úÖ SETUP LISTENER R√âPONSE
    this.setupTransitionListener(teleportData);
    
    // ‚úÖ ENVOI
    this.scene.networkManager.room.send("validateTransition", request);
  }

  // ‚úÖ LISTENER R√âPONSE SERVEUR
  setupTransitionListener(teleportData) {
    console.log(`üëÇ Setup listener validation...`);

    // ‚úÖ Nettoyer ancien listener
    if (this.scene.networkManager.onTransitionValidation) {
      this.scene.networkManager.onTransitionValidation = null;
    }

    // ‚úÖ Handler r√©ponse
    const handleResponse = (result) => {
      console.log(`üì® R√©ponse serveur:`, result);
      
      this.clearTransitionTimeout();
      this.scene.networkManager.onTransitionValidation = null;
      
      if (result.success) {
        this.handleTransitionSuccess(result, teleportData);
      } else {
        this.handleTransitionError(result);
      }
    };

    this.scene.networkManager.onTransitionValidation = handleResponse;
  }

  // ‚úÖ SUCC√àS TRANSITION
  handleTransitionSuccess(result, teleportData) {
    console.log(`üåÄ [TransitionManager] ‚úÖ TRANSITION VALID√âE`);
    
    const targetScene = this.getSceneFromZone(teleportData.targetZone);
    
    if (!targetScene) {
      console.error(`‚ùå Scene introuvable pour zone: ${teleportData.targetZone}`);
      this.handleTransitionError({ reason: `Zone inconnue: ${teleportData.targetZone}` });
      return;
    }

    // M√™me sc√®ne = repositionnement local
    if (targetScene === this.scene.scene.key) {
      console.log(`üìç Repositionnement local`);
      this.repositionPlayer(result);
      this.hideLoadingOverlay();
      this.resetTransitionState();
      return;
    }

    // Changement de sc√®ne
    console.log(`üöÄ Changement vers: ${targetScene}`);
    
    const transitionData = {
      fromZone: this.currentZone,
      fromTransition: true,
      networkManager: this.scene.networkManager,
      mySessionId: this.scene.mySessionId,
      spawnX: result.position?.x,
      spawnY: result.position?.y,
      preservePlayer: true
    };

    this.scene.scene.start(targetScene, transitionData);
  }

  // ‚úÖ ERREUR TRANSITION
  handleTransitionError(result) {
    console.error(`üåÄ [TransitionManager] ‚ùå ERREUR TRANSITION:`, result.reason);
    this.hideLoadingOverlay();
    this.showErrorPopup(result.reason || "Erreur de transition");
    this.resetTransitionState();
  }

  // ‚úÖ RESET √âTAT TRANSITION
  resetTransitionState() {
    this.isTransitioning = false;
    this.clearTransitionTimeout();
    console.log(`üåÄ [TransitionManager] üîÑ √âtat transition r√©initialis√©`);
  }

  // ‚úÖ CLEAR TIMEOUT
  clearTransitionTimeout() {
    if (this.transitionTimeoutHandle) {
      clearTimeout(this.transitionTimeoutHandle);
      this.transitionTimeoutHandle = null;
    }
  }

  // ‚úÖ REPOSITIONNEMENT LOCAL
  repositionPlayer(result) {
    const myPlayer = this.scene.playerManager?.getMyPlayer();
    if (myPlayer && result.position) {
      console.log(`üìç Repositionnement: (${result.position.x}, ${result.position.y})`);
      
      myPlayer.x = result.position.x;
      myPlayer.y = result.position.y;
      myPlayer.targetX = result.position.x;
      myPlayer.targetY = result.position.y;

      if (this.scene.cameraManager) {
        this.scene.cameraManager.snapToPlayer();
      }
    }
  }

  // ‚úÖ LOADING OVERLAY
  showLoadingOverlay(teleportData) {
    console.log(`üîÑ Affichage loading...`);
    // ... code loading identique ...
    this.loadingOverlay = this.scene.add.container(0, 0).setDepth(9999).setScrollFactor(0);
    // ... reste du code loading ...
  }

  hideLoadingOverlay() {
    if (this.loadingOverlay) {
      this.loadingOverlay.destroy();
      this.loadingOverlay = null;
      console.log(`üîÑ Loading masqu√©`);
    }
  }

  // ‚úÖ POPUP ERREUR
  showErrorPopup(message) {
    console.log(`üö´ Affichage erreur: ${message}`);
    // ... code popup identique ...
  }

  // ‚úÖ LOG R√âSUM√â INITIALISATION
  logInitializationSummary() {
    console.log(`üåÄ [TransitionManager] === R√âSUM√â INITIALISATION ===`);
    console.log(`üìç Zone courante: ${this.currentZone}`);
    console.log(`üîß √âtat: ${this.isActive ? 'ACTIF' : 'INACTIF'}`);
    console.log(`üìç T√©l√©ports trouv√©s: ${this.teleportZones.size}`);
    
    if (this.teleportZones.size > 0) {
      console.log(`üìã LISTE DES T√âL√âPORTS:`);
      this.teleportZones.forEach((teleport, id) => {
        console.log(`  - ${id}: (${teleport.x}, ${teleport.y}) ‚Üí ${teleport.targetZone}[${teleport.targetSpawn}]`);
      });
    }
    
    console.log(`üåÄ [TransitionManager] === INITIALISATION TERMIN√âE ===`);
  }

  // ‚úÖ HELPERS UTILITAIRES
  getProperty(object, propertyName) {
    if (!object.properties) return null;
    const prop = object.properties.find(p => p.name === propertyName);
    return prop ? prop.value : null;
  }

  getZoneFromScene(sceneName) {
    const mapping = {
      'BeachScene': 'beach',
      'VillageScene': 'village',
      'VillageLabScene': 'villagelab',
      'Road1Scene': 'road1',
      'VillageHouse1Scene': 'villagehouse1',
      'LavandiaScene': 'lavandia'
    };
    return mapping[sceneName] || sceneName.toLowerCase();
  }

  getSceneFromZone(zoneName) {
    const mapping = {
      'beach': 'BeachScene',
      'village': 'VillageScene',
      'villagelab': 'VillageLabScene',
      'road1': 'Road1Scene',
      'villagehouse1': 'VillageHouse1Scene',
      'lavandia': 'LavandiaScene'
    };
    return mapping[zoneName] || null;
  }

  // ‚úÖ DEBUG ET NETTOYAGE
  debugInfo() {
    this.logInitializationSummary();
  }

  destroy() {
    console.log(`üåÄ [TransitionManager] üíÄ Destruction...`);
    
    this.hideLoadingOverlay();
    this.clearTransitionTimeout();
    this.teleportZones.clear();
    this.isActive = false;
    this.isTransitioning = false;
    
    console.log(`üåÄ [TransitionManager] ‚úÖ D√©truit`);
  }

  setActive(active) {
    this.isActive = active;
    console.log(`üåÄ [TransitionManager] ${active ? '‚úÖ ACTIV√â' : '‚ùå D√âSACTIV√â'}`);
  }
}
