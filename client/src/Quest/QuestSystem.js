// Quest/QuestSystem.js - VERSION COMPL√àTE AVEC QUESTDELIVERYOVERLAY
// üì¶ Syst√®me complet avec overlay de livraison int√©gr√©
// ‚úÖ Connexions r√©seau pour livraison de qu√™tes + UI unifi√©e
// üõ°Ô∏è CORRECTION: Protection contre double envoi questDelivery

export class QuestSystem {
  constructor(gameRoom, networkManager) {
    this.gameRoom = gameRoom;
    this.networkManager = networkManager;
    
    // === √âTAT SIMPLE ===
    this.ready = false;
    this.activeQuests = [];
    this.availableQuests = [];
    this.completedQuests = [];
    
    // === UI COMPOSANTS ===
    this.ui = null;
    this.icon = null;
    this.tracker = null;
    this.detailsUI = null;
    // ‚úÖ NOUVEAU : QuestDeliveryOverlay
    this.deliveryOverlay = null;
    
    // === CALLBACKS ===
    this.onQuestUpdate = null;
    this.onQuestCompleted = null;
    this.onQuestStarted = null;
    // ‚úÖ NOUVEAU : Callbacks livraison
    this.onQuestDelivery = null;
    this.onDeliveryComplete = null;
    this.onDeliveryFailed = null;
    
    // === √âTAT LIVRAISON ===
    this.deliveryState = {
      currentDelivery: null,
      isDelivering: false,
      lastDeliveryTime: 0,
      deliveryHistory: [],
      // üõ°Ô∏è NOUVEAU : Protection double envoi au niveau syst√®me
      preventDoubleDelivery: true,
      deliveryCooldown: 3000, // 3 secondes entre livraisons syst√®me
      lastDeliveryNonce: null
    };
    
    console.log('üìñ [QuestSystem] Instance cr√©√©e avec QuestDeliveryOverlay et protection double envoi');
  }
  
  // === üöÄ INITIALISATION ===
  
  async init() {
    try {
      console.log('üöÄ [QuestSystem] Initialisation compl√®te...');
      
      this.setupNetworkHandlers();
      await this.createUI();
      
      this.ready = true;
      console.log('‚úÖ [QuestSystem] Pr√™t avec syst√®me de livraison complet !');
      
      return this;
    } catch (error) {
      console.error('‚ùå [QuestSystem] Erreur init:', error);
      throw error;
    }
  }

  // === üé® INTERFACE UTILISATEUR COMPL√àTE ===
  
  async createUI() {
    try {
      await this.createIcon();
      await this.createMainUI();
      await this.createTracker();
      await this.createQuestDetailsUI();
      // ‚úÖ NOUVEAU : Cr√©er QuestDeliveryOverlay
      await this.createQuestDeliveryOverlay();
      
      console.log('üé® [QuestSystem] UI compl√®te cr√©√©e avec overlay de livraison');
    } catch (error) {
      console.error('‚ùå [QuestSystem] Erreur cr√©ation UI:', error);
    }
  }
  
  async createIcon() {
    const { QuestIcon } = await import('./QuestIcon.js');
    
    const optionsManager = window.optionsSystem?.manager || 
                           window.optionsSystemGlobal?.manager ||
                           window.optionsSystem;
    
    this.icon = new QuestIcon(this, optionsManager);
    await this.icon.init();
    
    this.icon.onClick = () => {
      if (this.ui) {
        this.ui.toggle();
      }
    };
  }
  
  async createMainUI() {
    const { QuestUI } = await import('./QuestUI.js');
    this.ui = new QuestUI(this, this.gameRoom);
    await this.ui.init();
    
    this.ui.onAction = (action, data) => {
      this.handleUIAction(action, data);
    };
  }
  
  async createTracker() {
    this.tracker = this.ui;
    console.log('üìä [QuestSystem] Tracker r√©f√©rence ui configur√©');
  }
  
  async createQuestDetailsUI() {
    const { QuestDetailsUI } = await import('./QuestDetailsUI.js');
    
    const optionsManager = window.optionsSystem?.manager || 
                           window.optionsSystemGlobal?.manager ||
                           window.optionsSystem;
    
    this.detailsUI = new QuestDetailsUI(this, optionsManager);
    await this.detailsUI.init();
    
    this.detailsUI.onQuestAccept = (questId, npcId, questData) => {
      this.handleQuestAcceptFromUI(questId, npcId, questData);
    };
    
    this.detailsUI.onClose = () => {
      console.log('üìã [QuestSystem] QuestDetailsUI ferm√©');
    };
    
    console.log('üìã [QuestSystem] QuestDetailsUI cr√©√© et connect√©');
  }

  // ‚úÖ NOUVELLE M√âTHODE : Cr√©er QuestDeliveryOverlay
  async createQuestDeliveryOverlay() {
    try {
      const { QuestDeliveryOverlay } = await import('./QuestDeliveryOverlay.js');
      
      this.deliveryOverlay = new QuestDeliveryOverlay(this, this.networkManager);
      await this.deliveryOverlay.init();
      
      // üõ°Ô∏è MODIFICATION CRITIQUE : Supprimer callback qui cause double envoi
      // ‚ùå ANCIEN CODE QUI CAUSAIT LE DOUBLE ENVOI :
      // this.deliveryOverlay.onDeliveryConfirm = (deliveryData, npcId) => {
      //   this.handleDeliveryConfirmFromOverlay(deliveryData, npcId);
      // };
      
      // ‚úÖ NOUVEAU : Pas de callback syst√®me, seulement callback UI
      this.deliveryOverlay.onClose = () => {
        console.log('üéÅ [QuestSystem] QuestDeliveryOverlay ferm√©');
        this.deliveryState.currentDelivery = null;
        this.deliveryState.isDelivering = false;
      };
      
      console.log('üéÅ [QuestSystem] QuestDeliveryOverlay cr√©√© SANS callback double envoi');
      
    } catch (error) {
      console.error('‚ùå [QuestSystem] Erreur cr√©ation QuestDeliveryOverlay:', error);
      this.deliveryOverlay = null;
    }
  }
  
  // === üì° HANDLERS R√âSEAU AVEC LIVRAISON ===
  
  setupNetworkHandlers() {
    if (!this.networkManager || !this.networkManager.room) {
      console.warn('‚ö†Ô∏è [QuestSystem] NetworkManager/room non disponible');
      return;
    }
    
    console.log('üì° [QuestSystem] Enregistrement handlers avec livraison...');
    
    // ‚úÖ HANDLERS EXISTANTS
    this.networkManager.room.onMessage("questAcceptResult", (data) => {
      console.log('üì® [QuestSystem] RE√áU questAcceptResult:', data);
      this.handleQuestAcceptResult(data);
    });
    
    this.networkManager.room.onMessage("questDetailsResult", (data) => {
      console.log('üì® [QuestSystem] RE√áU questDetailsResult:', data);
    });
    
    this.networkManager.room.onMessage("questStatuses", (data) => {
      console.log('üì® [QuestSystem] RE√áU questStatuses:', data);
    });
    
    this.networkManager.room.onMessage("questProgressUpdate", (data) => {
      console.log('üì® [QuestSystem] RE√áU questProgressUpdate:', data);
      this.handleQuestProgressUpdate(data);
    });
    
    this.networkManager.room.onMessage("activeQuestsList", (data) => {
      console.log('üì® [QuestSystem] RE√áU activeQuestsList:', data);
      this.handleActiveQuests(data);
    });
    
    this.networkManager.room.onMessage("availableQuestsList", (data) => {
      console.log('üì® [QuestSystem] RE√áU availableQuestsList:', data);
      this.handleAvailableQuests(data);
    });
    
    this.networkManager.room.onMessage("questStartResult", (data) => {
      console.log('üì® [QuestSystem] RE√áU questStartResult:', data);
      this.handleQuestStartResult(data);
    });
    
    this.networkManager.room.onMessage("introQuestCompleted", (data) => {
      console.log('üì® [QuestSystem] RE√áU introQuestCompleted:', data);
      this.handleIntroQuestCompleted(data);
    });
    
    this.networkManager.room.onMessage("questDebugInfo", (data) => {
      console.log('üì® [QuestSystem] RE√áU questDebugInfo:', data);
      console.table(data);
    });
    
    // ‚úÖ NOUVEAUX HANDLERS : Syst√®me de livraison
    this.networkManager.room.onMessage("questDelivery", (data) => {
      console.log('üì® [QuestSystem] RE√áU questDelivery (donn√©es livraison):', data);
      this.handleQuestDeliveryData(data);
    });
    
    this.networkManager.room.onMessage("questDeliveryResult", (data) => {
      console.log('üì® [QuestSystem] RE√áU questDeliveryResult (r√©sultat livraison):', data);
      this.handleQuestDeliveryResult(data);
    });
    
    this.networkManager.room.onMessage("questDeliveryError", (data) => {
      console.log('üì® [QuestSystem] RE√áU questDeliveryError:', data);
      this.handleQuestDeliveryError(data);
    });
    
    // ‚úÖ HANDLER INTERACTION NPC pour compatibilit√©
    this.networkManager.room.onMessage("npcInteractionResult", (data) => {
      if (this.isQuestInteraction(data)) {
        console.log('üìã [QuestSystem] Interaction NPC quest d√©tect√©e');
        
        // ‚úÖ NOUVEAU : V√©rifier si c'est une livraison
        if (this.isDeliveryInteraction(data)) {
          console.log('üéÅ [QuestSystem] Interaction de livraison d√©tect√©e');
          this.handleQuestDeliveryData(data);
        }
      }
    });
    
    console.log('üì° [QuestSystem] Handlers r√©seau avec livraison configur√©s');
  }

  // === üéÅ NOUVEAUX HANDLERS : SYST√àME DE LIVRAISON ===

  /**
   * Handler pour donn√©es de livraison re√ßues du serveur
   * @param {Object} data - Donn√©es de livraison
   */
 handleQuestDeliveryData(data) {
  console.log('üéÅ [QuestSystem] === TRAITEMENT DONN√âES LIVRAISON ===');
  console.log('üìä Data re√ßue:', data);
  
  if (!this.deliveryOverlay) {
    console.error('‚ùå [QuestSystem] QuestDeliveryOverlay non disponible');
    this.showMessage('Interface de livraison non disponible', 'error');
    return false;
  }
  
  try {
    // ‚úÖ NOUVEAU : Afficher le dialogue EN PREMIER si disponible
    if (data.lines && data.lines.length > 0) {
      console.log('üí¨ [QuestSystem] Affichage dialogue avec livraison');
      this.showDialogueWithDelivery(data);
    }
    
    // ‚úÖ Extraire les donn√©es de livraison selon le format serveur
    const deliveryData = this.extractDeliveryData(data);
    
    if (!deliveryData || !deliveryData.items || deliveryData.items.length === 0) {
      console.warn('‚ö†Ô∏è [QuestSystem] Donn√©es de livraison invalides');
      this.showMessage('Aucun objet √† livrer', 'warning');
      return false;
    }
    
    console.log('‚úÖ [QuestSystem] Donn√©es de livraison extraites:', deliveryData);
    
    // ‚úÖ Stocker l'√©tat de livraison
    this.deliveryState.currentDelivery = deliveryData;
    this.deliveryState.isDelivering = false;
    this.deliveryState.lastDeliveryTime = Date.now();
    
    // ‚úÖ MODIFI√â : Afficher l'overlay avec un l√©ger d√©lai si dialogue affich√©
    const showDeliveryOverlay = () => {
      const success = this.deliveryOverlay.show(deliveryData);
      
      if (success) {
        console.log('‚úÖ [QuestSystem] Overlay de livraison affich√©');
        
        // ‚úÖ Callback custom
        if (this.onQuestDelivery && typeof this.onQuestDelivery === 'function') {
          this.onQuestDelivery(deliveryData);
        }
        
        return true;
      } else {
        throw new Error('√âchec affichage overlay');
      }
    };
    
    // ‚úÖ Si dialogue affich√©, attendre un peu avant d'afficher l'overlay
    if (data.lines && data.lines.length > 0) {
      // D√©lai pour que le joueur puisse lire le dialogue
      setTimeout(() => {
        showDeliveryOverlay();
      }, 500); // 500ms de d√©lai
    } else {
      // Sinon afficher imm√©diatement
      showDeliveryOverlay();
    }
    
    return true;
    
  } catch (error) {
    console.error('‚ùå [QuestSystem] Erreur traitement donn√©es livraison:', error);
    this.showMessage(`Erreur livraison: ${error.message}`, 'error');
    return false;
  }
}

// ‚úÖ NOUVELLE M√âTHODE : Afficher dialogue avec indicateur de livraison
showDialogueWithDelivery(data) {
  console.log('üí¨ [QuestSystem] === AFFICHAGE DIALOGUE AVEC LIVRAISON ===');
  
  // Pr√©parer les donn√©es de dialogue
  const dialogueData = {
    portrait: data.portrait || '/assets/portrait/defaultPortrait.png',
    name: data.npcName || 'NPC',
    lines: data.lines || ["J'attends que vous me livriez quelque chose..."],
    
    // ‚úÖ NOUVEAU : Ajouter un indicateur visuel de livraison
    showDeliveryIndicator: true,
    deliveryIcon: 'üì¶',
    
    // ‚úÖ Options d'affichage
    options: {
      autoClose: false, // Ne pas fermer automatiquement
      showSkipButton: true,
      showDeliveryHint: true,
      deliveryHintText: 'üì¶ Livraison disponible'
    },
    
    // ‚úÖ Callback quand le dialogue est ferm√©
    onClose: () => {
      console.log('üí¨ [QuestSystem] Dialogue ferm√©, overlay livraison reste visible');
    }
  };
  
  // Utiliser le syst√®me de dialogue disponible
  if (window.dialogueManager && typeof window.dialogueManager.show === 'function') {
    console.log('üÜï [QuestSystem] Utilisation DialogueManager');
    window.dialogueManager.show(dialogueData);
  } else if (typeof window.showNpcDialogue === 'function') {
    console.log('üîÑ [QuestSystem] Utilisation ancien syst√®me dialogue');
    window.showNpcDialogue(dialogueData);
  } else if (typeof window.showDialogue === 'function') {
    console.log('üîÑ [QuestSystem] Utilisation showDialogue');
    window.showDialogue(dialogueData);
  } else {
    console.warn('‚ö†Ô∏è [QuestSystem] Aucun syst√®me dialogue disponible');
    // Afficher au moins le message
    this.showMessage(data.lines[0] || "Livraison disponible", 'info');
  }
}

// ‚úÖ OPTIONNEL : M√©thode pour afficher les deux simultan√©ment
showDialogueAndDeliverySimultaneous(data) {
  console.log('üé≠ [QuestSystem] === AFFICHAGE SIMULTAN√â DIALOGUE + LIVRAISON ===');
  
  // 1. Afficher le dialogue
  if (data.lines && data.lines.length > 0) {
    const dialogueData = {
      portrait: data.portrait || '/assets/portrait/defaultPortrait.png',
      name: data.npcName || 'NPC',
      lines: data.lines,
      
      // ‚úÖ Positionner le dialogue pour ne pas cacher l'overlay
      position: 'top', // ou 'left' selon votre UI
      compact: true, // Mode compact pour laisser de la place
      
      options: {
        autoClose: false,
        showSkipButton: false, // Pas de skip, l'overlay est plus important
        fadeBackground: false // Ne pas assombrir le fond
      }
    };
    
    if (window.dialogueManager) {
      window.dialogueManager.show(dialogueData);
    }
  }
  
  // 2. Afficher l'overlay de livraison EN M√äME TEMPS
  const deliveryData = this.extractDeliveryData(data);
  if (deliveryData && deliveryData.items && deliveryData.items.length > 0) {
    // Positionner l'overlay pour ne pas chevaucher avec le dialogue
    deliveryData.position = 'center'; // ou 'bottom' selon votre UI
    deliveryData.offsetY = 100; // D√©caler si n√©cessaire
    
    this.deliveryOverlay.show(deliveryData);
  }
  
  return true;
}

// ‚úÖ M√âTHODE ALTERNATIVE : Mode "conversation + livraison"
showConversationWithDelivery(data) {
  console.log('üí¨üì¶ [QuestSystem] === MODE CONVERSATION AVEC LIVRAISON ===');
  
  // Cr√©er un dialogue enrichi qui inclut l'info de livraison
  const enrichedDialogue = {
    portrait: data.portrait || '/assets/portrait/defaultPortrait.png',
    name: data.npcName || 'NPC',
    lines: [
      ...(data.lines || []),
      "", // Ligne vide pour s√©parer
      "üì¶ **Objets √† livrer:**"
    ],
    
    // ‚úÖ Ajouter la liste des items dans le dialogue
    additionalContent: this.formatDeliveryItemsForDialogue(data),
    
    // ‚úÖ Actions dans le dialogue
    actions: [
      {
        label: "üì¶ Voir d√©tails livraison",
        action: () => {
          // Fermer dialogue et ouvrir overlay
          if (window.dialogueManager) window.dialogueManager.hide();
          const deliveryData = this.extractDeliveryData(data);
          this.deliveryOverlay.show(deliveryData);
        }
      },
      {
        label: "‚ùå Plus tard",
        action: () => {
          if (window.dialogueManager) window.dialogueManager.hide();
        }
      }
    ]
  };
  
  if (window.dialogueManager) {
    window.dialogueManager.show(enrichedDialogue);
  }
}

// ‚úÖ Utilitaire : Formater les items pour affichage dans dialogue
formatDeliveryItemsForDialogue(data) {
  const deliveryData = this.extractDeliveryData(data);
  if (!deliveryData || !deliveryData.items) return "";
  
  let content = "<div class='delivery-items-list'>";
  
  deliveryData.items.forEach(item => {
    const status = item.playerHas >= item.required ? "‚úÖ" : "‚ùå";
    content += `<div class='delivery-item'>`;
    content += `${status} ${item.itemName}: ${item.playerHas}/${item.required}`;
    content += `</div>`;
  });
  
  content += "</div>";
  
  if (deliveryData.canDeliverAll) {
    content += "<div class='delivery-ready'>‚ú® Pr√™t √† livrer !</div>";
  }
  
  return content;
}

  /**
   * Extraire les donn√©es de livraison du message serveur
   * @param {Object} data - Donn√©es brutes du serveur
   * @returns {Object} Donn√©es format√©es pour l'overlay
   */
extractDeliveryData(data) {
  console.log('üîç [QuestSystem] Extraction donn√©es livraison, data re√ßue:', data);
  
  // ‚úÖ Format 1 : Donn√©es directes de livraison (CORRIG√â)
  if (data.deliveryData) {
    console.log('üì¶ [QuestSystem] Format 1 d√©tect√©: deliveryData');
    
    // ‚úÖ CORRECTION : Mapper "deliveries" vers "items" pour l'overlay
    const deliveries = data.deliveryData.deliveries || [];
    const items = deliveries.map(delivery => ({
      itemId: delivery.itemId,
      itemName: delivery.itemName || delivery.itemId,
      required: delivery.requiredAmount || 1,
      playerHas: delivery.playerHasAmount || 0,
      canDeliver: delivery.canDeliver || false,
      // Conserver les donn√©es originales
      questId: delivery.questId,
      questName: delivery.questName,
      stepIndex: delivery.stepIndex,
      stepName: delivery.stepName,
      objectiveId: delivery.objectiveId,
      objectiveDescription: delivery.objectiveDescription
    }));
    
    console.log('‚úÖ [QuestSystem] Items extraits:', items);
    
    return {
      questId: deliveries[0]?.questId || data.questId,
      questName: deliveries[0]?.questName || 'Livraison',
      npcId: data.deliveryData.npcId || data.npcId,
      npcName: data.deliveryData.npcName || data.npcName || 'NPC',
      items: items,
      canDeliverAll: data.deliveryData.allItemsAvailable || false,
      message: data.message || 'Objets requis pour la qu√™te',
      // Conserver les donn√©es originales pour le traitement
      originalDeliveries: deliveries,
      totalDeliveries: data.deliveryData.totalDeliveries || deliveries.length,
      readyDeliveries: data.deliveryData.readyDeliveries || 0
    };
  }
  
  // ‚úÖ Format 2 : Donn√©es dans contextualData
  if (data.contextualData && data.contextualData.deliveryData) {
    console.log('üì¶ [QuestSystem] Format 2 d√©tect√©: contextualData.deliveryData');
    const delivery = data.contextualData.deliveryData;
    
    // M√™me traitement que format 1
    const deliveries = delivery.deliveries || [];
    const items = deliveries.map(d => ({
      itemId: d.itemId,
      itemName: d.itemName || d.itemId,
      required: d.requiredAmount || 1,
      playerHas: d.playerHasAmount || 0,
      canDeliver: d.canDeliver || false,
      questId: d.questId,
      questName: d.questName,
      objectiveId: d.objectiveId
    }));
    
    return {
      questId: deliveries[0]?.questId || data.questId,
      questName: deliveries[0]?.questName || 'Livraison',
      npcId: delivery.npcId || data.npcId,
      npcName: delivery.npcName || data.npcName || 'NPC',
      items: items,
      canDeliverAll: delivery.allItemsAvailable || false,
      message: data.message || 'Objets requis pour la qu√™te',
      originalDeliveries: deliveries,
      totalDeliveries: delivery.totalDeliveries || deliveries.length,
      readyDeliveries: delivery.readyDeliveries || 0
    };
  }
  
  // ‚úÖ Format 3 : Donn√©es dans unifiedInterface
  if (data.unifiedInterface && data.unifiedInterface.deliveryData) {
    console.log('üì¶ [QuestSystem] Format 3 d√©tect√©: unifiedInterface.deliveryData');
    const delivery = data.unifiedInterface.deliveryData;
    
    const deliveries = delivery.deliveries || [];
    const items = deliveries.map(d => ({
      itemId: d.itemId,
      itemName: d.itemName || d.itemId,
      required: d.requiredAmount || 1,
      playerHas: d.playerHasAmount || 0,
      canDeliver: d.canDeliver || false,
      questId: d.questId,
      questName: d.questName,
      objectiveId: d.objectiveId
    }));
    
    return {
      questId: deliveries[0]?.questId || data.questId,
      questName: deliveries[0]?.questName || 'Livraison',
      npcId: delivery.npcId || data.npcId,
      npcName: delivery.npcName || data.npcName || 'NPC',
      items: items,
      canDeliverAll: delivery.allItemsAvailable || false,
      message: data.message || 'Objets requis pour la qu√™te',
      originalDeliveries: deliveries,
      totalDeliveries: delivery.totalDeliveries || deliveries.length,
      readyDeliveries: delivery.readyDeliveries || 0
    };
  }
  
  // ‚úÖ Format 4 : Donn√©es √† la racine (format simple avec items)
  if (data.items && Array.isArray(data.items)) {
    console.log('üì¶ [QuestSystem] Format 4 d√©tect√©: items √† la racine');
    return {
      questId: data.questId,
      questName: data.questName || 'Livraison',
      npcId: data.npcId,
      npcName: data.npcName || 'NPC',
      items: data.items,
      canDeliverAll: data.canDeliverAll || false,
      message: data.message || 'Objets requis pour la qu√™te'
    };
  }
  
  // ‚úÖ Format 5 : Donn√©es √† la racine (format avec deliveries)
  if (data.deliveries && Array.isArray(data.deliveries)) {
    console.log('üì¶ [QuestSystem] Format 5 d√©tect√©: deliveries √† la racine');
    
    const items = data.deliveries.map(d => ({
      itemId: d.itemId,
      itemName: d.itemName || d.itemId,
      required: d.requiredAmount || 1,
      playerHas: d.playerHasAmount || 0,
      canDeliver: d.canDeliver || false,
      questId: d.questId,
      questName: d.questName,
      objectiveId: d.objectiveId
    }));
    
    return {
      questId: data.deliveries[0]?.questId || data.questId,
      questName: data.deliveries[0]?.questName || 'Livraison',
      npcId: data.npcId,
      npcName: data.npcName || 'NPC',
      items: items,
      canDeliverAll: data.allItemsAvailable || false,
      message: data.message || 'Objets requis pour la qu√™te',
      originalDeliveries: data.deliveries,
      totalDeliveries: data.totalDeliveries || data.deliveries.length,
      readyDeliveries: data.readyDeliveries || 0
    };
  }
  
  console.warn('‚ö†Ô∏è [QuestSystem] Format de donn√©es livraison non reconnu:', data);
  return null;
}

  // üõ°Ô∏è M√âTHODE SUPPRIM√âE : handleDeliveryConfirmFromOverlay() 
  // Cette m√©thode √©tait la source du double envoi !
  // Elle envoyait le message questDelivery au serveur, mais l'overlay le fait d√©j√†
  
  /**
   * Handler pour r√©sultat de livraison du serveur
   * @param {Object} data - R√©sultat de livraison
   */
  handleQuestDeliveryResult(data) {
    console.log('üéâ [QuestSystem] === R√âSULTAT LIVRAISON ===');
    console.log('üìä Data:', data);
    
    // üõ°Ô∏è Transmettre le r√©sultat √† l'overlay pour gestion
    if (this.deliveryOverlay && typeof this.deliveryOverlay.handleDeliveryResult === 'function') {
      this.deliveryOverlay.handleDeliveryResult(data);
    } else {
      // üõ°Ô∏è Fallback si overlay pas disponible
      this.handleDeliveryResultFallback(data);
    }
  }
  
  /**
   * üõ°Ô∏è NOUVELLE M√âTHODE : Fallback si overlay indisponible
   */
  handleDeliveryResultFallback(data) {
    this.deliveryState.isDelivering = false;
    
    if (data.success) {
      // ‚úÖ SUCC√àS
      const message = data.message || 'Objets livr√©s avec succ√®s !';
      console.log('‚úÖ [QuestSystem] Livraison r√©ussie');
      
      // ‚úÖ Notification de succ√®s
      this.showMessage(message, 'success', { duration: 4000 });
      
      // ‚úÖ Mettre √† jour les qu√™tes actives
      setTimeout(() => {
        this.requestActiveQuests();
      }, 1000);
      
      // ‚úÖ Animation ic√¥ne
      if (this.icon) {
        this.icon.animateQuestCompleted();
      }
      
      // ‚úÖ Callback custom
      if (this.onDeliveryComplete && typeof this.onDeliveryComplete === 'function') {
        this.onDeliveryComplete(data, this.deliveryState.currentDelivery);
      }
      
      // ‚úÖ Historique
      this.deliveryState.deliveryHistory.push({
        ...this.deliveryState.currentDelivery,
        completedAt: Date.now(),
        result: 'success',
        serverResponse: data
      });
      
    } else {
      // ‚ùå √âCHEC
      const errorMsg = data.message || data.error || 'Impossible de livrer les objets';
      console.error('‚ùå [QuestSystem] Livraison √©chou√©e:', errorMsg);
      
      this.showMessage(errorMsg, 'error', { duration: 5000 });
      
      // ‚úÖ Callback custom
      if (this.onDeliveryFailed && typeof this.onDeliveryFailed === 'function') {
        this.onDeliveryFailed(data, this.deliveryState.currentDelivery);
      }
      
      // ‚úÖ Historique
      this.deliveryState.deliveryHistory.push({
        ...this.deliveryState.currentDelivery,
        failedAt: Date.now(),
        result: 'failed',
        error: errorMsg,
        serverResponse: data
      });
    }
    
    // ‚úÖ Reset √©tat
    this.deliveryState.currentDelivery = null;
  }

  /**
   * Handler pour erreur de livraison
   * @param {Object} data - Donn√©es d'erreur
   */
  handleQuestDeliveryError(data) {
    console.error('‚ùå [QuestSystem] === ERREUR LIVRAISON ===');
    console.error('üìä Error data:', data);
    
    // üõ°Ô∏è Transmettre √† l'overlay si disponible
    if (this.deliveryOverlay && typeof this.deliveryOverlay.handleDeliveryResult === 'function') {
      this.deliveryOverlay.handleDeliveryResult({ success: false, ...data });
    } else {
      // üõ°Ô∏è Fallback
      this.handleDeliveryResultFallback({ success: false, ...data });
    }
  }

  // === üîç UTILITAIRES LIVRAISON ===

  /**
   * V√©rifier si une interaction est une livraison
   * @param {Object} data - Donn√©es d'interaction
   * @returns {boolean}
   */
  isDeliveryInteraction(data) {
    return !!(
      data.deliveryData ||
      data.contextualData?.deliveryData ||
      data.unifiedInterface?.deliveryData ||
      (data.items && Array.isArray(data.items) && data.questId) ||
      data.type === 'questDelivery'
    );
  }

  /**
   * Obtenir l'√©tat actuel de livraison
   * @returns {Object}
   */
  getDeliveryState() {
    return {
      ...this.deliveryState,
      hasActiveDelivery: !!this.deliveryState.currentDelivery,
      isDelivering: this.deliveryState.isDelivering,
      overlayVisible: this.deliveryOverlay?.isOpen() || false
    };
  }

  /**
   * Forcer la fermeture de la livraison
   */
  closeDelivery() {
    console.log('üö™ [QuestSystem] Fermeture forc√©e livraison');
    
    if (this.deliveryOverlay) {
      this.deliveryOverlay.hide();
    }
    
    this.deliveryState.currentDelivery = null;
    this.deliveryState.isDelivering = false;
  }

  // === üéØ M√âTHODES PUBLIQUES POUR DIALOGUEMANAGER (mises √† jour) ===
  
  showQuestDetailsForNpc(npcId, availableQuestIds) {
    if (!this.detailsUI) {
      console.error('‚ùå [QuestSystem] QuestDetailsUI non initialis√©');
      return false;
    }
    
    if (!availableQuestIds || availableQuestIds.length === 0) {
      console.warn('‚ö†Ô∏è [QuestSystem] Aucune qu√™te disponible pour NPC', npcId);
      this.showMessage('Aucune qu√™te disponible pour le moment.', 'info');
      return false;
    }
    
    console.log(`üìã [QuestSystem] Affichage qu√™tes pour NPC ${npcId}:`, availableQuestIds);
    
    if (availableQuestIds.length === 1) {
      this.detailsUI.showSingleQuest(npcId, availableQuestIds[0]);
    } else {
      this.detailsUI.showMultipleQuests(npcId, availableQuestIds);
    }
    
    return true;
  }

  /**
   * ‚úÖ NOUVELLE M√âTHODE : Afficher overlay de livraison pour NPC
   * @param {string} npcId - ID du NPC
   * @param {Object} deliveryData - Donn√©es de livraison
   * @returns {boolean}
   */
  showQuestDeliveryForNpc(npcId, deliveryData) {
    console.log(`üéÅ [QuestSystem] Affichage livraison pour NPC ${npcId}`);
    
    if (!this.deliveryOverlay) {
      console.error('‚ùå [QuestSystem] QuestDeliveryOverlay non disponible');
      return false;
    }
    
    // ‚úÖ Assurer le format correct
    const formattedData = {
      npcId: npcId,
      ...deliveryData
    };
    
    return this.handleQuestDeliveryData({ deliveryData: formattedData });
  }
  
  handleQuestActionFromDialogue(actionData) {
    const npcId = actionData.npcId;
    
    if (!npcId) {
      console.error('‚ùå [QuestSystem] NPC ID manquant dans action quest');
      return false;
    }
    
    console.log(`üéØ [QuestSystem] Action quest re√ßue pour NPC ${npcId}`);
    
    // ‚úÖ NOUVEAU : V√©rifier si c'est une action de livraison
    if (actionData.type === 'questDelivery' || actionData.deliveryData) {
      return this.showQuestDeliveryForNpc(npcId, actionData.deliveryData || actionData);
    }
    
    const questData = this.networkManager.getNpcQuestData(npcId);
    
    if (questData.availableQuestIds.length > 0) {
      return this.showQuestDetailsForNpc(npcId, questData.availableQuestIds);
    } else {
      this.showMessage('Ce PNJ n\'a pas de qu√™tes disponibles pour le moment.', 'info');
      return false;
    }
  }

  // === üé¨ HANDLERS EXISTANTS (inchang√©s) ===
  
  handleQuestAcceptResult(data) {
    console.log('üéØ [QuestSystem] === D√âBUT handleQuestAcceptResult ===');
    console.log('üìä Data re√ßue:', data);
    
    if (data.success) {
      const questName = data.quest?.name || data.questName || data.questId;
      const message = data.message || `Qu√™te "${questName}" accept√©e !`;
      
      console.log('‚úÖ [QuestSystem] Acceptation r√©ussie:', questName);
      
      this.showMessage(message, 'success');
      
      if (data.quest) {
        const existingQuest = this.activeQuests.find(q => q.id === data.quest.id);
        if (!existingQuest) {
          this.activeQuests.push(data.quest);
          this.updateUI();
          console.log('üìù [QuestSystem] Qu√™te ajout√©e aux actives');
        }
      }
      
      if (this.icon) {
        this.icon.animateNewQuest();
      }
      
      this.triggerCallback('onQuestStarted', data.quest);
      
    } else {
      const errorMsg = data.message || data.error || 'Impossible d\'accepter la qu√™te';
      console.error('‚ùå [QuestSystem] Acceptation √©chou√©e:', errorMsg);
      
      this.showMessage(errorMsg, 'error');
      
      if (errorMsg.includes('niveau') || errorMsg.includes('pr√©requis')) {
        this.showMessage('V√©rifiez vos pr√©requis dans le journal des qu√™tes', 'info');
      }
    }
    
    console.log('üéØ [QuestSystem] === FIN handleQuestAcceptResult ===');
  }
  
  handleQuestAcceptFromUI(questId, npcId, questData) {
    console.log(`üéØ [QuestSystem] Acceptation qu√™te depuis UI: ${questId} pour NPC ${npcId}`);
    
    if (!this.networkManager) {
      console.error('‚ùå [QuestSystem] NetworkManager non disponible');
      this.showMessage('Erreur r√©seau - impossible d\'accepter la qu√™te', 'error');
      return false;
    }
    
    try {
      this.networkManager.sendMessage('acceptQuest', {
        questId: questId,
        npcId: npcId,
        timestamp: Date.now()
      });
      
      console.log(`‚úÖ [QuestSystem] Demande acceptation envoy√©e: ${questId}`);
      return true;
      
    } catch (error) {
      console.error('‚ùå [QuestSystem] Erreur acceptation qu√™te:', error);
      this.showMessage('Erreur lors de l\'acceptation de la qu√™te', 'error');
      return false;
    }
  }
  
  handleQuestProgressUpdate(data) {
    console.log('üìà [QuestSystem] Progression qu√™te:', data);
    
    if (Array.isArray(data)) {
      data.forEach(result => {
        if (result.objectiveCompleted && this.ui && this.ui.highlightObjectiveAsCompleted) {
          this.ui.highlightObjectiveAsCompleted({
            questId: result.questId,
            objectiveName: result.objectiveName || result.message,
            ...result
          });
        }
        
        if (result.message) {
          this.showMessage(result.message, 'success');
        }
      });
    }
    
    setTimeout(() => {
      this.requestActiveQuests();
    }, 1500);
  }
  
  handleActiveQuests(data) {
    console.log('üìã [QuestSystem] Qu√™tes actives re√ßues:', data);
    
    this.activeQuests = this.extractQuestArray(data);
    this.updateUI();
    this.triggerCallback('onQuestUpdate', this.activeQuests);
  }
  
  handleAvailableQuests(data) {
    console.log('üìã [QuestSystem] Qu√™tes disponibles re√ßues:', data);
    
    this.availableQuests = this.extractQuestArray(data);
    
    if (this.availableQuests.length > 0) {
      console.log(`üìã [QuestSystem] ${this.availableQuests.length} qu√™tes disponibles stock√©es`);
    }
  }
  
  handleQuestStartResult(data) {
    console.log('üéØ [QuestSystem] R√©sultat d√©marrage qu√™te:', data);
    
    if (data.success && data.quest) {
      const existingQuest = this.activeQuests.find(q => q.id === data.quest.id);
      if (!existingQuest) {
        this.activeQuests.push(data.quest);
        this.updateUI();
      }
      
      this.triggerCallback('onQuestStarted', data.quest);
      this.showMessage(data.message || `Qu√™te "${data.quest.name}" d√©marr√©e !`, 'success');
    } else {
      this.showMessage(data.message || 'Impossible de d√©marrer cette qu√™te', 'error');
    }
  }
  
  handleIntroQuestCompleted(data) {
    console.log('üéâ [QuestSystem] Qu√™te d\'intro termin√©e:', data);
    
    this.showMessage(data.message || 'F√©licitations !', 'success');
    
    if (data.reward) {
      setTimeout(() => {
        this.showMessage(data.reward, 'info');
      }, 2000);
    }
  }

  // === üéÆ ACTIONS UI (inchang√©es) ===
  
  handleUIAction(action, data) {
    console.log(`üéÆ [QuestSystem] Action UI: ${action}`, data);
    
    switch (action) {
      case 'startQuest':
        this.startQuest(data.questId);
        break;
        
      case 'refreshQuests':
        this.requestActiveQuests();
        break;
        
      case 'getAvailableQuests':
        this.requestAvailableQuests();
        break;
        
      default:
        console.warn(`‚ö†Ô∏è [QuestSystem] Action inconnue: ${action}`);
    }
  }
  
  // === üì° REQU√äTES SERVEUR (inchang√©es) ===
  
  requestActiveQuests() {
    if (this.networkManager) {
      console.log('üì§ [QuestSystem] Demande qu√™tes actives');
      this.networkManager.sendMessage('getActiveQuests');
    }
  }
  
  requestAvailableQuests() {
    if (this.networkManager) {
      console.log('üì§ [QuestSystem] Demande qu√™tes disponibles');
      this.networkManager.sendMessage('getAvailableQuests');
    }
  }
  
  startQuest(questId) {
    if (this.networkManager) {
      console.log(`üì§ [QuestSystem] D√©marrage qu√™te: ${questId}`);
      this.networkManager.sendMessage('startQuest', { questId });
    }
  }

  // === üé≠ D√âTECTION INTERACTION NPC (mise √† jour) ===
  
  handleNpcInteraction(data) {
    console.log('üé≠ [QuestSystem] handleNpcInteraction appel√©:', data);
    
    // ‚úÖ NOUVEAU : Priorit√© aux livraison
    if (this.isDeliveryInteraction(data)) {
      console.log('üéÅ [QuestSystem] Interaction de livraison d√©tect√©e');
      this.handleQuestDeliveryData(data);
      return { handled: true, reason: 'quest_delivery' };
    }
    
    if (this.isQuestInteraction(data)) {
      console.log('üéØ [QuestSystem] Donn√©es qu√™te d√©tect√©es - disponibles pour DialogueManager');
    }
    
    return { handled: false, reason: 'delegated_to_dialogue_manager' };
  }
  
  isQuestInteraction(data) {
    return !!(
      data.type === 'questGiver' ||
      data.type === 'unifiedInterface' ||
      data.availableQuests ||
      data.questRewards ||
      data.contextualData?.hasQuests ||
      data.capabilities?.includes('quest') ||
      (data.message && data.message.toLowerCase().includes('qu√™te')) ||
      this.isDeliveryInteraction(data)
    );
  }

  // === üîß UTILITAIRES (inchang√©s) ===
  
  extractQuestArray(data) {
    if (Array.isArray(data)) return data.filter(q => q?.id);
    if (data?.quests) return data.quests.filter(q => q?.id);
    if (data?.questList) return data.questList.filter(q => q?.id);
    return [];
  }
  
  updateQuestProgress(questId, progressData) {
    const quest = this.activeQuests.find(q => q.id === questId);
    if (quest && progressData) {
      Object.assign(quest, progressData);
    }
  }
  
  updateUI() {
    console.log('üîÑ [QuestSystem] updateUI() appel√©');
    
    if (this.ui) {
      this.ui.updateQuestData(this.activeQuests, 'active');
      
      if (typeof this.ui.updateTrackerIntelligent === 'function') {
        this.ui.updateTrackerIntelligent();
      } else {
        console.warn('‚ö†Ô∏è [QuestSystem] updateTrackerIntelligent non disponible');
      }
    }
    
    if (this.icon && typeof this.icon.updateStats === 'function') {
      this.icon.updateStats({
        totalActive: this.activeQuests.length,
        newQuests: this.activeQuests.filter(q => q.isNew).length,
        readyToComplete: this.activeQuests.filter(q => q.status === 'ready').length
      });
    }
    
    console.log('‚úÖ [QuestSystem] updateUI() termin√©');
  }
  
  triggerCallback(callbackName, data) {
    const callback = this[callbackName];
    if (typeof callback === 'function') {
      try {
        callback(data);
      } catch (error) {
        console.error(`‚ùå [QuestSystem] Erreur callback ${callbackName}:`, error);
      }
    }
  }
  
  showMessage(message, type = 'info', options = {}) {
    if (typeof window.showGameNotification === 'function') {
      window.showGameNotification(message, type, { duration: 3000, ...options });
    } else {
      console.log(`üì¢ [QuestSystem] ${type.toUpperCase()}: ${message}`);
    }
  }

  // === üìä API PUBLIQUE (mise √† jour) ===
  
  getActiveQuests() {
    return [...this.activeQuests];
  }
  
  getAvailableQuests() {
    return [...this.availableQuests];
  }
  
  getCompletedQuests() {
    return [...this.completedQuests];
  }
  
  hasActiveQuests() {
    return this.activeQuests.length > 0;
  }
  
  isReady() {
    return this.ready;
  }

  /**
   * ‚úÖ NOUVELLE M√âTHODE : V√©rifier si une livraison est en cours
   */
  hasActiveDelivery() {
    return !!(this.deliveryState.currentDelivery && this.deliveryState.isDelivering);
  }

  /**
   * ‚úÖ NOUVELLE M√âTHODE : Obtenir historique des livraisons
   */
  getDeliveryHistory() {
    return [...this.deliveryState.deliveryHistory];
  }

  // === üéõÔ∏è CONTR√îLES UI (mise √† jour) ===
  
  show() {
    if (this.ui) this.ui.show();
    if (this.icon) this.icon.show();
  }
  
  hide() {
    if (this.ui) this.ui.hide();
    if (this.icon) this.icon.hide();
    if (this.ui) this.ui.hideTracker();
    
    if (this.detailsUI && this.detailsUI.isVisible) {
      this.detailsUI.hide();
    }
    
    // ‚úÖ NOUVEAU : Fermer aussi l'overlay de livraison
    if (this.deliveryOverlay && this.deliveryOverlay.isOpen()) {
      this.deliveryOverlay.hide();
    }
  }
  
  toggle() {
    if (this.ui) {
      this.ui.toggle();
    }
  }
  
  setEnabled(enabled) {
    if (this.ui) this.ui.setEnabled(enabled);
    if (this.icon) this.icon.setEnabled(enabled);
    if (this.detailsUI) this.detailsUI.setEnabled(enabled);
    // ‚úÖ NOUVEAU : Contr√¥ler aussi l'overlay de livraison
    if (this.deliveryOverlay) {
      // Note: QuestDeliveryOverlay n'a pas de setEnabled, on peut l'ajouter si n√©cessaire
    }
  }

  // === üîó INT√âGRATION UIMANAGER (inchang√©e) ===
  
  connectUIManager(uiManager) {
    console.log('üîó [QuestSystem] Connexion UIManager...');
    
    if (!uiManager || !uiManager.registerIconPosition) {
      console.error('‚ùå [QuestSystem] UIManager invalide');
      return false;
    }
    
    if (!this.icon || !this.icon.iconElement) {
      console.error('‚ùå [QuestSystem] Ic√¥ne non disponible');
      return false;
    }
    
    try {
      uiManager.registerIconPosition('quest', this.icon.iconElement, {
        anchor: 'bottom-right',
        order: 1,
        spacing: 10,
        group: 'ui-icons'
      });
      
      this.icon.iconElement.setAttribute('data-positioned-by', 'uimanager');
      
      console.log('‚úÖ [QuestSystem] UIManager connect√© - ic√¥ne enregistr√©e');
      return true;
      
    } catch (error) {
      console.error('‚ùå [QuestSystem] Erreur connexion UIManager:', error);
      return false;
    }
  }

  // === üßπ NETTOYAGE (mise √† jour) ===
  
  destroy() {
    console.log('üßπ [QuestSystem] Destruction avec QuestDeliveryOverlay...');
    
    if (this.ui) {
      this.ui.destroy();
      this.ui = null;
    }
    
    if (this.icon) {
      this.icon.destroy();
      this.icon = null;
    }
    
    if (this.detailsUI) {
      this.detailsUI.destroy();
      this.detailsUI = null;
    }
    
    // ‚úÖ NOUVEAU : D√©truire QuestDeliveryOverlay
    if (this.deliveryOverlay) {
      this.deliveryOverlay.destroy();
      this.deliveryOverlay = null;
    }
    
    this.tracker = null;
    this.networkManager = null;
    this.gameRoom = null;
    this.ready = false;
    
    this.activeQuests = [];
    this.availableQuests = [];
    this.completedQuests = [];
    
    // ‚úÖ NOUVEAU : Reset √©tat livraison
    this.deliveryState = {
      currentDelivery: null,
      isDelivering: false,
      lastDeliveryTime: 0,
      deliveryHistory: [],
      preventDoubleDelivery: true,
      deliveryCooldown: 3000,
      lastDeliveryNonce: null
    };
    
    console.log('‚úÖ [QuestSystem] D√©truit avec syst√®me de livraison');
  }
}

// === FACTORY FUNCTION MISE √Ä JOUR ===

export async function createQuestSystem(gameRoom, networkManager) {
  try {
    console.log('üè≠ [QuestFactory] Cr√©ation QuestSystem avec QuestDeliveryOverlay...');
    
    const questSystem = new QuestSystem(gameRoom, networkManager);
    await questSystem.init();
    
    // Exposer globalement
    window.questSystem = questSystem;
    window.questSystemGlobal = questSystem;
    
    // Fonctions de compatibilit√©
    window.toggleQuest = () => questSystem.toggle();
    window.openQuest = () => questSystem.show();
    window.closeQuest = () => questSystem.hide();
    
    // Fonctions de gestion livraison
    window.showQuestDelivery = (npcId, deliveryData) => questSystem.showQuestDeliveryForNpc(npcId, deliveryData);
    window.closeQuestDelivery = () => questSystem.closeDelivery();
    window.getDeliveryState = () => questSystem.getDeliveryState();
    
    // Fonctions de test existantes
    window.testQuestDetailsUI = (npcId = 2, questIds = ['test_quest_1']) => {
      console.log('üß™ Test QuestDetailsUI...');
      return questSystem.showQuestDetailsForNpc(npcId, questIds);
    };
    
    window.testQuestAction = (npcId = 2) => {
      console.log('üß™ Test action quest DialogueManager...');
      return questSystem.handleQuestActionFromDialogue({ npcId });
    };

    // ‚úÖ NOUVELLES FONCTIONS DE TEST : Livraison
    window.testQuestDeliverySystem = (npcId = 9001) => {
      console.log('üß™ Test syst√®me de livraison complet...');
      
      const testDeliveryData = {
        questId: 'test_delivery_quest',
        npcId: npcId,
        items: [
          {
            itemId: 'gardening_gloves',
            itemName: 'Gants de Jardinage',
            required: 1,
            playerHas: 1
          },
          {
            itemId: 'berry_oran', 
            itemName: 'Baie Oran',
            required: 5,
            playerHas: 3
          }
        ],
        canDeliverAll: false,
        message: 'Apportez-moi ces objets pour terminer la qu√™te'
      };
      
      return questSystem.showQuestDeliveryForNpc(npcId, testDeliveryData);
    };

    window.testQuestDeliverySuccess = () => {
      console.log('üß™ Test r√©sultat livraison succ√®s...');
      questSystem.handleQuestDeliveryResult({
        success: true,
        message: 'Tous les objets ont √©t√© livr√©s avec succ√®s !',
        questId: 'test_delivery_quest',
        experience: 250,
        gold: 100
      });
    };

    window.testQuestDeliveryFailure = () => {
      console.log('üß™ Test r√©sultat livraison √©chec...');
      questSystem.handleQuestDeliveryResult({
        success: false,
        message: 'Vous n\'avez pas tous les objets requis',
        error: 'INSUFFICIENT_ITEMS'
      });
    };

    window.debugQuestDelivery = () => {
      console.log('üîç Debug √©tat livraison:', questSystem.getDeliveryState());
      console.log('üîç Historique livraisons:', questSystem.getDeliveryHistory());
      console.log('üîç Overlay disponible:', !!questSystem.deliveryOverlay);
    };
    
    console.log('‚úÖ [QuestFactory] QuestSystem cr√©√© avec livraison SANS double envoi');
    console.log('üéØ Messages unifi√©s: acceptQuest ‚Üí questAcceptResult');
    console.log('üéÅ Syst√®me livraison: questDelivery ‚Üî questDeliveryResult (SANS DOUBLE ENVOI)');
    console.log('üß™ Tests disponibles:');
    console.log('   - window.testQuestDeliverySystem() - Test overlay livraison');
    console.log('   - window.testQuestDeliverySuccess() - Test succ√®s livraison');  
    console.log('   - window.testQuestDeliveryFailure() - Test √©chec livraison');
    console.log('   - window.debugQuestDelivery() - Debug √©tat livraison');
    console.log('   - window.showQuestDelivery(npcId, data) - Afficher livraison');
    console.log('   - window.closeQuestDelivery() - Fermer livraison');
    
    return questSystem;
    
  } catch (error) {
    console.error('‚ùå [QuestFactory] Erreur cr√©ation:', error);
    throw error;
  }
}

export default QuestSystem;
