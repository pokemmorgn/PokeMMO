// Quest/QuestManager.js - VERSION ULTRA-ROBUSTE COMPL√àTE
// üéØ CORRECTIONS: Setup handlers imm√©diat + NPC matching + Fallbacks + Auto-r√©paration

export class QuestManager {
  constructor(gameRoom) {
    this.gameRoom = gameRoom;
    
    // === DONN√âES LOCALES ===
    this.activeQuests = [];
    this.completedQuests = [];
    this.availableQuests = [];
    
    // === STATISTIQUES ===
    this.questStats = {
      totalActive: 0,
      totalCompleted: 0,
      newQuests: 0,
      readyToComplete: 0
    };
    
    // === CALLBACKS ===
    this.onQuestUpdate = null;
    this.onQuestStarted = null;
    this.onQuestCompleted = null;
    this.onQuestProgress = null;
    this.onStatsUpdate = null;
    
    // === √âTAT SYST√àME ===
    this.initialized = false;
    this.questUI = null;
    this.lastDataRequest = 0;
    this.requestCooldown = 1000;
    
    // === ROBUSTESSE ===
    this.requestQueue = [];
    this.processingQueue = false;
    this.fallbackEnabled = true;
    this.maxRetries = 3;
    this.retryDelay = 1000;
    
    // === NPC INTERACTION CACHE ===
    this.pendingNpcInteraction = null;
    this.npcInteractionTimeout = 8000;
    this.interactionHistory = new Map();
    
    // === D√âDUPLICATION ===
    this.lastNotificationTime = new Map();
    this.notificationCooldown = 2000;
    
    // ‚úÖ CORRECTION CRITIQUE 1: Setup handlers IMM√âDIATEMENT dans constructor
    if (this.gameRoom && typeof this.gameRoom.onMessage === 'function') {
      console.log('üì° [QuestManager] Setup handlers imm√©diat dans constructor...');
      this.setupServerListeners();
    } else {
      console.warn('‚ö†Ô∏è [QuestManager] GameRoom invalide, handlers non configur√©s');
    }
    
    console.log('üìñ [QuestManager] Instance cr√©√©e - Version ultra-robuste');
  }
  
  // === üöÄ INITIALISATION ROBUSTE ===
  
  async init() {
    try {
      console.log('üöÄ [QuestManager] Initialisation robuste...');
      
      if (!this.gameRoom) {
        throw new Error('GameRoom requis pour QuestManager');
      }
      
      this.validateHandlersOrRetry();
      this.verifyConnections();
      this.scheduleInitialDataRequest();
      
      this.initialized = true;
      console.log('‚úÖ [QuestManager] Initialis√© avec succ√®s');
      
      return this;
      
    } catch (error) {
      console.error('‚ùå [QuestManager] Erreur initialisation:', error);
      await this.initializeFallbackMode();
      throw error;
    }
  }
  
  validateHandlersOrRetry() {
    const requiredHandlers = [
      'availableQuestsList', 'activeQuestsList', 'questStartResult',
      'questGranted', 'questProgressUpdate', 'questCompleted'
    ];
    
    const missingHandlers = requiredHandlers.filter(handler => 
      !this.gameRoom._messageHandlers?.[handler]
    );
    
    if (missingHandlers.length > 0) {
      console.warn('‚ö†Ô∏è [QuestManager] Handlers manquants:', missingHandlers);
      console.log('üîÑ [QuestManager] Re-setup handlers...');
      this.setupServerListeners();
      
      const stillMissing = requiredHandlers.filter(handler => 
        !this.gameRoom._messageHandlers?.[handler]
      );
      
      if (stillMissing.length > 0) {
        console.error('‚ùå [QuestManager] Handlers toujours manquants:', stillMissing);
      } else {
        console.log('‚úÖ [QuestManager] Tous les handlers maintenant enregistr√©s');
      }
    } else {
      console.log('‚úÖ [QuestManager] Tous les handlers pr√©sents');
    }
  }
  
  async initializeFallbackMode() {
    console.log('üîÑ [QuestManager] Mode fallback activ√©...');
    this.activeQuests = this.generateFallbackQuests();
    this.calculateStats();
    this.triggerCallbacks();
    this.initialized = true;
  }
  
  generateFallbackQuests() {
    return [
      {
        id: 'fallback_welcome',
        name: 'Bienvenue dans l\'aventure',
        description: 'Explorez le monde et d√©couvrez vos premiers Pok√©mon.',
        category: 'main',
        currentStepIndex: 0,
        steps: [
          {
            id: 'welcome_step',
            name: 'Explorer les environs',
            description: 'Explorez la zone de d√©part',
            objectives: [
              {
                id: 'explore_obj',
                description: 'Explorez les environs',
                completed: false,
                requiredAmount: 1,
                currentAmount: 0
              }
            ]
          }
        ]
      }
    ];
  }
  
  scheduleInitialDataRequest() {
    setTimeout(() => this.requestInitialData(), 500);
    setTimeout(() => {
      if (this.activeQuests.length === 0) {
        console.log('üîÑ [QuestManager] Pas de qu√™tes re√ßues, retry...');
        this.requestInitialData();
      }
    }, 3000);
  }
  
  // === üì° COMMUNICATION SERVEUR ROBUSTE ===
  
  setupServerListeners() {
    if (!this.gameRoom || typeof this.gameRoom.onMessage !== 'function') {
      console.error('‚ùå [QuestManager] GameRoom invalide pour setup handlers');
      return;
    }
    
    console.log('üì° [QuestManager] Configuration listeners serveur robuste...');
    
    try {
      this.gameRoom.onMessage("activeQuestsList", (data) => {
        this.safeHandleMessage('activeQuestsList', data, this.handleActiveQuestsReceived);
      });
      
      this.gameRoom.onMessage("availableQuestsList", (data) => {
        this.safeHandleMessage('availableQuestsList', data, this.handleAvailableQuestsReceived);
      });
      
      this.gameRoom.onMessage("questStartResult", (data) => {
        this.safeHandleMessage('questStartResult', data, this.handleQuestStartResult);
      });
      
      this.gameRoom.onMessage("questGranted", (data) => {
        this.safeHandleMessage('questGranted', data, this.handleQuestGranted);
      });
      
      this.gameRoom.onMessage("questProgressUpdate", (data) => {
        this.safeHandleMessage('questProgressUpdate', data, this.handleQuestProgressUpdate);
      });
      
      this.gameRoom.onMessage("questCompleted", (data) => {
        this.safeHandleMessage('questCompleted', data, this.handleQuestCompleted);
      });
      
      this.gameRoom.onMessage("questStatuses", (data) => {
        this.safeHandleMessage('questStatuses', data, this.handleQuestStatuses);
      });
      
      this.gameRoom.onMessage("triggerIntroSequence", (data) => {
        this.safeHandleMessage('triggerIntroSequence', data, this.handleIntroSequence);
      });
      
      this.gameRoom.onMessage("introQuestCompleted", (data) => {
        this.safeHandleMessage('introQuestCompleted', data, this.handleIntroQuestCompleted);
      });
      
      console.log('‚úÖ [QuestManager] Listeners serveur configur√©s avec s√©curit√©');
      
    } catch (error) {
      console.error('‚ùå [QuestManager] Erreur setup listeners:', error);
    }
  }
  
  safeHandleMessage(type, data, handler) {
    try {
      console.log(`üì® [QuestManager] Message ${type} re√ßu:`, data);
      handler.call(this, data);
    } catch (error) {
      console.error(`‚ùå [QuestManager] Erreur handler ${type}:`, error);
      
      if (type === 'activeQuestsList' && this.fallbackEnabled) {
        this.handleActiveQuestsReceived([]);
      }
    }
  }
  
  verifyConnections() {
    console.log('üîç [QuestManager] V√©rification connexions...');
    
    if (!this.gameRoom) {
      throw new Error('GameRoom manquant');
    }
    
    if (typeof this.gameRoom.send !== 'function') {
      throw new Error('gameRoom.send non disponible');
    }
    
    console.log('‚úÖ [QuestManager] Connexions v√©rifi√©es');
  }
  
  // === üì§ REQU√äTES SERVEUR AVEC QUEUE ===
  
  async requestWithQueue(messageType, data = null) {
    return new Promise((resolve, reject) => {
      const request = {
        messageType,
        data,
        resolve,
        reject,
        timestamp: Date.now(),
        retries: 0
      };
      
      this.requestQueue.push(request);
      this.processRequestQueue();
    });
  }
  
  async processRequestQueue() {
    if (this.processingQueue || this.requestQueue.length === 0) {
      return;
    }
    
    this.processingQueue = true;
    
    while (this.requestQueue.length > 0) {
      const request = this.requestQueue.shift();
      
      try {
        await this.processRequest(request);
        request.resolve(true);
      } catch (error) {
        if (request.retries < this.maxRetries) {
          request.retries++;
          this.requestQueue.unshift(request);
          await new Promise(resolve => setTimeout(resolve, this.retryDelay));
        } else {
          request.reject(error);
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    this.processingQueue = false;
  }
  
  async processRequest(request) {
    if (!this.canSendRequest()) {
      throw new Error('Cooldown actif');
    }
    
    console.log(`üì§ [QuestManager] Envoi requ√™te: ${request.messageType}`);
    
    this.gameRoom.send(request.messageType, request.data);
    this.lastDataRequest = Date.now();
  }
  
  canSendRequest() {
    const now = Date.now();
    return (now - this.lastDataRequest) > this.requestCooldown;
  }
  
  requestInitialData() {
    console.log('üì§ [QuestManager] Demande donn√©es initiales robuste...');
    
    this.requestWithQueue("getActiveQuests")
      .catch(error => console.warn('‚ö†Ô∏è Erreur getActiveQuests:', error));
    
    this.requestWithQueue("clientIntroReady")
      .catch(error => console.warn('‚ö†Ô∏è Erreur clientIntroReady:', error));
  }
  
  requestQuestData() {
    this.requestWithQueue("getActiveQuests")
      .catch(error => console.warn('‚ö†Ô∏è Erreur requestQuestData:', error));
  }
  
  requestAvailableQuests() {
    this.requestWithQueue("getAvailableQuests")
      .catch(error => console.warn('‚ö†Ô∏è Erreur getAvailableQuests:', error));
  }
  
  startQuest(questId) {
    this.requestWithQueue("startQuest", { questId })
      .catch(error => console.warn('‚ö†Ô∏è Erreur startQuest:', error));
  }
  
  // === üìä HANDLERS DONN√âES ROBUSTES ===
  
  handleActiveQuestsReceived(data) {
    try {
      console.log('üìä [QuestManager] Traitement qu√™tes actives robuste:', data);
      
      let questArray = [];
      
      if (data && Array.isArray(data.quests)) {
        questArray = data.quests;
      } else if (Array.isArray(data)) {
        questArray = data;
      } else if (data && typeof data === 'object') {
        questArray = [data];
      }
      
      this.activeQuests = questArray
        .map(quest => this.normalizeQuestData(quest))
        .filter(quest => quest && (quest.id || quest._id));
      
      console.log(`üìä [QuestManager] ${this.activeQuests.length} qu√™tes actives pars√©es`);
      
      this.calculateStats();
      this.triggerCallbacks();
      
    } catch (error) {
      console.error('‚ùå [QuestManager] Erreur handleActiveQuests:', error);
      
      if (this.activeQuests.length === 0 && this.fallbackEnabled) {
        this.activeQuests = this.generateFallbackQuests();
        this.calculateStats();
        this.triggerCallbacks();
      }
    }
  }
  
  handleAvailableQuestsReceived(data) {
    try {
      console.log('üìä [QuestManager] Traitement qu√™tes disponibles:', data);
      
      let questArray = [];
      if (data && Array.isArray(data.quests)) {
        questArray = data.quests;
      } else if (Array.isArray(data)) {
        questArray = data;
      }
      
      this.availableQuests = questArray
        .map(quest => this.normalizeQuestData(quest))
        .filter(quest => quest && (quest.id || quest._id));
      
      console.log(`üìä [QuestManager] ${this.availableQuests.length} qu√™tes disponibles pars√©es`);
      
      this.processPendingNpcInteraction();
      
    } catch (error) {
      console.error('‚ùå [QuestManager] Erreur handleAvailableQuests:', error);
      this.processPendingNpcInteraction();
    }
  }
  
  handleQuestStartResult(data) {
    console.log('üéØ [QuestManager] R√©sultat d√©marrage qu√™te:', data);
    
    if (data.success) {
      this.showNotification(`Qu√™te "${data.quest?.name || 'Inconnue'}" accept√©e !`, 'success');
      this.triggerCallback('onQuestStarted', data.quest);
      setTimeout(() => this.requestQuestData(), 500);
    } else {
      this.showNotification(data.message || "Impossible de d√©marrer cette qu√™te", 'error');
    }
  }
  
  handleQuestGranted(data) {
    console.log('üéÅ [QuestManager] Qu√™te accord√©e:', data);
    
    this.showNotification(`Nouvelle qu√™te : ${data.questName || 'Inconnue'} !`, 'success');
    
    this.triggerCallback('onQuestStarted', {
      id: data.questId,
      name: data.questName,
      granted: true
    });
    
    setTimeout(() => this.requestQuestData(), 500);
  }
  
  handleQuestProgressUpdate(data) {
    console.log('üìà [QuestManager] Progression qu√™te:', data);
    
    if (!Array.isArray(data)) {
      console.warn('‚ö†Ô∏è [QuestManager] Format progression invalide:', data);
      return;
    }
    
    data.forEach(result => {
      if (result.questCompleted) {
        this.triggerCallback('onQuestCompleted', result);
      } else {
        this.triggerCallback('onQuestProgress', result);
      }
      
      if (result.objectiveCompleted) {
        this.showNotification(`Objectif compl√©t√© : ${result.objectiveName}`, 'success');
      } else if (result.stepCompleted) {
        this.showNotification(`√âtape termin√©e : ${result.stepName}`, 'success');
      } else if (result.questCompleted) {
        this.showNotification(`Qu√™te termin√©e : ${result.questName} !`, 'success');
      }
    });
    
    setTimeout(() => this.requestQuestData(), 500);
  }
  
  handleQuestCompleted(data) {
    console.log('üéâ [QuestManager] Qu√™te termin√©e:', data);
    
    this.showNotification(data.message || "F√©licitations ! Qu√™te termin√©e !", 'success');
    this.triggerCallback('onQuestCompleted', data);
    setTimeout(() => this.requestQuestData(), 500);
  }
  
  handleQuestStatuses(data) {
    console.log('üìä [QuestManager] Statuts qu√™tes NPCs:', data);
    
    if (data.questStatuses && Array.isArray(data.questStatuses)) {
      this.updateNpcQuestStatuses(data.questStatuses);
    }
  }
  
  handleIntroSequence(data) {
    console.log('üé¨ [QuestManager] S√©quence intro d√©clench√©e:', data);
    
    if (data.shouldStartIntro) {
      this.triggerIntroSequence(data);
    }
  }
  
  handleIntroQuestCompleted(data) {
    console.log('üéì [QuestManager] Qu√™te intro termin√©e:', data);
    
    this.showNotification(data.message || "F√©licitations ! Vous avez termin√© l'introduction !", 'success');
  }
  
  // === üó£Ô∏è INTERACTION NPC ULTRA-ROBUSTE ===
  
  handleNpcInteraction(data) {
    console.log('üó£Ô∏è [QuestManager] === INTERACTION NPC ROBUSTE ===');
    console.log('üìä [QuestManager] Data NPC:', data);
    
    try {
      const npcId = this.extractNpcId(data);
      if (npcId) {
        this.interactionHistory.set(npcId, {
          data: data,
          timestamp: Date.now(),
          attempts: (this.interactionHistory.get(npcId)?.attempts || 0) + 1
        });
      }
      
      if (data && typeof data === 'object' && data.type) {
        return this.processNpcInteractionData(data);
      }
      
      if (data && (data.npcId || data.id || data.name)) {
        return this.processNpcDirectInteraction(data);
      }
      
      console.log('‚ÑπÔ∏è [QuestManager] Aucune donn√©e NPC sp√©cifique');
      return 'NO_QUEST';
      
    } catch (error) {
      console.error('‚ùå [QuestManager] Erreur handleNpcInteraction:', error);
      return false;
    }
  }
  
  extractNpcId(data) {
    return data?.npcId || data?.id || data?.targetId || 
           (data?.name ? `name_${data.name}` : null);
  }
  
  processNpcInteractionData(data) {
    console.log('üìä [QuestManager] Traitement interaction typ√©e:', data.type);
    
    switch (data.type) {
      case 'questGiver':
        return this.handleQuestGiverInteraction(data);
      case 'questComplete':
        return this.handleQuestCompleteInteraction(data);
      case 'questProgress':
        return this.handleQuestProgressInteraction(data);
      default:
        console.log(`‚ÑπÔ∏è [QuestManager] Type non-quest: ${data.type}`);
        return 'NO_QUEST';
    }
  }
  
  processNpcDirectInteraction(npcData) {
    console.log('üéØ [QuestManager] Traitement NPC direct:', npcData);
    
    const activeNpcQuests = this.findActiveQuestsForNpc(npcData);
    
    if (activeNpcQuests.length > 0) {
      console.log(`‚úÖ [QuestManager] ${activeNpcQuests.length} qu√™tes actives trouv√©es`);
      return this.showActiveQuestDialog(npcData, activeNpcQuests);
    }
    
    const availableNpcQuests = this.findAvailableQuestsForNpc(npcData);
    
    if (availableNpcQuests.length > 0) {
      console.log(`‚úÖ [QuestManager] ${availableNpcQuests.length} qu√™tes disponibles trouv√©es`);
      return this.showQuestSelectionDialog(npcData.name || 'NPC', availableNpcQuests);
    }
    
    console.log('üì§ [QuestManager] Demande qu√™tes serveur pour NPC...');
    this.requestAvailableQuestsForNpc(npcData);
    return true;
  }
  
  handleQuestGiverInteraction(data) {
    console.log('üéÅ [QuestManager] Quest Giver d√©tect√©:', data);
    
    if (data.availableQuests && Array.isArray(data.availableQuests) && data.availableQuests.length > 0) {
      return this.showQuestSelectionDialog(data.npcName, data.availableQuests);
    } else {
      console.log('üì§ [QuestManager] Demande qu√™tes disponibles...');
      this.requestAvailableQuestsForNpc(data);
      return true;
    }
  }
  
  handleQuestCompleteInteraction(data) {
    console.log('‚úÖ [QuestManager] Quest Complete d√©tect√©e:', data);
    
    if (data.lines && data.lines.length > 0) {
      this.showQuestCompletionDialog(data);
    }
    
    return true;
  }
  
  handleQuestProgressInteraction(data) {
    console.log('üìà [QuestManager] Quest Progress d√©tect√©e:', data);
    
    if (data.questProgress && Array.isArray(data.questProgress)) {
      this.handleQuestProgressUpdate(data.questProgress);
    }
    
    return true;
  }
  
  findActiveQuestsForNpc(npcData) {
    const npcId = this.extractNpcId(npcData);
    const npcName = npcData.npcName || npcData.name;
    
    console.log('üîç [QuestManager] Recherche qu√™tes actives pour:', { npcId, npcName });
    
    return this.activeQuests.filter(quest => {
      const matches = this.questInvolvesNpc(quest, npcId, npcName);
      console.log(`${matches ? '‚úÖ' : '‚ùå'} [QuestManager] Quest "${quest.name}" ${matches ? 'compatible' : 'incompatible'} avec NPC`);
      return matches;
    });
  }
  
  findAvailableQuestsForNpc(npcData) {
    const npcId = this.extractNpcId(npcData);
    const npcName = npcData.npcName || npcData.name;
    
    console.log('üîç [QuestManager] Recherche qu√™tes disponibles pour:', { npcId, npcName });
    
    return this.availableQuests.filter(quest => {
      const matches = this.questMatchesNpc(quest, npcData);
      console.log(`${matches ? '‚úÖ' : '‚ùå'} [QuestManager] Quest "${quest.name}" ${matches ? 'compatible' : 'incompatible'} avec NPC`);
      return matches;
    });
  }
  
  questMatchesNpc(quest, npcData) {
    if (!quest || !npcData) return false;
    
    const npcId = this.extractNpcId(npcData);
    const npcName = npcData.npcName || npcData.name;
    
    console.log('üîç [QuestManager] Test matching:', {
      questName: quest.name,
      questId: quest.id,
      npcId: npcId,
      npcName: npcName
    });
    
    // V√©rification ID direct
    if (npcId && (quest.startNpcId == npcId || quest.endNpcId == npcId || quest.npcId == npcId)) {
      console.log('‚úÖ [QuestManager] Match trouv√©: ID direct');
      return true;
    }
    
    // V√©rification nom (case insensitive)
    if (npcName && quest.startNpcName && 
        quest.startNpcName.toLowerCase() === npcName.toLowerCase()) {
      console.log('‚úÖ [QuestManager] Match trouv√©: startNpcName');
      return true;
    }
    
    if (npcName && quest.endNpcName && 
        quest.endNpcName.toLowerCase() === npcName.toLowerCase()) {
      console.log('‚úÖ [QuestManager] Match trouv√©: endNpcName');
      return true;
    }
    
    // V√©rification dans les √©tapes
    if (quest.steps && Array.isArray(quest.steps)) {
      for (const step of quest.steps) {
        if (step.objectives && Array.isArray(step.objectives)) {
          for (const obj of step.objectives) {
            if ((obj.targetNpcId && obj.targetNpcId == npcId) ||
                (obj.npcId && obj.npcId == npcId) ||
                (obj.target && obj.target == npcId) ||
                (npcName && obj.targetNpc && obj.targetNpc.toLowerCase() === npcName.toLowerCase()) ||
                (npcName && obj.npc && obj.npc.toLowerCase() === npcName.toLowerCase())) {
              console.log('‚úÖ [QuestManager] Match trouv√©: dans objectif step');
              return true;
            }
          }
        }
      }
    }
    
    // Fallback: si pas de restrictions NPC sp√©cifiques, autoriser
    const hasNpcRestrictions = !!(
      quest.startNpcId || quest.endNpcId || quest.npcId ||
      quest.startNpcName || quest.endNpcName ||
      (quest.steps && quest.steps.some(step => 
        step.objectives && step.objectives.some(obj => 
          obj.targetNpcId || obj.npcId || obj.targetNpc || obj.npc
        )
      ))
    );
    
    if (!hasNpcRestrictions) {
      console.log('‚úÖ [QuestManager] Match trouv√©: qu√™te g√©n√©rique');
      return true;
    }
    
    console.log('‚ùå [QuestManager] Aucun match trouv√©');
    return false;
  }
  
  questInvolvesNpc(quest, npcId, npcName) {
    if (!quest || !quest.steps) return false;
    
    if (quest.startNpcId === npcId || quest.endNpcId === npcId) {
      return true;
    }
    
    return quest.steps.some(step => {
      if (step.objectives) {
        return step.objectives.some(obj => {
          return (
            obj.targetNpcId === npcId ||
            obj.targetNpc === npcName ||
            obj.npcId === npcId ||
            obj.npc === npcName ||
            obj.target === npcId?.toString()
          );
        });
      }
      return false;
    });
  }
  
  requestAvailableQuestsForNpc(npcData) {
    console.log('üì§ [QuestManager] Demande qu√™tes pour NPC:', npcData);
    
    this.pendingNpcInteraction = {
      npcData,
      timestamp: Date.now()
    };
    
    setTimeout(() => {
      if (this.pendingNpcInteraction && 
          this.pendingNpcInteraction.timestamp === this.pendingNpcInteraction.timestamp) {
        console.log('‚è∞ [QuestManager] Timeout interaction NPC');
        this.pendingNpcInteraction = null;
      }
    }, this.npcInteractionTimeout);
    
    this.requestAvailableQuests();
  }
  
  processPendingNpcInteraction() {
    if (!this.pendingNpcInteraction) {
      console.log('‚ÑπÔ∏è [QuestManager] Aucune interaction NPC en attente');
      return;
    }
    
    console.log('üîÑ [QuestManager] Traitement interaction NPC en attente');
    console.log('üìä [QuestManager] Qu√™tes disponibles totales:', this.availableQuests.length);
    
    const { npcData } = this.pendingNpcInteraction;
    this.pendingNpcInteraction = null;
    
    console.log('üéØ [QuestManager] NPC Data pour matching:', npcData);
    
    const npcQuests = this.availableQuests.filter((quest, index) => {
      console.log(`üîç [QuestManager] Test quest ${index + 1}/${this.availableQuests.length}: ${quest.name}`);
      const matches = this.questMatchesNpc(quest, npcData);
      console.log(`${matches ? '‚úÖ' : '‚ùå'} [QuestManager] Quest "${quest.name}" ${matches ? 'compatible' : 'incompatible'}`);
      return matches;
    });
    
    console.log(`üìä [QuestManager] Qu√™tes compatibles trouv√©es: ${npcQuests.length}/${this.availableQuests.length}`);
    
    if (npcQuests.length > 0) {
      console.log('‚úÖ [QuestManager] Affichage dialogue s√©lection qu√™tes');
      this.showQuestSelectionDialog(npcData.npcName || npcData.name || 'NPC', npcQuests);
    } else {
      console.log('‚ÑπÔ∏è [QuestManager] Aucune qu√™te disponible pour ce NPC');
      
      if (this.availableQuests.length > 0) {
        console.log('üîÑ [QuestManager] Fallback: affichage de toutes les qu√™tes disponibles');
        this.showQuestSelectionDialog(
          (npcData.npcName || npcData.name || 'NPC') + ' (Toutes les qu√™tes)',
          this.availableQuests
        );
      }
    }
  }
  
  // === üé≠ DIALOGUES QU√äTES ===
  
  showQuestSelectionDialog(npcName, quests) {
    console.log('üí¨ [QuestManager] Dialogue s√©lection qu√™tes:', npcName, quests);
    
    if (!this.questUI || !this.questUI.showQuestDialog) {
      console.warn('‚ö†Ô∏è [QuestManager] QuestUI non disponible');
      if (quests.length === 1) {
        this.startQuest(quests[0].id);
      }
      return true;
    }
    
    this.questUI.showQuestDialog(
      `${npcName || 'Donneur de qu√™tes'} - Choisir une qu√™te`,
      quests,
      (selectedQuestId) => {
        console.log('‚úÖ [QuestManager] Qu√™te s√©lectionn√©e:', selectedQuestId);
        this.startQuest(selectedQuestId);
      }
    );
    
    return true;
  }
  
  showActiveQuestDialog(npcData, quests) {
    console.log('üé≠ [QuestManager] Dialogue qu√™tes actives:', npcData, quests);
    
    if (!this.questUI) {
      console.warn('‚ö†Ô∏è [QuestManager] QuestUI non disponible');
      return false;
    }
    
    const npcName = npcData.name || 'NPC';
    this.questUI.showQuestDialog(
      `${npcName} - Qu√™tes actives`,
      quests,
      (selectedQuestId) => {
        // Action pour qu√™te active (voir d√©tails, terminer, etc.)
        console.log('üìñ [QuestManager] Consultation qu√™te active:', selectedQuestId);
      }
    );
    
    return true;
  }
  
  showQuestCompletionDialog(data) {
    console.log('üéâ [QuestManager] Dialogue compl√©tion qu√™te:', data);
    
    if (typeof window.showNpcDialogue === 'function') {
      const dialogueData = {
        portrait: data.portrait || "/assets/portrait/defaultPortrait.png",
        name: data.npcName || "PNJ",
        lines: data.lines || ["F√©licitations ! Qu√™te termin√©e !"]
      };
      
      window.showNpcDialogue(dialogueData);
    }
  }
  
  // === üìà PROGRESSION AUTOMATIQUE ===
  
  triggerCollectEvent(itemId, amount = 1) {
    if (this.shouldTriggerEvent('collect', `${itemId}_${amount}`)) {
      this.triggerProgress({
        type: 'collect',
        targetId: itemId,
        amount: amount
      });
    }
  }
  
  triggerDefeatEvent(pokemonId) {
    if (this.shouldTriggerEvent('defeat', pokemonId)) {
      this.triggerProgress({
        type: 'defeat',
        pokemonId: pokemonId,
        amount: 1
      });
    }
  }
  
  triggerReachEvent(zoneId, x, y, map) {
    if (this.shouldTriggerEvent('reach', zoneId)) {
      this.triggerProgress({
        type: 'reach',
        targetId: zoneId,
        location: { x, y, map }
      });
    }
  }
  
  triggerDeliverEvent(npcId, itemId) {
    if (this.shouldTriggerEvent('deliver', `${npcId}_${itemId}`)) {
      this.triggerProgress({
        type: 'deliver',
        npcId: npcId,
        targetId: itemId
      });
    }
  }
  
  triggerTalkEvent(npcId) {
    if (this.shouldTriggerEvent('talk', npcId)) {
      this.triggerProgress({
        type: 'talk',
        npcId: npcId,
        targetId: npcId.toString()
      });
    }
  }
  
  shouldTriggerEvent(type, identifier) {
    const key = `${type}_${identifier}`;
    const now = Date.now();
    const lastTime = this.lastNotificationTime.get(key);
    
    if (!lastTime || (now - lastTime) > this.notificationCooldown) {
      this.lastNotificationTime.set(key, now);
      return true;
    }
    
    console.log(`üîï [QuestManager] √âv√©nement d√©dupliqu√©: ${key}`);
    return false;
  }
  
  triggerProgress(data) {
    this.requestWithQueue("questProgress", data)
      .catch(error => console.warn('‚ö†Ô∏è Erreur triggerProgress:', error));
  }
  
  // === üé¨ ACTIONS UTILISATEUR ===
  
  handleAction(action, data) {
    console.log(`üé¨ [QuestManager] Action: ${action}`, data);
    
    if (!this.gameRoom) {
      console.warn('‚ö†Ô∏è [QuestManager] Pas de gameRoom pour action');
      return;
    }
    
    switch (action) {
      case 'startQuest':
        this.startQuest(data.questId);
        break;
        
      case 'refreshQuests':
        this.requestQuestData();
        break;
        
      case 'getAvailableQuests':
        this.requestAvailableQuests();
        break;
        
      case 'triggerProgress':
        this.triggerProgress(data);
        break;
        
      case 'debugQuests':
        this.debugQuests();
        break;
        
      default:
        console.warn(`‚ö†Ô∏è [QuestManager] Action inconnue: ${action}`);
    }
  }
  
  debugQuests() {
    this.requestWithQueue("debugPlayerQuests")
      .catch(error => console.warn('‚ö†Ô∏è Erreur debugQuests:', error));
  }
  
  // === üîó CONNEXION AVEC QUESTUI ===
  
  connectQuestUI(questUI) {
    console.log('üîó [QuestManager] Connexion avec QuestUI');
    this.questUI = questUI;
    
    if (this.activeQuests.length > 0 && questUI.updateQuestData) {
      questUI.updateQuestData(this.activeQuests, 'active');
    }
  }
  
  // === üìä CALCULS ET CALLBACKS ===
  
  calculateStats() {
    this.questStats.totalActive = this.activeQuests.length;
    this.questStats.newQuests = this.activeQuests.filter(q => q.isNew).length;
    this.questStats.readyToComplete = this.activeQuests.filter(q => 
      q.status === 'readyToComplete' || q.currentStepIndex >= (q.steps?.length || 0)
    ).length;
    
    console.log('üìä [QuestManager] Stats calcul√©es:', this.questStats);
  }
  
  triggerCallbacks() {
    this.triggerCallback('onQuestUpdate', this.activeQuests);
    this.triggerCallback('onStatsUpdate', this.questStats);
  }
  
  triggerCallback(callbackName, data) {
    const callback = this[callbackName];
    if (callback && typeof callback === 'function') {
      try {
        callback(data);
      } catch (error) {
        console.error(`‚ùå [QuestManager] Erreur callback ${callbackName}:`, error);
      }
    }
  }
  
  updateNpcQuestStatuses(statuses) {
    if (window.npcManager && window.npcManager.updateQuestStatuses) {
      window.npcManager.updateQuestStatuses(statuses);
    }
    
    window.dispatchEvent(new CustomEvent('questStatusesUpdated', {
      detail: { statuses }
    }));
  }
  
  triggerIntroSequence(data) {
    console.log('üé¨ [QuestManager] D√©marrage s√©quence intro...');
    
    if (this.gameRoom) {
      this.gameRoom.send("intro_started");
    }
    
    if (typeof window.createSequentialDiscussion === 'function') {
      const introMessages = [
        {
          speaker: "Narrator",
          portrait: "/assets/portrait/narratorPortrait.png",
          text: "Bienvenue dans votre aventure Pok√©mon !",
          hideName: true
        },
        {
          speaker: "Psyduck",
          portrait: "/assets/portrait/psyduckPortrait.png",
          text: "Salut ! Je suis Psyduck et je vais t'accompagner dans tes premiers pas !"
        },
        {
          speaker: "Psyduck", 
          portrait: "/assets/portrait/psyduckPortrait.png",
          text: "Viens, suis-moi ! Je vais te montrer les bases de ce monde."
        }
      ];
      
      window.createSequentialDiscussion(
        "Psyduck",
        "/assets/portrait/psyduckPortrait.png",
        introMessages,
        {
          onComplete: () => {
            console.log('üé¨ [QuestManager] S√©quence intro termin√©e');
            
            if (this.gameRoom) {
              this.gameRoom.send("intro_completed");
            }
          }
        }
      );
    } else {
      console.warn('‚ö†Ô∏è [QuestManager] Syst√®me de dialogue non disponible pour intro');
    }
  }
  
  // === üîß UTILITAIRES ===
  
  normalizeQuestData(quest) {
    try {
      if (typeof quest === 'string') {
        quest = JSON.parse(quest);
      }

      const normalized = {
        id: quest.id || quest._id || `quest_${Date.now()}`,
        name: quest.name || 'Qu√™te sans nom',
        description: quest.description || 'Pas de description disponible',
        category: quest.category || 'side',
        level: quest.level || '',
        currentStepIndex: quest.currentStepIndex || 0,
        status: quest.status || 'active',
        steps: []
      };

      if (quest.steps && Array.isArray(quest.steps)) {
        normalized.steps = quest.steps.map((step, index) => {
          try {
            if (typeof step === 'string') {
              step = JSON.parse(step);
            }
            
            return {
              id: step.id || `step_${index}`,
              name: step.name || `√âtape ${index + 1}`,
              description: step.description || 'Pas de description',
              objectives: step.objectives || [],
              rewards: step.rewards || [],
              completed: step.completed || false
            };
          } catch (err) {
            console.warn("‚ö†Ô∏è [QuestManager] Erreur step:", err);
            return {
              id: `step_${index}`,
              name: `√âtape ${index + 1}`,
              description: 'Description non disponible',
              objectives: [],
              rewards: [],
              completed: false
            };
          }
        });
      }

      return normalized;

    } catch (error) {
      console.error("‚ùå [QuestManager] Erreur normalizeQuestData:", error, quest);
      return {
        id: 'error_quest',
        name: 'Qu√™te (Erreur)',
        description: 'Cette qu√™te n\'a pas pu √™tre charg√©e correctement.',
        category: 'error',
        steps: []
      };
    }
  }
  
  showNotification(message, type = 'info') {
    if (typeof window.showGameNotification === 'function') {
      window.showGameNotification(message, type, {
        duration: 3000,
        position: 'bottom-center'
      });
    } else {
      console.log(`üì¢ [QuestManager] ${type.toUpperCase()}: ${message}`);
    }
  }
  
  // === üìñ GETTERS ===
  
  getActiveQuests() {
    return [...this.activeQuests];
  }
  
  getAvailableQuests() {
    return [...this.availableQuests];
  }
  
  getCompletedQuests() {
    return [...this.completedQuests];
  }
  
  getQuestStats() {
    return { ...this.questStats };
  }
  
  getQuestCount() {
    return this.activeQuests.length;
  }
  
  hasActiveQuests() {
    return this.activeQuests.length > 0;
  }
  
  hasNewQuests() {
    return this.questStats.newQuests > 0;
  }
  
  hasQuestsReadyToComplete() {
    return this.questStats.readyToComplete > 0;
  }
  
  getQuestById(questId) {
    return this.activeQuests.find(q => q.id === questId || q._id === questId) || null;
  }
  
  getQuestsByCategory(category) {
    return this.activeQuests.filter(q => q.category === category);
  }
  
  getMainQuests() {
    return this.getQuestsByCategory('main');
  }
  
  getSideQuests() {
    return this.getQuestsByCategory('side');
  }
  
  getDailyQuests() {
    return this.getQuestsByCategory('daily');
  }
  
  // === üßπ NETTOYAGE ===
  
  destroy() {
    console.log('üßπ [QuestManager] Destruction...');
    
    // Reset callbacks
    this.onQuestUpdate = null;
    this.onQuestStarted = null;
    this.onQuestCompleted = null;
    this.onQuestProgress = null;
    this.onStatsUpdate = null;
    
    // Reset donn√©es
    this.activeQuests = [];
    this.completedQuests = [];
    this.availableQuests = [];
    this.questStats = {
      totalActive: 0,
      totalCompleted: 0,
      newQuests: 0,
      readyToComplete: 0
    };
    
    // Reset √©tat
    this.initialized = false;
    this.gameRoom = null;
    this.questUI = null;
    this.pendingNpcInteraction = null;
    this.lastNotificationTime.clear();
    this.interactionHistory.clear();
    this.requestQueue = [];
    
    console.log('‚úÖ [QuestManager] D√©truit');
  }
  
  // === üêõ DEBUG ===
  
  getDebugInfo() {
    return {
      initialized: this.initialized,
      questCount: this.getQuestCount(),
      questStats: this.questStats,
      hasGameRoom: !!this.gameRoom,
      hasQuestUI: !!this.questUI,
      lastDataRequest: this.lastDataRequest,
      pendingNpcInteraction: !!this.pendingNpcInteraction,
      requestQueueLength: this.requestQueue.length,
      processingQueue: this.processingQueue,
      interactionHistorySize: this.interactionHistory.size,
      callbacks: {
        onQuestUpdate: !!this.onQuestUpdate,
        onQuestStarted: !!this.onQuestStarted,
        onQuestCompleted: !!this.onQuestCompleted,
        onQuestProgress: !!this.onQuestProgress,
        onStatsUpdate: !!this.onStatsUpdate
      },
      questAnalysis: this.getQuestAnalysis(),
      availableQuestsCount: this.availableQuests.length,
      notificationCacheSize: this.lastNotificationTime.size,
      fallbackEnabled: this.fallbackEnabled
    };
  }
  
  getQuestAnalysis() {
    return {
      questCount: this.getQuestCount(),
      hasActiveQuests: this.hasActiveQuests(),
      newQuests: this.questStats.newQuests,
      readyToComplete: this.questStats.readyToComplete,
      categories: {
        main: this.getMainQuests().length,
        side: this.getSideQuests().length,
        daily: this.getDailyQuests().length
      },
      totalCompleted: this.questStats.totalCompleted,
      initialized: this.initialized,
      hasUI: !!this.questUI
    };
  }
  
  logDebugInfo() {
    console.log('üêõ [QuestManager] === DEBUG INFO ===', this.getDebugInfo());
  }
  
  debugQuestNpcMatching(npcData) {
    console.log('üêõ [QuestManager] === DEBUG QUEST-NPC MATCHING ===');
    console.log('üìä NPC Data:', npcData);
    console.log('üìä Qu√™tes disponibles:', this.availableQuests.length);
    
    this.availableQuests.forEach((quest, index) => {
      console.log(`\n--- Quest ${index + 1}: ${quest.name} ---`);
      console.log('Quest details:', {
        id: quest.id,
        startNpcId: quest.startNpcId,
        endNpcId: quest.endNpcId,
        npcId: quest.npcId,
        startNpcName: quest.startNpcName,
        endNpcName: quest.endNpcName
      });
      
      const matches = this.questMatchesNpc(quest, npcData);
      console.log(`Result: ${matches ? '‚úÖ COMPATIBLE' : '‚ùå INCOMPATIBLE'}`);
    });
    
    console.log('üêõ [QuestManager] === FIN DEBUG ===');
  }
}

export default QuestManager;

console.log(`
üìñ === QUEST MANAGER ULTRA-ROBUSTE COMPLET ===

‚úÖ CORRECTIONS MAJEURES:
1. Setup handlers IMM√âDIAT dans constructor
2. Validation et retry handlers automatique
3. Queue de requ√™tes avec retry automatique
4. NPC matching intelligent et permissif
5. Fallbacks robustes partout
6. Error handling complet sur tous les handlers
7. D√©duplication et cooldowns intelligents

üéØ FONCTIONNALIT√âS COMPL√àTES:
‚Ä¢ Communication serveur ultra-robuste
‚Ä¢ Interaction NPC avec matching intelligent
‚Ä¢ Progression automatique des qu√™tes
‚Ä¢ Gestion des dialogues et s√©lections
‚Ä¢ Callbacks et √©v√©nements complets
‚Ä¢ Normalisation des donn√©es automatique
‚Ä¢ Debug et diagnostics avanc√©s

üîß ROBUSTESSE:
‚Ä¢ Queue de requ√™tes avec retry
‚Ä¢ Handlers avec error catching
‚Ä¢ Fallback mode automatique
‚Ä¢ Validation des connexions
‚Ä¢ Cooldowns et d√©duplication
‚Ä¢ Recovery automatique

üéÆ QUEST MANAGER MAINTENANT ULTRA-FIABLE !
`);
