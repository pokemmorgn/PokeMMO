// client/src/game/ShopSystem.js - Syst√®me de gestion des shops c√¥t√© client

import { ShopUI } from '../components/ShopUI.js';

export class ShopSystem {
  constructor(scene, gameRoom) {
    this.scene = scene;
    this.gameRoom = gameRoom;
    this.shopUI = null;
    this.currentShopId = null;
    this.currentNpcId = null;

      // ‚úÖ NOUVEAUX VERROUS
  this.isOpeningShop = false;
    
    // ‚úÖ R√©f√©rence au NotificationManager
    this.notificationManager = window.NotificationManager;
    
    // √âtat du syst√®me
    this.isInitialized = false;
    this.playerGold = 0;
    this.lastTransactionTime = 0;
    
    this.init();
  }

  init() {
    try {
      // Cr√©er l'interface de shop
      this.shopUI = new ShopUI(this.gameRoom);
      
      // Configurer les interactions entre les composants
      this.setupInteractions();
      
      // Rendre le syst√®me accessible globalement
      window.shopSystem = this;
      
      this.isInitialized = true;
      console.log("üè™ Syst√®me de shop initialis√©");
    } catch (error) {
      console.error("‚ùå Erreur initialisation ShopSystem:", error);
    }
  }

  setupInteractions() {
    // √âcouter les √©v√©nements du serveur pour les shops
    this.setupServerListeners();
    
    // Configurer les raccourcis clavier
    this.setupKeyboardShortcuts();
    
    // Int√©grer avec les autres syst√®mes
    this.setupSystemIntegration();
  }

  setupServerListeners() {
    if (!this.gameRoom) return;

    console.log("üì° Configuration des listeners serveur pour ShopSystem");

    // ‚úÖ √âcouter les interactions NPC qui sont des marchands
    this.gameRoom.onMessage("npcInteractionResult", (data) => {
      if (data.type === "shop") {
        this.handleShopNpcInteraction(data);
      }
    });

    // ‚úÖ R√©sultats de transaction shop
    this.gameRoom.onMessage("shopTransactionResult", (data) => {
      this.handleTransactionResult(data);
    });

    // ‚úÖ Catalogue de shop re√ßu
    this.gameRoom.onMessage("shopCatalogResult", (data) => {
      if (this.shopUI) {
        this.shopUI.handleShopCatalog(data);
      }
    });

    // ‚úÖ Mise √† jour de l'or du joueur
    this.gameRoom.onMessage("goldUpdate", (data) => {
      this.updatePlayerGold(data.newGold, data.oldGold);
    });

    // ‚úÖ Rafra√Æchissement de shop
    this.gameRoom.onMessage("shopRefreshResult", (data) => {
      if (this.shopUI) {
        this.shopUI.handleRefreshResult(data);
      }
    });
  }

  // ‚úÖ GESTION DES INTERACTIONS NPC MARCHAND
handleShopNpcInteraction(data) {
  console.log(`üè™ Interaction avec NPC marchand:`, data);

  // ‚úÖ NOUVEAU: R√©initialiser les verrous
  this.isOpeningShop = false;

  try {
    // Extraire les donn√©es importantes
    const shopId = data.shopId || 'default_shop';
    const shopData = data.shopData;
    
    // ‚úÖ CORRECTION MAJEURE: Construction robuste de l'objet NPC
    let npc = { name: "Marchand", id: data.npcId || 'unknown' };
    
    // 1. Priorit√© aux donn√©es NPC du serveur
    if (data.npc && typeof data.npc === 'object') {
      npc = { ...npc, ...data.npc };
      console.log('üé≠ NPC depuis data.npc:', npc);
    }
    
    // 2. Puis aux donn√©es npcName
    if (data.npcName) {
      if (typeof data.npcName === 'object' && data.npcName.name) {
        npc.name = data.npcName.name;
        npc.id = data.npcName.id || npc.id;
        console.log('üé≠ NPC depuis data.npcName objet:', npc);
      } else if (typeof data.npcName === 'string') {
        npc.name = data.npcName;
        console.log('üé≠ NPC depuis data.npcName string:', npc);
      }
    }
    
    // 3. Enrichir avec le vrai NPC du manager si possible
    const realNpc = this.scene?.npcManager?.getNpcData?.(data.npcId) ||
                   window.interactionManager?.state?.lastInteractedNpc;
    
    if (realNpc) {
      npc = {
        ...realNpc,
        name: realNpc.name || npc.name,
        id: realNpc.id || npc.id
      };
      console.log('üé≠ NPC enrichi depuis manager:', npc);
    }

    // Stocker les infos du shop
    this.currentShopId = shopId;
    this.currentNpcId = data.npcId;

    // Extraire l'or du joueur
    if (shopData && shopData.playerGold !== undefined) {
      this.playerGold = shopData.playerGold;
    }

    // ‚úÖ OUVRIR LE SHOP AVEC FORCE
    console.log(`üöÄ FORCER ouverture shop: ${shopId} pour ${npc.name}`);
    const success = this.forceOpenShop(shopId, npc, shopData);
    
    if (success) {
      // Notification de succ√®s
      this.showInfo(`Bienvenue chez ${npc.name} !`);
    } else {
      console.error('‚ùå √âchec ouverture forc√©e shop');
      this.showError('Impossible d\'ouvrir le shop');
    }
    
  } catch (error) {
    console.error('‚ùå Erreur handleShopNpcInteraction:', error);
    this.showError(`Erreur shop: ${error.message}`);
  }
}

// === 3. NOUVELLE M√âTHODE DANS ShopSystem.js - Force Open Shop ===
forceOpenShop(shopId, npc, shopData = null) {
  console.log(`üí™ [ShopSystem] === OUVERTURE FORC√âE ===`);
  console.log(`üéØ Shop: ${shopId}`);
  console.log(`üé≠ NPC:`, npc);
  
  // ‚úÖ RESET complet de l'√©tat
  this.isOpeningShop = false;
  if (this.shopUI) {
    this.shopUI.isProcessingCatalog = false;
  }

  // ‚úÖ V√©rifier l'UI
  if (!this.shopUI) {
    console.error('‚ùå ShopUI manquant!');
    return false;
  }

  try {
    // ‚úÖ FORCER fermeture si d√©j√† ouvert
    if (this.isShopOpen()) {
      console.log('üîÑ Shop d√©j√† ouvert, fermeture forc√©e...');
      this.shopUI.hide();
    }

    // ‚úÖ OUVERTURE DIRECTE
    console.log(`üö™ Ouverture directe de l'interface...`);
    this.shopUI.show(shopId, npc);

    // ‚úÖ INJECTION IMM√âDIATE DES DONN√âES si disponibles
    if (shopData) {
      console.log('üíâ Injection imm√©diate des donn√©es...');
      
      // Construire la structure attendue
      const catalogData = {
        success: true,
        catalog: shopData,
        playerGold: this.playerGold || 0
      };
      
      // Forcer le traitement
      this.shopUI.handleShopCatalog(catalogData);
    }

    // ‚úÖ Jouer son d'ouverture
    this.playSound('shop_open');

    // ‚úÖ Mettre √† jour l'√©tat global
    this.updateGlobalUIState(true);

    console.log('‚úÖ Ouverture forc√©e r√©ussie!');
    return true;

  } catch (error) {
    console.error('‚ùå Erreur ouverture forc√©e:', error);
    this.showError(`Erreur technique: ${error.message}`);
    return false;
  }
}

// === 4. CORRECTION DANS InteractionManager.js - M√©thode handleShopInteraction ===
handleShopInteraction(npc, data) {
  console.log('üè™ [InteractionManager] Handling shop interaction:', { npc: npc?.name, data });
  
  // V√©rifier le syst√®me shop
  this.shopSystem = this.shopSystem || 
                   (this.scene.shopIntegration?.getShopSystem()) || 
                   window.shopSystem;
  
  if (!this.shopSystem) {
    console.error('‚ùå [InteractionManager] Aucun ShopSystem disponible!');
    this.handleDialogueInteraction(npc, { 
      message: "Ce marchand n'est pas disponible." 
    });
    return;
  }

  // ‚úÖ Si c'est un dialogue, le traiter comme tel
  if (data && data.type === 'dialogue') {
    this.handleDialogueInteraction(npc, data);
    return;
  }

  try {
    // ‚úÖ CORRECTION: Construire les donn√©es d'interaction proprement
    const interactionData = data || this.createShopInteractionData(npc);
    
    // ‚úÖ NOUVEAU: S'assurer que le npcName est correct
    if (npc) {
      interactionData.npc = npc;
      interactionData.npcName = npc.name;
      interactionData.npcId = npc.id;
    }
    
    console.log('üì§ [InteractionManager] Envoi au ShopSystem:', interactionData);
    
    // ‚úÖ D√©l√©guer au ShopSystem
    this.shopSystem.handleShopNpcInteraction(interactionData);
    
  } catch (error) {
    console.error('‚ùå [InteractionManager] Erreur shop:', error);
    this.handleDialogueInteraction(npc, { 
      message: `Erreur shop: ${error.message}`
    });
  }
}

// === 5. FONCTION DE DEBUG COMPL√àTE ===
function debugShopState() {
  console.log('üîç === DEBUG COMPLET SHOP ===');
  
  // √âtat des syst√®mes
  console.log('üìä SYST√àMES:');
  console.log('  - window.shopSystem:', !!window.shopSystem);
  console.log('  - scene.shopIntegration:', !!window.game?.scene?.getScenes(true)[0]?.shopIntegration);
  console.log('  - scene.interactionManager:', !!window.game?.scene?.getScenes(true)[0]?.interactionManager);
  
  // √âtat du shop
  if (window.shopSystem) {
    console.log('üè™ SHOP SYSTEM:');
    console.log('  - isInitialized:', window.shopSystem.isInitialized);
    console.log('  - shopUI exists:', !!window.shopSystem.shopUI);
    console.log('  - gameRoom exists:', !!window.shopSystem.gameRoom);
    console.log('  - isShopOpen:', window.shopSystem.isShopOpen());
    console.log('  - currentShopId:', window.shopSystem.currentShopId);
    console.log('  - playerGold:', window.shopSystem.playerGold);
    
    if (window.shopSystem.shopUI) {
      console.log('üñºÔ∏è SHOP UI:');
      console.log('  - isVisible:', window.shopSystem.shopUI.isVisible);
      console.log('  - isProcessingCatalog:', window.shopSystem.shopUI.isProcessingCatalog);
      console.log('  - shopData exists:', !!window.shopSystem.shopUI.shopData);
      console.log('  - overlay exists:', !!window.shopSystem.shopUI.overlay);
    }
  }
  
  // Test d'ouverture forc√©e
  console.log('üß™ TEST OUVERTURE FORC√âE...');
  if (window.shopSystem && window.shopSystem.forceOpenShop) {
    window.shopSystem.forceOpenShop('test_shop', { name: 'Test NPC', id: 'test' }, {
      shopInfo: { id: 'test_shop', name: 'Test Shop' },
      availableItems: [
        { itemId: 'potion', buyPrice: 300, stock: 10, canBuy: true, unlocked: true }
      ]
    });
  }
}

// === 6. AJOUTER LA FONCTION AU WINDOW GLOBAL ===
window.debugShopState = debugShopState;
window.forceOpenTestShop = function() {
  if (window.shopSystem && window.shopSystem.forceOpenShop) {
    window.shopSystem.forceOpenShop('test_shop', 
      { name: 'Marchand Test', id: 'test_npc' }, 
      {
        shopInfo: { id: 'test_shop', name: 'Boutique Test' },
        availableItems: [
          { itemId: 'potion', buyPrice: 300, stock: 10, canBuy: true, unlocked: true },
          { itemId: 'poke_ball', buyPrice: 200, stock: 5, canBuy: true, unlocked: true }
        ]
      }
    );
  } else {
    console.error('‚ùå ShopSystem non disponible');
  }
};


  // ‚úÖ FERMETURE DE SHOP
  closeShop() {
    if (!this.isShopOpen()) return;
    
    console.log(`üè™ Fermeture du shop: ${this.currentShopId}`);
    
    if (this.shopUI) {
      this.shopUI.hide();
    }
    
    this.currentShopId = null;
    this.currentNpcId = null;
    
    // ‚úÖ Notification de fermeture
    this.showInfo("√Ä bient√¥t !");
    
    // ‚úÖ Jouer un son de fermeture
    this.playSound('shop_close');
    
    // ‚úÖ Mettre √† jour l'√©tat global
    this.updateGlobalUIState(false);
    
    // ‚úÖ Sauvegarder les pr√©f√©rences
    this.saveShopPreferences();
  }

  // ‚úÖ GESTION DES R√âSULTATS DE TRANSACTION
  handleTransactionResult(data) {
    console.log(`üí∞ R√©sultat transaction:`, data);
    
    this.lastTransactionTime = Date.now();
    
    if (data.success) {
      // ‚úÖ Notification de succ√®s avec d√©tails
      this.showTransactionSuccessNotification(data);
      
      // ‚úÖ Effet visuel et sonore de succ√®s
      this.playSound('shop_buy_success');
      
      // ‚úÖ Mettre √† jour l'or si fourni
      if (data.newGold !== undefined) {
        this.updatePlayerGold(data.newGold);
      }
      
      // ‚úÖ Int√©gration avec l'inventaire si disponible
      this.updateInventoryAfterTransaction(data);
      
      // ‚úÖ Ajouter √† l'historique
      this.addTransactionToHistory(data);
      
    } else {
      // ‚úÖ Notification d'√©chec
      this.showError(data.message || "Transaction √©chou√©e");
      
      // ‚úÖ Son d'erreur
      this.playSound('shop_error');
    }
  }

  // ‚úÖ NOTIFICATION DE SUCC√àS D√âTAILL√âE
  showTransactionSuccessNotification(data) {
    const message = data.message || "Transaction r√©ussie";
    
    // ‚úÖ Notification principale
    this.showSuccess(message);
    
    // ‚úÖ Analyser le type de transaction
    const isBuy = message.includes('Bought') || message.includes('achet√©');
    const isSell = message.includes('Sold') || message.includes('vendu');
    
    // ‚úÖ Notification sp√©ciale pour les achats importants
    if (isBuy && data.itemsChanged) {
      const item = data.itemsChanged[0];
      if (this.isImportantItem(item.itemId)) {
        setTimeout(() => {
          this.showAchievement(`Nouvel objet important: ${this.getItemName(item.itemId)} !`);
        }, 1000);
      }
    }
  }

  // ‚úÖ MISE √Ä JOUR DE L'OR DU JOUEUR
  updatePlayerGold(newGold, oldGold = null) {
    const previousGold = oldGold !== null ? oldGold : this.playerGold;
    this.playerGold = newGold;
    
    // Mettre √† jour l'interface
    if (this.shopUI) {
      this.shopUI.updatePlayerGold(newGold);
    }
    
    // Notification du changement
    if (oldGold !== null) {
      this.showGoldNotification(newGold, previousGold);
    }
  }

  // ‚úÖ NOTIFICATION DE CHANGEMENT D'OR
  showGoldNotification(newGold, oldGold) {
    const difference = newGold - oldGold;
    if (difference === 0) return;
    
    const isGain = difference > 0;
    const message = isGain 
      ? `+${difference}‚ÇΩ gagn√© !`
      : `${Math.abs(difference)}‚ÇΩ d√©pens√©`;
    
    const notificationType = isGain ? 'success' : 'info';
    this.showNotification(message, notificationType, 2000);
  }

  // ‚úÖ MISE √Ä JOUR DE L'INVENTAIRE APR√àS TRANSACTION
  updateInventoryAfterTransaction(data) {
    if (!data.itemsChanged || !window.inventorySystem) return;
    
    // Notifier le syst√®me d'inventaire des changements
    data.itemsChanged.forEach(itemChange => {
      const isAdd = itemChange.quantityChanged > 0;
      
      // ‚úÖ D√©clencher les notifications d'inventaire
      if (isAdd) {
        window.inventorySystem.onItemPickup(
          itemChange.itemId, 
          itemChange.quantityChanged
        );
      }
    });
  }

  // ‚úÖ AJOUT √Ä L'HISTORIQUE DES TRANSACTIONS
  addTransactionToHistory(data) {
    if (!window.shopHistory) {
      window.shopHistory = [];
    }

    if (data.itemsChanged && data.itemsChanged.length > 0) {
      const item = data.itemsChanged[0];
      const action = item.quantityChanged > 0 ? 'buy' : 'sell';
      const cost = Math.abs(item.quantityChanged) * (action === 'buy' ? 
        (this.shopUI?.selectedItem?.buyPrice || 0) : 
        (this.shopUI?.selectedItem?.sellPrice || 0));

      window.shopHistory.push({
        timestamp: new Date(),
        shopId: this.currentShopId,
        itemId: item.itemId,
        itemName: this.getItemName(item.itemId),
        quantity: Math.abs(item.quantityChanged),
        action: action,
        cost: cost,
        playerGoldAfter: this.playerGold
      });

      // Garder seulement les 50 derni√®res transactions
      if (window.shopHistory.length > 50) {
        window.shopHistory = window.shopHistory.slice(-50);
      }
    }
  }

  // ‚úÖ V√âRIFICATION SI UN OBJET EST IMPORTANT
  isImportantItem(itemId) {
    const importantItems = [
      'master_ball',
      'max_potion',
      'full_restore',
      'max_revive',
      'max_repel',
      'rare_candy',
      'pp_max',
      'sacred_ash'
    ];
    return importantItems.includes(itemId);
  }

  // ‚úÖ OBTENIR LE NOM LOCALIS√â D'UN OBJET
  getItemName(itemId) {
    if (this.shopUI) {
      return this.shopUI.getItemName(itemId);
    }
    return itemId.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  }

  // ‚úÖ SETUP DES RACCOURCIS CLAVIER - MODIFI√â POUR LA TOUCHE L
  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      // ‚úÖ CONDITION RESTRICTIVE : Ne capturer L que dans des conditions tr√®s sp√©cifiques
      
      // Si le shop est ouvert, traiter les raccourcis du shop
      if (this.isShopOpen()) {
        this.handleShopKeyboardShortcuts(e);
        return;
      }
      
      // ‚úÖ Pour ouvrir le shop avec L, il faut que TOUTES ces conditions soient vraies :
      // 1. Le joueur ne bouge PAS (aucune touche de mouvement press√©e)
      // 2. Aucune autre interface n'est ouverte
      // 3. Le joueur est stationnaire depuis au moins 500ms
      // 4. Il y a un marchand √† proximit√©
      
      if (e.key.toLowerCase() === 'l') {
        // V√©rifier si c'est un raccourci shop valide
        if (this.shouldHandleShopShortcut()) {
          this.tryOpenNearbyShop();
          e.preventDefault();
          e.stopPropagation();
        }
        // Sinon, laisser passer la touche L normalement
      }
    });
  }

  // ‚úÖ Nouvelle m√©thode pour d√©terminer si on doit traiter le raccourci shop
  shouldHandleShopShortcut() {
    // 1. V√©rifier qu'aucune interface n'est ouverte
    if (!this.canPlayerInteract()) {
      return false;
    }
    
    // 2. V√©rifier qu'aucune touche de mouvement n'est press√©e
    if (this.areMovementKeysPressed()) {
      return false;
    }
    
    // 3. V√©rifier que le joueur est pr√®s d'un marchand
    if (!this.isNearMerchant()) {
      return false;
    }
    
    // 4. V√©rifier un d√©lai depuis le dernier mouvement (optionnel)
    const timeSinceLastMovement = Date.now() - (window.lastMovementTime || 0);
    if (timeSinceLastMovement < 300) { // 300ms de d√©lai
      return false;
    }
    
    return true;
  }

  // ‚úÖ V√©rifier si des touches de mouvement sont press√©es
  areMovementKeysPressed() {
    // Acc√©der au syst√®me de contr√¥les si disponible
    if (window.gameControls && window.gameControls.pressedKeys) {
      const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'];
      return movementKeys.some(key => window.gameControls.pressedKeys.has(key.toLowerCase()));
    }
    
    // Fallback : v√©rifier directement
    if (this.scene && this.scene.input && this.scene.input.keyboard) {
      const cursors = this.scene.input.keyboard.cursors;
      const wasd = this.scene.input.keyboard.addKeys('W,S,A,D');
      
      return (
        cursors.left.isDown || cursors.right.isDown || 
        cursors.up.isDown || cursors.down.isDown ||
        wasd.W.isDown || wasd.A.isDown || wasd.S.isDown || wasd.D.isDown
      );
    }
    
    return false;
  }

  // ‚úÖ V√©rifier si le joueur est pr√®s d'un marchand
  isNearMerchant() {
    if (!this.scene || !this.scene.playerManager || !this.scene.npcManager) {
      return false;
    }

    const myPlayer = this.scene.playerManager.getMyPlayer();
    if (!myPlayer) return false;

    // Chercher un NPC marchand √† proximit√© (distance plus courte)
    const nearbyNpc = this.scene.npcManager.getClosestNpc(myPlayer.x, myPlayer.y, 48); // 48px au lieu de 64
    
    if (!nearbyNpc) return false;
    
    // V√©rifier si c'est un marchand
    return !!(
      nearbyNpc.properties?.npcType === 'merchant' ||
      nearbyNpc.properties?.shopId ||
      nearbyNpc.properties?.shop
    );
  }

  // ‚úÖ G√©rer les raccourcis quand le shop est ouvert
  handleShopKeyboardShortcuts(e) {
    if (!this.shopUI) return;
    
    const handled = this.shopUI.handleKeyPress(e.key);
    if (handled) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    
    // Raccourcis suppl√©mentaires
    switch (e.key.toLowerCase()) {
      case 'escape':
        this.closeShop();
        e.preventDefault();
        e.stopPropagation();
        break;
        
      case 'l':
        // Fermer le shop avec L aussi
        this.closeShop();
        e.preventDefault();
        e.stopPropagation();
        break;
        
      case 'arrowup':
      case 'arrowdown':
        if (this.shopUI.navigateItems) {
          this.shopUI.navigateItems(e.key === 'ArrowDown' ? 'next' : 'prev');
          e.preventDefault();
          e.stopPropagation();
        }
        break;
        
      case 'h':
        this.showTransactionHistory();
        e.preventDefault();
        e.stopPropagation();
        break;
        
      case 'p':
        this.checkForPromotions();
        e.preventDefault();
        e.stopPropagation();
        break;
    }
  }

  // ‚úÖ Version am√©lior√©e de tryOpenNearbyShop
  tryOpenNearbyShop() {
    console.log("üè™ Recherche de marchand √† proximit√©...");
    
    if (!this.scene || !this.scene.playerManager || !this.scene.npcManager) {
      this.showInfo("Syst√®me de jeu non disponible");
      return;
    }

    const myPlayer = this.scene.playerManager.getMyPlayer();
    if (!myPlayer) {
      this.showInfo("Joueur introuvable");
      return;
    }

    // Chercher un NPC marchand √† proximit√©
    const nearbyNpc = this.scene.npcManager.getClosestNpc(myPlayer.x, myPlayer.y, 48);
    
    if (!nearbyNpc) {
      this.showInfo("Aucun marchand √† proximit√© - Approchez-vous et appuyez sur L");
      return;
    }
    
    // V√©rifier si c'est un marchand
    const isMerchant = !!(
      nearbyNpc.properties?.npcType === 'merchant' ||
      nearbyNpc.properties?.shopId ||
      nearbyNpc.properties?.shop
    );
    
    if (!isMerchant) {
      this.showInfo("Ce NPC n'est pas un marchand");
      return;
    }
    
    // D√©clencher l'interaction avec le marchand
    console.log(`üè™ Ouverture shop via raccourci L avec NPC: ${nearbyNpc.name}`);
    if (this.scene.networkManager) {
      this.scene.networkManager.sendNpcInteract(nearbyNpc.id);
    } else {
      this.showError("Connexion r√©seau indisponible");
    }
  }

  // ‚úÖ INT√âGRATION AVEC LES AUTRES SYST√àMES
  setupSystemIntegration() {
    // Int√©gration avec le syst√®me d'inventaire
    if (window.inventorySystem) {
      console.log("üîó Int√©gration ShopSystem ‚Üî InventorySystem");
    }
    
    // Int√©gration avec le syst√®me de qu√™tes
    if (window.questSystem) {
      console.log("üîó Int√©gration ShopSystem ‚Üî QuestSystem");
    }
  }

  // ‚úÖ M√âTHODES PUBLIQUES D'√âTAT
  isShopOpen() {
    return this.shopUI ? this.shopUI.isVisible : false;
  }

  getCurrentShopId() {
    return this.currentShopId;
  }

  getCurrentNpcId() {
    return this.currentNpcId;
  }

  canPlayerInteract() {
    const questDialogOpen = window._questDialogActive || false;
    const chatOpen = typeof window.isChatFocused === "function" && window.isChatFocused();
    const inventoryOpen = window.inventorySystem?.isInventoryOpen() || false;
    const dialogueOpen = document.getElementById('dialogue-box')?.style.display !== 'none';
    
    return !questDialogOpen && !chatOpen && !inventoryOpen && !dialogueOpen;
  }

  canOpenMenus() {
    return !this.isShopOpen() && this.canPlayerInteract();
  }

  // ‚úÖ M√âTHODES UTILITAIRES
  getPlayerGold() {
    return this.playerGold;
  }

  playSound(soundType) {
    // Int√©gration avec le syst√®me de sons si disponible
    if (typeof window.playSound === 'function') {
      const soundMap = {
        'shop_open': 'ui_shop_open',
        'shop_close': 'ui_shop_close',
        'shop_buy_success': 'ui_purchase_success',
        'shop_sell_success': 'ui_sell_success',
        'shop_error': 'ui_error',
        'shop_select': 'ui_select'
      };
      
      const soundId = soundMap[soundType];
      if (soundId) {
        window.playSound(soundId, { volume: 0.7 });
      }
    }
  }

  // ‚úÖ ACHAT RAPIDE
  quickBuy(itemId, quantity = 1) {
    if (!this.isShopOpen()) {
      this.showWarning("Aucun shop ouvert");
      return false;
    }
    
    // Trouver l'objet dans le catalogue actuel
    const shopData = this.shopUI.shopData;
    if (!shopData) return false;
    
    const item = shopData.availableItems.find(i => i.itemId === itemId);
    if (!item) {
      this.showError(`${this.getItemName(itemId)} non disponible`);
      return false;
    }
    
    // V√©rifier que l'achat est possible
    if (!this.canBuyItem(item)) {
      this.showError(`Impossible d'acheter ${this.getItemName(itemId)}`);
      return false;
    }
    
    // Effectuer l'achat
    this.gameRoom.send("shopTransaction", {
      shopId: this.currentShopId,
      action: 'buy',
      itemId: itemId,
      quantity: quantity
    });
    
    return true;
  }

  canBuyItem(item) {
    if (!item) return false;
    
    const canAfford = this.playerGold >= item.buyPrice;
    const inStock = item.stock === undefined || item.stock === -1 || item.stock > 0;
    const isUnlocked = item.unlocked;
    
    return canAfford && inStock && isUnlocked;
  }

  // ‚úÖ STATISTIQUES ET ANALYTICS
  getShopStats() {
    if (!this.shopUI?.shopData) return null;

    const items = this.shopUI.shopData.availableItems;
    const buyableItems = items.filter(item => item.canBuy && item.unlocked);
    const affordableItems = buyableItems.filter(item => this.canBuyItem(item));
    
    return {
      totalItems: items.length,
      buyableItems: buyableItems.length,
      affordableItems: affordableItems.length,
      playerGold: this.playerGold,
      currentTab: this.shopUI.currentTab
    };
  }

  getTransactionHistory() {
    return window.shopHistory || [];
  }

  getTotalSpent() {
    const history = this.getTransactionHistory();
    return history
      .filter(h => h.action === 'buy')
      .reduce((total, h) => total + h.cost, 0);
  }

  getTotalEarned() {
    const history = this.getTransactionHistory();
    return history
      .filter(h => h.action === 'sell')
      .reduce((total, h) => total + h.cost, 0);
  }

  // ‚úÖ AFFICHAGE DE L'HISTORIQUE
  showTransactionHistory() {
    if (!window.shopHistory || window.shopHistory.length === 0) {
      this.showInfo("Aucun historique d'achat");
      return;
    }

    const recent = window.shopHistory.slice(-5).reverse();
    const historyText = recent.map(h => 
      `${h.action === 'buy' ? 'üõí' : 'üí∞'} ${h.quantity}x ${h.itemName} (${h.cost}‚ÇΩ)`
    ).join('\n');
    
    console.log('üìú Historique des achats r√©cents:\n' + historyText);
    this.showInfo("Historique affich√© dans la console");
  }

  // ‚úÖ V√âRIFICATION DES PROMOTIONS
  checkForPromotions() {
    if (!this.shopUI?.shopData) return;

    // Exemple de logique de promotion
    const promoItems = this.shopUI.shopData.availableItems.filter(item => {
      // Promotion sur les objets chers si le joueur a beaucoup d'or
      return this.playerGold > 5000 && item.buyPrice > 1000;
    });

    if (promoItems.length > 0) {
      this.showSuccess("üéâ Offres sp√©ciales disponibles sur les objets premium !");
    } else {
      this.showInfo("Aucune promotion en cours");
    }
  }

  // ‚úÖ GESTION DES PR√âF√âRENCES
  saveShopPreferences() {
    const preferences = {
      favorites: window.shopFavorites || [],
      lastVisitedShop: this.currentShopId,
      preferredTab: this.shopUI?.currentTab || 'buy',
      soundEnabled: true
    };
    
    try {
      localStorage.setItem('pokeworld_shop_preferences', JSON.stringify(preferences));
      console.log('üè™ Pr√©f√©rences shop sauvegard√©es');
    } catch (error) {
      console.warn('‚ö†Ô∏è Impossible de sauvegarder les pr√©f√©rences shop:', error);
    }
  }

  loadShopPreferences() {
    try {
      const saved = localStorage.getItem('pokeworld_shop_preferences');
      if (saved) {
        const preferences = JSON.parse(saved);
        
        window.shopFavorites = preferences.favorites || [];
        
        console.log('üè™ Pr√©f√©rences shop charg√©es');
        return preferences;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Erreur chargement pr√©f√©rences shop:', error);
    }
    
    return null;
  }

  // ‚úÖ GESTION DE L'√âTAT GLOBAL DE L'UI
  updateGlobalUIState(shopOpen) {
    // Mettre √† jour la classe du body
    if (shopOpen) {
      document.body.classList.add('shop-open');
    } else {
      document.body.classList.remove('shop-open');
    }
  }

  // ‚úÖ M√âTHODES DE NOTIFICATION SIMPLIFI√âES
  showNotification(message, type = 'info', duration = 3000) {
    if (this.notificationManager) {
      this.notificationManager.show(message, {
        type: type,
        duration: duration,
        position: 'top-center'
      });
    } else {
      console.log(`[${type.toUpperCase()}] ${message}`);
    }
  }

  showSuccess(message) {
    this.showNotification(message, 'success');
  }

  showError(message) {
    this.showNotification(message, 'error', 4000);
  }

  showWarning(message) {
    this.showNotification(message, 'warning', 4000);
  }

  showInfo(message) {
    this.showNotification(message, 'info', 2000);
  }

  showAchievement(message) {
    if (this.notificationManager) {
      this.notificationManager.achievement(message, {
        duration: 5000,
        bounce: true
      });
    } else {
      this.showSuccess(message);
    }
  }

  // ‚úÖ DEBUG ET D√âVELOPPEMENT
  debugShopState() {
    console.log('üîç [DEBUG SHOP] √âtat actuel:');
    console.log('- Shop ouvert:', this.isShopOpen());
    console.log('- Shop ID:', this.currentShopId);
    console.log('- NPC ID:', this.currentNpcId);
    console.log('- Onglet actuel:', this.shopUI?.currentTab);
    console.log('- Objet s√©lectionn√©:', this.shopUI?.selectedItem?.itemId);
    console.log('- Or du joueur:', this.getPlayerGold());
    console.log('- Initialis√©:', this.isInitialized);
    
    if (this.shopUI?.shopData) {
      console.log('- Objets disponibles:', this.shopUI.shopData.availableItems.length);
      console.log('- Shop info:', this.shopUI.shopData.shopInfo);
    }
    
    const stats = this.getShopStats();
    if (stats) {
      console.log('- Statistiques:', stats);
    }
  }

  // ‚úÖ M√âTHODES DE NETTOYAGE
  cleanupShopData() {
    // Nettoyer les donn√©es temporaires
    this.currentShopId = null;
    this.currentNpcId = null;
    
    // Sauvegarder les pr√©f√©rences avant nettoyage
    this.saveShopPreferences();
    
    console.log('üßπ Donn√©es shop nettoy√©es');
  }

  destroy() {
    console.log('üíÄ Destruction ShopSystem');
    
    // Fermer le shop si ouvert
    if (this.isShopOpen()) {
      this.closeShop();
    }
    
    // Sauvegarder les pr√©f√©rences
    this.saveShopPreferences();
    
    // Nettoyer l'interface
    if (this.shopUI) {
      this.shopUI.destroy();
      this.shopUI = null;
    }
    
    // Nettoyer les r√©f√©rences
    this.scene = null;
    this.gameRoom = null;
    this.notificationManager = null;
    this.isInitialized = false;
    
    // Supprimer la r√©f√©rence globale
    if (window.shopSystem === this) {
      window.shopSystem = null;
    }
    
    console.log('‚úÖ ShopSystem d√©truit');
  }

  // ‚úÖ M√âTHODE D'INITIALISATION FINALE
  onSceneReady() {
    // Charger les pr√©f√©rences sauvegard√©es
    this.loadShopPreferences();
    
    console.log('üè™ ShopSystem pr√™t pour la sc√®ne');
  }
}
