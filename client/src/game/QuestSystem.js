// client/src/game/QuestSystem.js - VERSION CORRIG√âE avec coordination compl√®te

import { QuestJournalUI } from '../components/QuestJournalUI.js';
import { QuestIcon } from '../components/QuestIcon.js';
import { QuestTrackerUI } from '../components/QuestTrackerUI.js';

export class QuestSystem {
  constructor(scene, gameRoom) {
    this.scene = scene;
    this.gameRoom = gameRoom;
    this.questJournal = null;
    this.questIcon = null;
    this.questTracker = null;
    this.trackedQuest = null;
    this.questNotifications = [];

    // ‚úÖ Utiliser le NotificationManager global
    this.notificationManager = window.NotificationManager;
    if (!this.notificationManager) {
      console.warn("‚ö†Ô∏è NotificationManager non trouv√©, cr√©er une instance");
      this.notificationManager = {
        show: (message, options) => console.log(`[QUEST] ${message}`),
        success: (message, options) => console.log(`[QUEST SUCCESS] ${message}`),
        error: (message, options) => console.log(`[QUEST ERROR] ${message}`),
        warning: (message, options) => console.log(`[QUEST WARNING] ${message}`),
        info: (message, options) => console.log(`[QUEST INFO] ${message}`),
        quest: (message, options) => console.log(`[QUEST] ${message}`),
        questNotification: (questName, action, options) => console.log(`[QUEST] ${questName} - ${action}`),
        achievement: (message, options) => console.log(`[ACHIEVEMENT] ${message}`)
      };
    }
    
    // ‚úÖ Syst√®me de d√©duplication des notifications
    this.lastNotificationTime = new Map();
    this.notificationCooldown = 2000;
    
    // ‚úÖ STOCKAGE CENTRALIS√â des qu√™tes pour coordination
    this.activeQuests = [];
    this.availableQuests = [];
    
    this.init();
  }

  init() {
    // ‚úÖ MODIFICATION: Cr√©er le journal SANS listeners automatiques
    this.questJournal = new QuestJournalUI(null); // Pas de gameRoom direct
    
    // ‚úÖ Cr√©er l'ic√¥ne de qu√™te
    this.questIcon = new QuestIcon(this);
    
    // ‚úÖ Cr√©er le tracker de qu√™tes
    this.questTracker = new QuestTrackerUI(this);
    this.questTracker.connectToQuestSystem(this);
    
    // ‚úÖ NOUVEAU: Setup des listeners CENTRALIS√âS
    this.setupCentralizedListeners();
    
    // ‚úÖ Setup des timers pour le tracker
    this.setupTrackerTimers();
    
    // Rendre le syst√®me accessible globalement
    window.questSystem = this;
    
    console.log("üéØ Syst√®me de qu√™tes initialis√© avec coordination centralis√©e");
  }

  // ‚úÖ === LISTENERS CENTRALIS√âS POUR COORDINATION ===
  setupCentralizedListeners() {
    if (!this.gameRoom) {
      console.warn("‚ö†Ô∏è [QuestSystem] Pas de gameRoom pour les √©coutes centralis√©es");
      return;
    }

    console.log("üì° [QuestSystem] Configuration des √©coutes centralis√©es");

    // ‚úÖ √âCOUTER LES QU√äTES ACTIVES (CENTRALIS√â)
    this.gameRoom.onMessage("activeQuestsList", (data) => {
      console.log("üìã [QuestSystem] Liste des qu√™tes actives re√ßue:", data);
      this.activeQuests = data.quests || [];
      
      // ‚úÖ SYNCHRONISER TOUS LES COMPOSANTS
      this.syncAllComponents();
    });

    // ‚úÖ √âCOUTER LES QU√äTES DISPONIBLES (CENTRALIS√â)
    this.gameRoom.onMessage("availableQuestsList", (data) => {
      console.log("üìã [QuestSystem] Liste des qu√™tes disponibles re√ßue:", data);
      this.availableQuests = data.quests || [];
      
      // ‚úÖ Mettre √† jour seulement le journal (tracker n'affiche que les actives)
      if (this.questJournal) {
        this.questJournal.updateQuestList(this.availableQuests);
      }
    });

    // ‚úÖ √âCOUTER LES NOUVELLES QU√äTES (questGranted) - CENTRALIS√â
    this.gameRoom.onMessage("questGranted", (data) => {
      console.log("üéÅ [QuestSystem] Nouvelle qu√™te accord√©e (centralis√©):", data);
      
      // ‚úÖ AFFICHER NOTIFICATION
      if (this.shouldShowNotification('questGranted', data.questId)) {
        this.questIcon.onNewQuest();
        
        this.notificationManager.questNotification(
          data.questName || 'Nouvelle qu√™te',
          'granted',
          {
            duration: 5000,
            closable: true,
            onClick: () => {
              this.openQuestJournal();
            }
          }
        );
      }
      
      // ‚úÖ RAFRA√éCHIR LES QU√äTES ACTIVES
      setTimeout(() => {
        this.refreshActiveQuests();
      }, 500);
    });

    // ‚úÖ √âCOUTER LES PROGRESSIONS DE QU√äTE (CENTRALIS√â)
    this.gameRoom.onMessage("questProgressUpdate", (results) => {
      console.log("üìà [QuestSystem] Progression de qu√™te (centralis√©):", results);
      
      this.handleQuestProgressUpdate(results);
      
      // ‚úÖ RAFRA√éCHIR APR√àS PROGRESSION
      setTimeout(() => {
        this.refreshActiveQuests();
      }, 300);
    });

    // ‚úÖ √âCOUTER LES R√âSULTATS DE D√âMARRAGE (CENTRALIS√â)
    this.gameRoom.onMessage("questStartResult", (data) => {
      console.log("üéØ [QuestSystem] R√©sultat d√©marrage qu√™te (centralis√©):", data);
      
      if (data.success) {
        const questId = data.quest?.id || data.quest?.name || 'unknown';
        if (this.shouldShowNotification('questStart', questId)) {
          this.questIcon.onNewQuest();
          
          this.notificationManager.questNotification(
            data.quest?.name || 'Nouvelle qu√™te',
            'started',
            {
              duration: 5000,
              closable: true,
              onClick: () => {
                this.openQuestJournal();
              }
            }
          );
        }
        
        // ‚úÖ AJOUTER AU TRACKER
        if (data.quest) {
          this.addQuestToTracker(data.quest);
        }
        
        // ‚úÖ RAFRA√éCHIR
        this.refreshActiveQuests();
      } else {
        this.notificationManager.error(
          data.message || "Impossible d'accepter la qu√™te",
          { duration: 4000 }
        );
      }
    });

    // ‚úÖ AUTRES LISTENERS EXISTANTS...
    this.setupAdditionalListeners();

    console.log("‚úÖ [QuestSystem] Listeners centralis√©s configur√©s");
  }

  // ‚úÖ === M√âTHODE DE SYNCHRONISATION CENTRALE ===
  syncAllComponents() {
    console.log("üîÑ [QuestSystem] Synchronisation de tous les composants");
    
    // ‚úÖ Synchroniser le Journal
    if (this.questJournal) {
      this.questJournal.activeQuests = this.activeQuests; // Mise √† jour directe
      this.questJournal.updateQuestList(this.activeQuests);
    }
    
    // ‚úÖ Synchroniser le Tracker
    if (this.questTracker) {
      this.questTracker.updateQuests(this.activeQuests);
    }
    
    // ‚úÖ Mettre √† jour l'ic√¥ne
    this.updateQuestIconState();
    
    console.log(`‚úÖ [QuestSystem] Synchronisation termin√©e (${this.activeQuests.length} qu√™tes actives)`);
  }

  // ‚úÖ === M√âTHODE POUR RAFRA√éCHIR LES QU√äTES ACTIVES ===
  refreshActiveQuests() {
    console.log("üîÑ [QuestSystem] Rafra√Æchissement des qu√™tes actives");
    if (this.gameRoom) {
      this.gameRoom.send("getActiveQuests");
    }
  }

  // ‚úÖ === LISTENERS ADDITIONNELS ===
  setupAdditionalListeners() {
    // Interaction NPC avec qu√™tes
    this.gameRoom.onMessage("npcInteractionResult", (data) => {
      this.handleNpcInteraction(data);
    });

    // ‚úÖ R√©compenses de qu√™te
    this.gameRoom.onMessage("questRewards", (data) => {
      this.showQuestRewards(data);
    });
  }

  // ‚úÖ Setup des timers pour le tracker (inchang√©)
  setupTrackerTimers() {
    // Timer pour mettre √† jour les qu√™tes avec limite de temps
    this.timerInterval = setInterval(() => {
      if (this.questTracker) {
        this.questTracker.updateQuestTimers();
      }
    }, 1000);

    // Timer pour mettre √† jour les distances des qu√™tes (si le joueur a boug√©)
    this.distanceInterval = setInterval(() => {
      if (this.questTracker && this.scene && this.scene.playerManager) {
        const player = this.scene.playerManager.getMyPlayer();
        if (player) {
          this.questTracker.updateQuestDistances(player.x, player.y);
        }
      }
    }, 2000);
  }

  // ‚úÖ === M√âTHODES DE GESTION DU TRACKER (am√©lior√©es) ===
  addQuestToTracker(quest) {
    if (!this.questTracker) return;
    
    console.log("üìä [QuestSystem] Ajout de qu√™te au tracker:", quest.name);
    
    // Enrichir la qu√™te avec des donn√©es suppl√©mentaires pour le tracker
    const enrichedQuest = {
      ...quest,
      level: quest.level || this.calculateQuestLevel(quest),
      distance: quest.targetLocation ? this.calculateQuestDistance(quest) : null,
      timeRemaining: quest.timeLimit || null
    };
    
    this.questTracker.onQuestAdded(enrichedQuest);
    this.updateQuestIconState();
  }

  // ‚úÖ Calculer le niveau d'une qu√™te (inchang√©)
  calculateQuestLevel(quest) {
    if (quest.difficulty) {
      const levelMap = { easy: '1-5', medium: '6-10', hard: '11-15', expert: '16+' };
      return levelMap[quest.difficulty] || '';
    }
    return '';
  }

  // ‚úÖ Calculer la distance d'une qu√™te (inchang√©)
  calculateQuestDistance(quest) {
    if (!quest.targetLocation || !this.scene?.playerManager) return null;
    
    const player = this.scene.playerManager.getMyPlayer();
    if (!player) return null;
    
    const dx = quest.targetLocation.x - player.x;
    const dy = quest.targetLocation.y - player.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // ‚úÖ Mettre √† jour l'√©tat de l'ic√¥ne (inchang√©)
  updateQuestIconState() {
    if (!this.questIcon) return;
    
    const hasActiveQuests = this.activeQuests.length > 0;
    this.questIcon.updateActiveQuestState(hasActiveQuests);
    
    // Compter les nouvelles qu√™tes ou qu√™tes pr√™tes √† √™tre termin√©es
    const newOrReadyQuests = this.activeQuests.filter(quest => 
      quest.isNew || quest.currentStepIndex >= quest.steps.length
    ).length;
    
    this.questIcon.updateNotificationCount(newOrReadyQuests);
  }

  // ‚úÖ Syst√®me de d√©duplication (inchang√©)
  shouldShowNotification(type, questId) {
    const key = `${type}_${questId}`;
    const now = Date.now();
    const lastTime = this.lastNotificationTime.get(key);
    
    if (!lastTime || (now - lastTime) > this.notificationCooldown) {
      this.lastNotificationTime.set(key, now);
      return true;
    }
    
    console.log(`üîï Notification d√©dupliqu√©e: ${key} (${now - lastTime}ms depuis la derni√®re)`);
    return false;
  }

  // ‚úÖ Gestion des mises √† jour de progression (am√©lior√©e pour coordination)
  handleQuestProgressUpdate(results) {
    if (!Array.isArray(results)) return;
    
    results.forEach(result => {
      if (result.questCompleted) {
        const questId = result.questId || 'unknown';
        if (this.shouldShowNotification('questCompleted', questId)) {
          this.questIcon.onQuestCompleted();
          
          this.notificationManager.questNotification(
            result.questId,
            'completed',
            {
              duration: 6000,
              bounce: true,
              sound: true,
              onClick: () => this.openQuestJournal()
            }
          );
          
          // ‚úÖ NOTIFIER LE TRACKER
          if (this.questTracker) {
            const quest = this.activeQuests.find(q => q.id === result.questId);
            if (quest) {
              quest.currentStepIndex = quest.steps.length;
              this.questTracker.onQuestCompleted(quest);
            }
          }
          
          // Afficher les r√©compenses si disponibles
          if (result.rewards && result.rewards.length > 0) {
            setTimeout(() => {
              this.showQuestRewards({ rewards: result.rewards });
            }, 1000);
          }
        }
      } else if (result.stepCompleted) {
        const stepId = `${result.questId || 'unknown'}_step`;
        if (this.shouldShowNotification('stepCompleted', stepId)) {
          this.questIcon.onQuestProgress();
          
          this.notificationManager.quest(
            `√âtape termin√©e !`,
            {
              duration: 3000,
              onClick: () => this.openQuestJournal()
            }
          );
          
          // ‚úÖ METTRE √Ä JOUR LE TRACKER
          if (this.questTracker) {
            const quest = this.activeQuests.find(q => q.id === result.questId);
            if (quest) {
              quest.currentStepIndex = result.newStepIndex || quest.currentStepIndex + 1;
              this.questTracker.onQuestUpdated(quest);
            }
          }
        }
      } else if (result.message) {
        if (this.shouldShowNotification('questProgress', result.message)) {
          this.notificationManager.info(result.message, { duration: 3000 });
          this.questIcon.onQuestProgress();
        }
      }
    });
    
    // ‚úÖ SYNCHRONISER TOUS LES COMPOSANTS APR√àS PROGRESSION
    this.updateQuestIconState();
  }

  // ‚úÖ === M√âTHODES D'INTERFACE (inchang√©es) ===
  openQuestJournal() {
    if (this.questJournal) {
      this.questJournal.show();
    }
  }

  closeQuestJournal() {
    if (this.questJournal) {
      this.questJournal.hide();
    }
  }

  toggleQuestJournal() {
    if (this.questJournal) {
      this.questJournal.toggle();
    }
  }

  showQuestTracker() {
    if (this.questTracker) {
      this.questTracker.show();
    }
  }

  hideQuestTracker() {
    if (this.questTracker) {
      this.questTracker.hide();
    }
  }

  toggleQuestTracker() {
    if (this.questTracker) {
      this.questTracker.toggle();
    }
  }

  showQuestIcon() {
    if (this.questIcon) {
      this.questIcon.show();
    }
  }

  hideQuestIcon() {
    if (this.questIcon) {
      this.questIcon.hide();
    }
  }

  // ‚úÖ === M√âTHODES POUR D√âCLENCHER DES √âV√âNEMENTS (inchang√©es) ===
  triggerCollectEvent(itemId, amount = 1) {
    if (this.gameRoom) {
      this.gameRoom.send("questProgress", {
        type: 'collect',
        itemId: itemId,
        amount: amount
      });
      
      const collectKey = `${itemId}_${amount}`;
      if (this.shouldShowNotification('itemCollect', collectKey)) {
        this.notificationManager.info(
          `Objet collect√©: ${itemId} x${amount}`,
          {
            duration: 2000,
            position: 'bottom-right',
            type: 'inventory'
          }
        );
      }
    }
  }

  triggerDefeatEvent(pokemonId) {
    if (this.gameRoom) {
      this.gameRoom.send("questProgress", {
        type: 'defeat',
        pokemonId: pokemonId
      });
      
      if (this.shouldShowNotification('pokemonDefeat', pokemonId)) {
        this.notificationManager.show(
          `Pok√©mon vaincu !`,
          {
            type: 'battle',
            duration: 2000,
            position: 'bottom-center'
          }
        );
      }
    }
  }

  triggerReachEvent(zoneId, x, y, map) {
    if (this.gameRoom) {
      this.gameRoom.send("questProgress", {
        type: 'reach',
        zoneId: zoneId,
        x: x,
        y: y,
        map: map
      });
      
      if (this.shouldShowNotification('zoneReach', zoneId)) {
        this.notificationManager.info(
          `Zone visit√©e: ${zoneId}`,
          {
            duration: 2000,
            position: 'top-center'
          }
        );
      }
    }
  }

  triggerDeliverEvent(npcId, itemId) {
    if (this.gameRoom) {
      this.gameRoom.send("questProgress", {
        type: 'deliver',
        npcId: npcId,
        targetId: itemId
      });
      
      const deliverKey = `${npcId}_${itemId}`;
      if (this.shouldShowNotification('itemDeliver', deliverKey)) {
        this.notificationManager.success(
          `Objet livr√©: ${itemId}`,
          {
            duration: 3000
          }
        );
      }
    }
  }

  // ‚úÖ === M√âTHODES DE CONFIGURATION DU TRACKER (inchang√©es) ===
  setMaxTrackedQuests(max) {
    if (this.questTracker) {
      this.questTracker.setMaxTrackedQuests(max);
    }
  }

  setTrackerPosition(x, y) {
    if (this.questTracker) {
      this.questTracker.setPosition(x, y);
    }
  }

  // ‚úÖ === M√âTHODES UTILITAIRES (inchang√©es) ===
  isQuestJournalOpen() {
    return this.questJournal ? this.questJournal.isVisible : false;
  }

  canPlayerInteract() {
    const questDialogOpen = document.querySelector('.quest-dialog-overlay') !== null;
    const chatOpen = typeof window.isChatFocused === 'function' ? window.isChatFocused() : false;
    const starterHudOpen = typeof window.isStarterHUDOpen === 'function' ? window.isStarterHUDOpen() : false;
    
    return !questDialogOpen && !chatOpen && !starterHudOpen;
  }

  // ‚úÖ === M√âTHODES DE DEBUG (inchang√©es) ===
  resetNotificationCooldowns() {
    this.lastNotificationTime.clear();
    console.log("üîÑ Cooldowns de notification r√©initialis√©s");
  }

  debugNotificationSystem() {
    console.log("üîç √âtat du syst√®me de d√©duplication des notifications:");
    console.log("- Cooldown actuel:", this.notificationCooldown, "ms");
    console.log("- Notifications en cooldown:", this.lastNotificationTime.size);
    
    if (this.lastNotificationTime.size > 0) {
      console.log("- D√©tails des cooldowns:");
      const now = Date.now();
      this.lastNotificationTime.forEach((time, key) => {
        const remaining = Math.max(0, this.notificationCooldown - (now - time));
        console.log(`  ${key}: ${remaining}ms restant`);
      });
    }

    if (this.notificationManager) {
      this.notificationManager.info(
        `Debug: ${this.lastNotificationTime.size} notifications en cooldown`,
        {
          duration: 3000,
          position: 'top-left'
        }
      );
    }
  }

  setNotificationCooldown(milliseconds) {
    const oldCooldown = this.notificationCooldown;
    this.notificationCooldown = milliseconds;
    
    console.log(`üîß Cooldown notification chang√©: ${oldCooldown}ms ‚Üí ${milliseconds}ms`);
    
    if (this.notificationManager) {
      this.notificationManager.info(
        `Cooldown mis √† jour: ${milliseconds}ms`,
        {
          duration: 2000,
          position: 'bottom-left'
        }
      );
    }
  }

  // ‚úÖ === GESTION DES √âV√âNEMENTS NPC (toutes les m√©thodes existantes conserv√©es) ===
  handleNpcInteraction(data) {
    console.log("üéØ Interaction NPC re√ßue:", data);
    
    if (window._questDialogActive) {
      console.log("‚ö†Ô∏è Dialog de qu√™te d√©j√† ouvert, interaction ignor√©e");
      return;
    }
    
    switch (data.type) {
      case 'questGiver':
        const parsedData = this.parseNpcQuestData(data);
        this.showQuestGiverDialog(parsedData);
        break;
        
      case 'questComplete':
        this.showQuestCompleteDialog(data);
        break;
        
      case 'questProgress':
        if (this.shouldShowNotification('questProgress', data.message)) {
          this.notificationManager.info(data.message, { duration: 3000 });
        }
        break;
        
      case 'shop':
        console.log("üõí Ouverture boutique:", data.shopId);
        break;
        
      case 'heal':
        this.notificationManager.success(data.message, { duration: 3000 });
        break;
        
      default:
        console.log(`‚ÑπÔ∏è Type d'interaction '${data.type}' d√©l√©gu√© √† BaseZoneScene`);
        break;
    }
  }

  parseNpcQuestData(data) {
    console.log("üîç Parsing NPC quest data:", data);
    
    try {
      let availableQuests = data.availableQuests || [];
      
      if (typeof availableQuests === 'string') {
        console.log("üìù Parsing string JSON:", availableQuests);
        availableQuests = JSON.parse(availableQuests);
      }
      
      if (!Array.isArray(availableQuests)) {
        console.warn("‚ö†Ô∏è availableQuests n'est pas un array:", typeof availableQuests);
        
        if (availableQuests.quests && Array.isArray(availableQuests.quests)) {
          availableQuests = availableQuests.quests;
        } else {
          availableQuests = [];
        }
      }

      const normalizedQuests = availableQuests.map(quest => this.normalizeQuestData(quest));
      
      console.log("‚úÖ Qu√™tes NPC pars√©es:", normalizedQuests);
      
      return {
        ...data,
        availableQuests: normalizedQuests
      };
      
    } catch (error) {
      console.error("‚ùå Erreur lors du parsing des qu√™tes NPC:", error);
      return {
        ...data,
        availableQuests: []
      };
    }
  }

  normalizeQuestData(quest) {
    try {
      if (typeof quest === 'string') {
        quest = JSON.parse(quest);
      }

      const normalized = {
        id: quest.id || `quest_${Date.now()}`,
        name: quest.name || 'Qu√™te sans nom',
        description: quest.description || 'Pas de description disponible',
        category: quest.category || 'side',
        level: quest.level || '',
        steps: []
      };

      if (quest.steps && Array.isArray(quest.steps)) {
        normalized.steps = quest.steps.map((step, index) => {
          try {
            if (typeof step === 'string') {
              step = JSON.parse(step);
            }
            
            return {
              id: step.id || `step_${index}`,
              name: step.name || `√âtape ${index + 1}`,
              description: step.description || 'Pas de description',
              rewards: step.rewards || []
            };
          } catch (err) {
            console.warn("‚ö†Ô∏è Erreur step:", err);
            return {
              id: `step_${index}`,
              name: `√âtape ${index + 1}`,
              description: 'Description non disponible',
              rewards: []
            };
          }
        });
      }

      return normalized;

    } catch (error) {
      console.error("‚ùå Erreur normalizeQuestData:", error, quest);
      return {
        id: 'error_quest',
        name: 'Qu√™te (Erreur)',
        description: 'Cette qu√™te n\'a pas pu √™tre charg√©e correctement.',
        category: 'error',
        steps: []
      };
    }
  }

  showQuestGiverDialog(data) {
    console.log("üí¨ Affichage dialogue qu√™te:", data);
    
    if (!data.availableQuests || data.availableQuests.length === 0) {
      console.log("‚ö†Ô∏è Aucune qu√™te disponible");
      return;
    }

    window._questDialogActive = true;

    const questDialog = this.createQuestDialog('Qu√™tes disponibles', data.availableQuests, (questId) => {
      this.startQuest(questId);
    });

    document.body.appendChild(questDialog);
  }

  showQuestCompleteDialog(data) {
    const message = data.message || "F√©licitations ! Vous avez termin√© une qu√™te !";
    
    window._questDialogActive = true;
    const completeDialog = this.createQuestCompleteDialog(message, data.questRewards);
    document.body.appendChild(completeDialog);
  }

  createQuestDialog(title, quests, onSelectQuest) {
    console.log("üé® Cr√©ation dialogue avec qu√™tes:", quests);
    
    const dialog = document.createElement('div');
    dialog.className = 'quest-dialog-overlay';
    
    const questsHTML = quests.map(quest => {
      const questName = quest.name || 'Qu√™te sans nom';
      const questDesc = quest.description || 'Pas de description';
      const questCategory = quest.category || 'side';
      const questLevel = quest.level ? `[${quest.level}]` : '';
      const firstStep = quest.steps && quest.steps[0] ? quest.steps[0] : null;
      
      console.log("üéØ G√©n√©ration HTML pour qu√™te:", questName);
      
      return `
        <div class="quest-option" data-quest-id="${quest.id}">
          <div class="quest-option-header">
            <strong>${questName} ${questLevel}</strong>
            <span class="quest-category ${questCategory}">${questCategory.toUpperCase()}</span>
          </div>
          <p class="quest-option-description">${questDesc}</p>
          ${firstStep ? `
            <div class="quest-option-steps">
              <strong>Premi√®re √©tape :</strong> ${firstStep.description || 'Non sp√©cifi√©e'}
            </div>
            ${firstStep.rewards && firstStep.rewards.length > 0 ? `
              <div class="quest-option-rewards">
                <strong>R√©compenses :</strong> 
                ${firstStep.rewards.map(r => this.formatReward(r)).join(', ')}
              </div>
            ` : ''}
          ` : `
            <div class="quest-option-steps">
              <strong>Premi√®re √©tape :</strong> Information non disponible
            </div>
          `}
        </div>
      `;
    }).join('');

    dialog.innerHTML = `
      <div class="quest-dialog">
        <div class="quest-dialog-header">
          <h3>${title}</h3>
          <button class="quest-dialog-close">‚úï</button>
        </div>
        <div class="quest-dialog-content">
          ${questsHTML}
        </div>
        <div class="quest-dialog-actions">
          <button class="quest-btn-cancel">Annuler</button>
          <button class="quest-btn-accept" disabled>Accepter</button>
        </div>
      </div>
    `;

    // S√©lection automatique si une seule qu√™te
    let defaultSelectedId = null;
    if (quests.length === 1) {
      const onlyOption = dialog.querySelector('.quest-option');
      const acceptBtn = dialog.querySelector('.quest-btn-accept');
      if (onlyOption && acceptBtn) {
        onlyOption.classList.add('selected');
        acceptBtn.disabled = false;
        defaultSelectedId = onlyOption.dataset.questId;
        setTimeout(() => {
          onlyOption.focus();
          acceptBtn.focus();
        }, 0);
      }
    }

    this.styleQuestDialog(dialog);
    this.addQuestDialogListeners(dialog, onSelectQuest, defaultSelectedId);

    return dialog;
  }

  addQuestDialogListeners(dialog, onSelectQuest, defaultSelectedId = null) {
    let selectedQuestId = defaultSelectedId;

    const closeBtn = dialog.querySelector('.quest-dialog-close');
    const cancelBtn = dialog.querySelector('.quest-btn-cancel');
    const acceptBtn = dialog.querySelector('.quest-btn-accept');

    if (defaultSelectedId && acceptBtn) {
      acceptBtn.disabled = false;
    }

    const closeDialog = () => {
      dialog.remove();
      window._questDialogActive = false;
      console.log("üìã Dialogue de qu√™te ferm√©");
    };

    if (closeBtn) {
      closeBtn.addEventListener('click', closeDialog);
    }
    if (cancelBtn) {
      cancelBtn.addEventListener('click', closeDialog);
    }

    // S√©lection des qu√™tes
    dialog.querySelectorAll('.quest-option').forEach(option => {
      option.addEventListener('click', () => {
        dialog.querySelectorAll('.quest-option').forEach(opt => 
          opt.classList.remove('selected')
        );
        option.classList.add('selected');
        selectedQuestId = option.dataset.questId;
        acceptBtn.disabled = false;
        
        console.log(`üìã Qu√™te s√©lectionn√©e: ${selectedQuestId}`);
      });
    });

    const acceptQuest = () => {
      if (!selectedQuestId && defaultSelectedId) {
        selectedQuestId = defaultSelectedId;
      }
      if (!selectedQuestId) {
        const selectedOption = dialog.querySelector('.quest-option.selected') || dialog.querySelector('.quest-option');
        if (selectedOption) {
          selectedQuestId = selectedOption.dataset.questId;
        }
      }
      
      console.log("üéØ Acceptation de la qu√™te:", selectedQuestId);
      
      if (selectedQuestId && onSelectQuest) {
        onSelectQuest(selectedQuestId);
      }
      closeDialog();
    };

    acceptBtn.addEventListener('click', acceptQuest);

    // Gestion clavier
    const handleKeydown = (e) => {
      if (!dialog || !dialog.parentNode) {
        document.removeEventListener('keydown', handleKeydown);
        return;
      }

      console.log(`‚å®Ô∏è Touche press√©e dans dialogue qu√™te: ${e.key}`);

      switch (e.key) {
        case 'Escape':
          e.preventDefault();
          e.stopPropagation();
          closeDialog();
          break;
          
        case 'Enter':
        case 'e':
        case 'E':
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedQuestId || defaultSelectedId) {
            console.log(`‚úÖ Acceptation via ${e.key}: ${selectedQuestId || defaultSelectedId}`);
            acceptQuest();
          } else {
            const firstOption = dialog.querySelector('.quest-option');
            if (firstOption) {
              firstOption.click();
            }
          }
          break;
          
        case 'ArrowUp':
        case 'ArrowDown':
          e.preventDefault();
          e.stopPropagation();
          this.navigateQuestOptions(dialog, e.key === 'ArrowDown' ? 1 : -1);
          break;
      }
    };

    document.addEventListener('keydown', handleKeydown);
    dialog.tabIndex = -1;
    dialog.focus();

    console.log(`üìã Event listeners configur√©s pour dialogue qu√™te (selectedId: ${selectedQuestId})`);
  }

  navigateQuestOptions(dialog, direction) {
    const options = dialog.querySelectorAll('.quest-option');
    if (options.length === 0) return;

    let currentIndex = -1;
    options.forEach((option, index) => {
      if (option.classList.contains('selected')) {
        currentIndex = index;
      }
    });

    let newIndex = currentIndex + direction;
    if (newIndex < 0) newIndex = options.length - 1;
    if (newIndex >= options.length) newIndex = 0;

    options[newIndex].click();
  }

  startQuest(questId) {
    console.log("üéØ D√©marrage de la qu√™te:", questId);
    
    if (this.gameRoom) {
      this.gameRoom.send("startQuest", { questId });
      console.log("üì§ Message startQuest envoy√© au serveur");
    } else {
      console.error("‚ùå Pas de gameRoom pour envoyer startQuest");
    }
  }

  styleQuestDialog(dialog) {
    const style = document.createElement('style');
    if (!document.querySelector('#quest-dialog-styles')) {
      style.id = 'quest-dialog-styles';
      style.textContent = `
        .quest-dialog-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1050;
          backdrop-filter: blur(5px);
        }

        .quest-dialog {
          background: linear-gradient(145deg, rgba(25, 35, 55, 0.98), rgba(35, 45, 65, 0.98));
          border: 2px solid rgba(100, 149, 237, 0.8);
          border-radius: 15px;
          max-width: 500px;
          max-height: 70vh;
          width: 90%;
          color: white;
          font-family: Arial, sans-serif;
          overflow: hidden;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }

        .quest-dialog-header {
          background: rgba(100, 149, 237, 0.2);
          padding: 15px 20px;
          border-bottom: 1px solid rgba(100, 149, 237, 0.3);
          display: flex;
          justify-content: space-between;
          align-items: center;
        }

        .quest-dialog-header h3 {
          margin: 0;
          font-size: 18px;
        }

        .quest-dialog-close {
          background: none;
          border: none;
          color: white;
          font-size: 20px;
          cursor: pointer;
          width: 30px;
          height: 30px;
          border-radius: 50%;
          background: rgba(220, 53, 69, 0.8);
        }

        .quest-dialog-close:hover {
          background: rgba(220, 53, 69, 1);
        }

        .quest-dialog-content {
          max-height: 300px;
          overflow-y: auto;
          padding: 20px;
        }

        .quest-option {
          background: rgba(255, 255, 255, 0.05);
          border-radius: 8px;
          padding: 15px;
          margin-bottom: 10px;
          cursor: pointer;
          transition: all 0.3s ease;
          border: 2px solid transparent;
        }

        .quest-option:hover {
          background: rgba(100, 149, 237, 0.1);
          border-color: rgba(100, 149, 237, 0.3);
        }

        .quest-option.selected {
          border-color: #64b5f6;
          background: rgba(100, 149, 237, 0.2);
        }

        .quest-option-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        }

        .quest-category {
          padding: 2px 8px;
          border-radius: 12px;
          font-size: 10px;
          font-weight: bold;
        }

        .quest-category.main { background: rgba(255, 193, 7, 0.3); color: #ffc107; }
        .quest-category.side { background: rgba(40, 167, 69, 0.3); color: #28a745; }
        .quest-category.daily { background: rgba(220, 53, 69, 0.3); color: #dc3545; }

        .quest-option-description {
          font-size: 14px;
          color: #ccc;
          margin-bottom: 8px;
          line-height: 1.4;
        }

        .quest-dialog-actions {
          padding: 15px 20px;
          border-top: 1px solid rgba(100, 149, 237, 0.3);
          display: flex;
          gap: 10px;
          justify-content: flex-end;
        }

        .quest-btn-cancel,
        .quest-btn-accept {
          padding: 10px 20px;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
          transition: all 0.3s ease;
        }

        .quest-btn-cancel {
          background: rgba(108, 117, 125, 0.3);
          color: #ccc;
        }

        .quest-btn-accept {
          background: rgba(40, 167, 69, 0.8);
          color: white;
        }

        .quest-btn-accept:disabled {
          background: rgba(108, 117, 125, 0.3);
          cursor: not-allowed;
        }

        .quest-btn-cancel:hover {
          background: rgba(108, 117, 125, 0.5);
        }

        .quest-btn-accept:hover:not(:disabled) {
          background: rgba(40, 167, 69, 1);
        }
      `;
      document.head.appendChild(style);
    }
  }

  formatReward(reward) {
    try {
      if (typeof reward === 'string') {
        reward = JSON.parse(reward);
      }
      
      const type = reward.type || 'unknown';
      const amount = reward.amount || 1;
      
      switch (type) {
        case 'gold':
          return `üí∞ ${amount} pi√®ces`;
        case 'item':
          const itemId = reward.itemId || reward.item || 'Objet inconnu';
          return `üì¶ ${itemId} x${amount}`;
        case 'pokemon':
          return `üéÅ Pok√©mon sp√©cial`;
        case 'experience':
          return `‚≠ê ${amount} XP`;
        default:
          return `üéÅ R√©compense (${type})`;
      }
    } catch (error) {
      console.warn("‚ö†Ô∏è Erreur formatReward:", error, reward);
      return `üéÅ R√©compense`;
    }
  }

  showQuestRewards(data) {
    if (data.rewards && data.rewards.length > 0) {
      window._questDialogActive = true;
      
      const rewardText = data.rewards.map(r => this.formatReward(r)).join(', ');
      
      if (this.shouldShowNotification('questRewards', rewardText)) {
        this.notificationManager.achievement(
          `R√©compenses re√ßues : ${rewardText}`,
          {
            duration: 8000,
            persistent: false,
            bounce: true,
            sound: true
          }
        );
      }
      
      const dialog = this.createQuestCompleteDialog(
        data.message || "R√©compenses re√ßues !",
        data.rewards
      );
      document.body.appendChild(dialog);
    }
  }

  createQuestCompleteDialog(message, rewards) {
    const dialog = document.createElement('div');
    dialog.className = 'quest-dialog-overlay';
    dialog.innerHTML = `
      <div class="quest-dialog quest-complete-dialog">
        <div class="quest-dialog-header">
          <h3>üéâ Qu√™te termin√©e !</h3>
        </div>
        <div class="quest-dialog-content">
          <p class="quest-complete-message">${message}</p>
          ${rewards && rewards.length > 0 ? `
            <div class="quest-complete-rewards">
              <h4>R√©compenses re√ßues :</h4>
              ${rewards.map(reward => `
                <div class="quest-reward-item">
                  ${this.formatReward(reward)}
                </div>
              `).join('')}
            </div>
          ` : ''}
        </div>
        <div class="quest-dialog-actions">
          <button class="quest-btn-accept">Continuer</button>
        </div>
      </div>
    `;

    this.styleQuestDialog(dialog);
    
    setTimeout(() => {
      if (dialog.parentNode) {
        dialog.remove();
        window._questDialogActive = false;
      }
    }, 5000);

    dialog.querySelector('.quest-btn-accept').addEventListener('click', () => {
      dialog.remove();
      window._questDialogActive = false;
    });
    
    return dialog;
  }

  // ‚úÖ === M√âTHODES DE NETTOYAGE ET DESTRUCTION ===
  destroy() {
    console.log("üíÄ Destruction du syst√®me de qu√™tes");
    
    // ‚úÖ Nettoyer les timers
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    
    if (this.distanceInterval) {
      clearInterval(this.distanceInterval);
      this.distanceInterval = null;
    }
    
    // Nettoyer les composants UI
    if (this.questIcon) {
      this.questIcon.destroy();
      this.questIcon = null;
    }
    
    if (this.questTracker) {
      this.questTracker.destroy();
      this.questTracker = null;
    }
    
    if (this.questJournal) {
      // Le QuestJournalUI n'a pas de m√©thode destroy, on le cache
      this.questJournal.hide();
      this.questJournal = null;
    }
    
    // Nettoyer les donn√©es
    this.activeQuests = [];
    this.availableQuests = [];
    this.lastNotificationTime.clear();
    
    console.log("‚úÖ Syst√®me de qu√™tes d√©truit");
  }
}
