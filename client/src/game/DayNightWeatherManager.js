// DayNightWeatherManager.js - VERSION SYNCHRONISATION AUTOMATIQUE
import { ClientTimeWeatherManager } from '../managers/ClientTimeWeatherManager.js';
import { zoneEnvironmentManager } from '../managers/ZoneEnvironmentManager.js';
import { WeatherEffects } from '../effects/WeatherEffects.js';

export class OptimizedPhaserOverlayManager {
  constructor(scene) {
    this.scene = scene;
    
    // ‚úÖ NOUVEAU: Marquer l'heure de d√©marrage
    this.startTime = Date.now();
    
    // ‚úÖ CORRECTION: V√©rifier si la sc√®ne existe pour √©viter les erreurs
    if (!scene) {
      console.warn('üå§Ô∏è [PhaserOverlay] Cr√©√© sans sc√®ne - mode global');
      this.globalMode = true;
    } else {
      this.globalMode = false;
    }
    
    this.combinedOverlay = null;
    this.colorCache = new Map();
    this.lastCombinedState = null;
    this.activeTween = null;
    this.performanceMode = this.detectPerformanceLevel();
    
    // ‚úÖ NOUVEAU: Anti-spam avec d√©bouncing
    this.pendingUpdate = null;
    this.updateTimer = null;
    this.debugMode = false;
    
    // ‚úÖ NOUVEAU: Mode transition rapide
    this.fastTransitionMode = false;
    
    console.log(`üé® [PhaserOverlay] Initialis√© (Mode: ${this.performanceMode}, Global: ${this.globalMode})`);
  }

  detectPerformanceLevel() {
    // ‚úÖ CORRECTION: G√©rer le cas o√π scene est null
    if (!this.scene || !this.scene.sys) {
      // Mode global - utiliser des valeurs par d√©faut
      const factors = {
        webgl: 1.0, // Assumer WebGL disponible
        memory: navigator.deviceMemory || 4,
        cores: navigator.hardwareConcurrency || 4,
        mobile: /Mobi|Android/i.test(navigator.userAgent) ? 0.6 : 1.0
      };
      
      const score = factors.webgl * Math.min(factors.memory / 4, 2) * Math.min(factors.cores / 4, 2) * factors.mobile;
      
      if (score >= 1.5) return 'high';
      if (score >= 1.0) return 'medium';
      return 'low';
    }
    
    // Mode normal avec sc√®ne
    const game = this.scene.sys.game;
    const renderer = game.renderer;
    
    const factors = {
      webgl: renderer.type === Phaser.WEBGL ? 1.0 : 0.7,
      memory: navigator.deviceMemory || 4,
      cores: navigator.hardwareConcurrency || 4,
      mobile: /Mobi|Android/i.test(navigator.userAgent) ? 0.6 : 1.0
    };
    
    const score = factors.webgl * Math.min(factors.memory / 4, 2) * Math.min(factors.cores / 4, 2) * factors.mobile;
    
    if (score >= 1.5) return 'high';
    if (score >= 1.0) return 'medium';
    return 'low';
  }

  initialize() {
    console.log(`üé® [PhaserOverlay] Initialisation overlay manager...`);
    
    if (this.globalMode) {
      console.log(`üåç [PhaserOverlay] Mode global - pas d'overlay direct`);
    } else {
      this.createCombinedOverlay();
    }
    
    this.precacheCommonColors();
    
    console.log(`‚úÖ [PhaserOverlay] Overlay manager initialis√©`);
  }

  createCombinedOverlay() {
    // ‚úÖ CORRECTION: Ne pas cr√©er d'overlay en mode global
    if (this.globalMode || !this.scene) {
      console.log(`üå§Ô∏è [PhaserOverlay] Mode global - pas d'overlay direct`);
      return;
    }
    
    const camera = this.scene.cameras.main;
    
    this.combinedOverlay = this.scene.add.rectangle(
      camera.centerX,
      camera.centerY,
      camera.width,
      camera.height,
      0x000044,
      0
    );
    
    this.combinedOverlay.setDepth(9998);
    this.combinedOverlay.setScrollFactor(0);
    this.combinedOverlay.setOrigin(0.5, 0.5);
    this.combinedOverlay.setInteractive(false);
    
    console.log(`üåô [PhaserOverlay] Overlay combin√© cr√©√©`);
  }

  precacheCommonColors() {
    const commonColors = {
      'day-clear-outdoor': { color: 0x000044, alpha: 0 },
      'day-rain-outdoor': { color: 0x000044, alpha: 0.2 },
      'day-storm-outdoor': { color: 0x333366, alpha: 0.25 },
      'day-snow-outdoor': { color: 0xCCDDFF, alpha: 0.03 },
      'day-fog-outdoor': { color: 0xCCCCCC, alpha: 0.08 },
      
      'night-clear-outdoor': { color: 0x000044, alpha: 0.25 },
      'night-rain-outdoor': { color: 0x000044, alpha: 0.4 },
      'night-storm-outdoor': { color: 0x333366, alpha: 0.5 },
      'night-snow-outdoor': { color: 0x334466, alpha: 0.3 },
      'night-fog-outdoor': { color: 0xCCCCCC, alpha: 0.4 },
      
      'cave': { color: 0x2D1B0E, alpha: 0.4 },
      'indoor': { color: 0x000044, alpha: 0 }
    };
    
    Object.entries(commonColors).forEach(([key, value]) => {
      this.colorCache.set(key, value);
    });
    
    console.log(`üé® [PhaserOverlay] ${this.colorCache.size} couleurs combin√©es en cache`);
  }

  // ‚úÖ UPDATE COMBIN√â CORRIG√â - PAS DE SKIP PENDANT LES PREMI√àRES SECONDES
  updateCombined(isDayTime, weather, environment = 'outdoor', zoneName = null) {
    if (!this.combinedOverlay) return;
    
    // ‚úÖ Normaliser zoneName pour √©viter les oscillations
    const normalizedZone = this.normalizeZoneName(zoneName);
    const timeState = isDayTime ? 'day' : 'night';
    const stateKey = `${timeState}-${weather}-${environment}-${normalizedZone}`;
    
    console.log(`üé® [PhaserOverlay] Update: ${stateKey}`);
    
    // ‚úÖ PAS DE SKIP PENDANT LES PREMI√àRES SECONDES pour garantir l'application
    const isEarlyStage = Date.now() - this.startTime < 10000; // 10 secondes
    
    if (!isEarlyStage && this.lastCombinedState === stateKey) {
      if (this.debugMode) {
        console.log(`‚ö° [PhaserOverlay] Skip identique: ${stateKey}`);
      }
      return;
    }
    
    // ‚úÖ CALCULER couleur et alpha selon les conditions
    let targetColor = 0x000044;
    let targetAlpha = 0;
    
    // ‚úÖ EFFETS DE NUIT
    if (!isDayTime) {
      targetColor = 0x000044;
      targetAlpha = 0.25; // Nuit r√©duite
      console.log(`üåô [PhaserOverlay] Effet nuit: alpha ${targetAlpha}`);
    }
    
    // ‚úÖ EFFETS M√âT√âO
    if (weather === 'rain') {
      targetAlpha = Math.max(targetAlpha, 0.2);
      if (!isDayTime) targetAlpha = Math.max(targetAlpha, 0.4);
      console.log(`üåßÔ∏è [PhaserOverlay] Effet pluie: alpha ${targetAlpha}`);
    } else if (weather === 'storm') {
      targetColor = 0x333366;
      targetAlpha = Math.max(targetAlpha, 0.25);
      if (!isDayTime) targetAlpha = Math.max(targetAlpha, 0.5);
      console.log(`‚õàÔ∏è [PhaserOverlay] Effet orage: alpha ${targetAlpha}`);
    } else if (weather === 'snow') {
      targetColor = isDayTime ? 0xCCDDFF : 0x334466;
      targetAlpha = Math.max(targetAlpha, 0.03);
      if (!isDayTime) targetAlpha = Math.max(targetAlpha, 0.3);
      console.log(`‚ùÑÔ∏è [PhaserOverlay] Effet neige: alpha ${targetAlpha}`);
    } else if (weather === 'fog') {
      targetColor = 0xCCCCCC;
      targetAlpha = Math.max(targetAlpha, 0.08);
      if (!isDayTime) targetAlpha = Math.max(targetAlpha, 0.4);
      console.log(`üå´Ô∏è [PhaserOverlay] Effet brouillard: alpha ${targetAlpha}`);
    }
    
    // ‚úÖ EFFETS SP√âCIAUX POUR ENVIRONNEMENTS
    if (environment === 'cave') {
      targetColor = 0x2D1B0E;
      targetAlpha = 0.4;
      console.log(`üèîÔ∏è [PhaserOverlay] Effet grotte: alpha ${targetAlpha}`);
    } else if (environment === 'indoor') {
      targetColor = 0x000044;
      targetAlpha = 0;
      console.log(`üè† [PhaserOverlay] Int√©rieur: pas d'overlay`);
    }
    
    // ‚úÖ MISE √Ä JOUR DE L'√âTAT
    this.lastCombinedState = stateKey;
    console.log(`üé® [PhaserOverlay] ${stateKey} ‚Üí couleur: 0x${targetColor.toString(16)}, alpha: ${targetAlpha}`);
    
    // ‚úÖ APPLICATION IMM√âDIATE
    this.combinedOverlay.setFillStyle(targetColor);
    this.combinedOverlay.setAlpha(targetAlpha);
    
    if (targetAlpha > 0) {
      this.combinedOverlay.setVisible(true);
    } else {
      this.combinedOverlay.setVisible(false);
    }
    
    // ‚úÖ ARR√äTER tout tween en cours pour √©viter les conflits
    if (this.activeTween) {
      this.activeTween.stop();
      this.activeTween = null;
    }
  }

  // ‚úÖ NOUVELLE M√âTHODE: Normaliser le zoneName
  normalizeZoneName(zoneName) {
    if (!zoneName || zoneName === 'null' || zoneName === 'undefined') {
      const sceneZone = this.scene?.zoneName || this.scene?.scene?.key;
      if (sceneZone && sceneZone !== 'null' && sceneZone !== 'undefined') {
        return sceneZone;
      }
      return 'default';
    }
    return zoneName;
  }

  // ‚úÖ API PUBLIQUE avec application directe
  setDayNight(isDayTime, environment = 'outdoor', zoneName = null) {
    const currentWeather = this.lastWeather || 'clear';
    this.lastIsDayTime = isDayTime;
    this.updateCombined(isDayTime, currentWeather, environment, zoneName);
  }

  setWeather(weather, environment = 'outdoor') {
    this.lastWeather = weather;
    const currentTime = this.lastIsDayTime !== undefined ? this.lastIsDayTime : true;
    this.updateCombined(currentTime, weather, environment);
  }

  forceUpdate(isDayTime, weather, environment = 'outdoor', zoneName = null) {
    console.log(`üîÑ [PhaserOverlay] Force update avec reset`);
    
    // ‚úÖ RESET de l'√©tat pour forcer
    this.lastCombinedState = null;
    this.lastWeather = weather;
    this.lastIsDayTime = isDayTime;
    
    // ‚úÖ Update imm√©diat
    this.updateCombined(isDayTime, weather, environment, zoneName);
  }

  setDebugMode(enabled) {
    this.debugMode = enabled;
    console.log(`üîß [PhaserOverlay] Debug mode: ${enabled ? 'ON' : 'OFF'}`);
  }

  onCameraResize() {
    const camera = this.scene.cameras.main;
    
    if (this.combinedOverlay) {
      this.combinedOverlay.setPosition(camera.centerX, camera.centerY);
      this.combinedOverlay.setSize(camera.width, camera.height);
    }
    
    console.log(`üìê [PhaserOverlay] Overlay redimensionn√©: ${camera.width}x${camera.height}`);
  }

  debug() {
    console.log(`üîç [PhaserOverlay] === DEBUG OVERLAY OPTIMIS√â ===`);
    console.log(`‚ö° Mode: ${this.performanceMode}`);
    console.log(`üé¨ Tween actif: ${this.activeTween ? 'OUI' : 'NON'}`);
    console.log(`üé® √âtat actuel: ${this.lastCombinedState}`);
    console.log(`üîß Debug mode: ${this.debugMode}`);
    console.log(`‚è∞ Temps depuis d√©marrage: ${Date.now() - this.startTime}ms`);
    
    if (this.combinedOverlay) {
      console.log(`üåô Overlay: alpha=${this.combinedOverlay.alpha.toFixed(3)}, visible=${this.combinedOverlay.visible}`);
      console.log(`üé® Couleur: 0x${this.combinedOverlay.fillColor.toString(16)}`);
    }
  }

  destroy() {
    console.log(`üßπ [PhaserOverlay] Destruction optimis√©e...`);
    
    if (this.activeTween) {
      this.activeTween.stop();
      this.activeTween = null;
    }
    
    if (this.combinedOverlay) {
      this.combinedOverlay.destroy();
      this.combinedOverlay = null;
    }
    
    this.colorCache.clear();
    this.lastCombinedState = null;
    
    console.log(`‚úÖ [PhaserOverlay] D√©truit`);
  }
}

// ‚úÖ MANAGER PRINCIPAL AVEC SYNCHRONISATION AUTOMATIQUE
export class DayNightWeatherManagerPhaser {
  constructor(scene) {
    this.scene = scene;
    this.globalMode = !scene;
    this.overlayManager = null;
    this.timeWeatherManager = null;
    this.weatherEffects = null;
    this.isInitialized = false;
    
    console.log(`üåÖ [DayNightWeatherManagerPhaser] Cr√©√© (Global: ${this.globalMode})`);
    
    // ‚úÖ CORRECTION: Pas de WeatherEffects en mode global
    if (this.globalMode) {
      this.weatherEffects = null;
    }
  }

  initialize(networkManager) {
    if (this.isInitialized) return;

    console.log(`üåÖ [DayNightWeatherManagerPhaser] === INIT SYNCHRONISATION AUTOMATIQUE ===`);
    
    try {
      this.timeWeatherManager = new ClientTimeWeatherManager(this.scene);
      this.timeWeatherManager.initialize(networkManager);

      this.overlayManager = new OptimizedPhaserOverlayManager(this.scene);
      this.overlayManager.initialize();

      // ‚úÖ CORRECTION: Pas de WeatherEffects en mode global
      if (!this.globalMode && this.scene) {
        this.weatherEffects = new WeatherEffects(this.scene);
      }

      this.setupCallbacks();
      
      this.isInitialized = true;
      console.log(`‚úÖ [DayNightWeatherManagerPhaser] Initialis√© (SYNCHRONISATION AUTOMATIQUE)`);
      
    } catch (error) {
      console.error(`‚ùå [DayNightWeatherManagerPhaser] Erreur:`, error);
    }
  }

  // ‚úÖ CALLBACKS DIRECTS SANS D√âBOUNCING
  setupCallbacks() {
    // ‚úÖ CALLBACKS DIRECTS SANS D√âBOUNCING pour √©viter les pertes
    this.timeWeatherManager.onTimeChange((hour, isDayTime) => {
      console.log(`üïê [DayNightWeatherManagerPhaser] Temps re√ßu: ${hour}h ${isDayTime ? 'JOUR' : 'NUIT'}`);
      this.handleTimeChange(hour, isDayTime);
    });

    this.timeWeatherManager.onWeatherChange((weather, displayName) => {
      console.log(`üå§Ô∏è [DayNightWeatherManagerPhaser] M√©t√©o re√ßue: ${displayName}`);
      this.handleWeatherChange(weather, displayName);
    });
  }

  // ‚úÖ HANDLERS DIRECTS
  handleTimeChange(hour, isDayTime) {
    const currentZone = this.getCurrentZone();
    const environment = zoneEnvironmentManager.getZoneEnvironment(currentZone);
    
    console.log(`üåÖ [DayNightWeatherManagerPhaser] Application temps: ${hour}h ${isDayTime ? 'JOUR' : 'NUIT'} (${environment})`);
    
    this.overlayManager.setDayNight(isDayTime, environment, currentZone);
  }

  handleWeatherChange(weather, displayName) {
    const currentZone = this.getCurrentZone();
    const environment = zoneEnvironmentManager.getZoneEnvironment(currentZone);
    
    console.log(`üå§Ô∏è [DayNightWeatherManagerPhaser] Application m√©t√©o: ${displayName} (${environment})`);
    
    this.overlayManager.setWeather(weather, environment);
    
    if (this.weatherEffects) {
      this.weatherEffects.setEnvironmentType(environment);
      this.weatherEffects.setWeather(weather);
    }
  }

  getCurrentZone() {
    let zoneName = this.scene?.zoneName || this.scene?.scene?.key || 'unknown';
    
    if (!zoneName || zoneName === 'null' || zoneName === 'undefined') {
      zoneName = 'default';
    }
    
    return zoneName;
  }

  forceUpdate() {
    if (!this.isInitialized) return;

    const time = this.timeWeatherManager.getCurrentTime();
    const weather = this.timeWeatherManager.getCurrentWeather();
    const currentZone = this.getCurrentZone();
    const environment = zoneEnvironmentManager.getZoneEnvironment(currentZone);

    console.log(`üîÑ [DayNightWeatherManagerPhaser] Force update direct`);
    
    this.overlayManager.forceUpdate(time.isDayTime, weather.weather, environment, currentZone);
  }

  forceUpdateWithState(isDayTime, weather, environment, zoneName) {
    if (!this.isInitialized) return;
    
    console.log(`üîß [DayNightWeatherManagerPhaser] Force update avec √©tat sp√©cifique:`, {
      isDayTime, weather, environment, zoneName
    });
    
    this.overlayManager.forceUpdate(isDayTime, weather, environment, zoneName);
    
    if (this.weatherEffects) {
      this.weatherEffects.setEnvironmentType(environment);
      this.weatherEffects.setWeather(weather);
    }
  }

  onZoneChanged(newZoneName) {
    console.log(`üåç [DayNightWeatherManagerPhaser] Zone chang√©e: ${newZoneName}`);
    
    // ‚úÖ Application imm√©diate avec l'√©tat actuel
    this.forceImmediateWeatherApplication(newZoneName);
  }

  forceImmediateWeatherApplication(newZoneName) {
    if (!this.isInitialized) {
      console.warn(`‚ö†Ô∏è [DayNightWeatherManagerPhaser] Service pas initialis√©`);
      return;
    }
    
    console.log(`‚ö° [DayNightWeatherManagerPhaser] APPLICATION IMM√âDIATE pour: ${newZoneName}`);
    
    // ‚úÖ V√âRIFIER SI ON EST DANS UNE ZONE OUTDOOR
    const environment = zoneEnvironmentManager.getZoneEnvironment(newZoneName);
    
    if (environment === 'outdoor') {
      console.log(`üåç [DayNightWeatherManagerPhaser] Zone outdoor d√©tect√©e`);
      
      // ‚úÖ FORCER L'OVERLAY √Ä RESTER CORRECT POUR LES ZONES OUTDOOR
      if (this.overlayManager && this.overlayManager.combinedOverlay) {
        this.overlayManager.lastCombinedState = null; // Reset pour forcer l'application
      }
    }
    
    // ‚úÖ R√©cup√©rer l'√©tat actuel et appliquer
    const currentTime = this.timeWeatherManager.getCurrentTime();
    const currentWeather = this.timeWeatherManager.getCurrentWeather();
    
    if (this.overlayManager) {
      this.overlayManager.forceUpdate(
        currentTime.isDayTime, 
        currentWeather.weather, 
        environment, 
        newZoneName
      );
    }
    
    // ‚úÖ Effets m√©t√©o aussi
    if (this.weatherEffects) {
      this.weatherEffects.setEnvironmentType(environment);
      this.weatherEffects.setWeather(currentWeather.weather);
    }
    
    console.log(`‚úÖ [DayNightWeatherManagerPhaser] Application imm√©diate termin√©e`);
  }

  onCameraResize() {
    if (this.overlayManager) {
      this.overlayManager.onCameraResize();
    }
  }

  setDebugMode(enabled) {
    if (this.overlayManager) {
      this.overlayManager.setDebugMode(enabled);
    }
    console.log(`üîß [DayNightWeatherManagerPhaser] Debug mode: ${enabled ? 'ON' : 'OFF'}`);
  }

  debug() {
    console.log(`üîç [DayNightWeatherManagerPhaser] === DEBUG SYNCHRONISATION AUTOMATIQUE ===`);
    
    if (this.overlayManager) {
      this.overlayManager.debug();
    }
    
    if (this.weatherEffects) {
      this.weatherEffects.debug();
    }
  }

  destroy() {
    console.log(`üßπ [DayNightWeatherManagerPhaser] Destruction...`);
    
    if (this.overlayManager) {
      this.overlayManager.destroy();
    }
    
    if (this.weatherEffects) {
      this.weatherEffects.destroy();
    }
    
    if (this.timeWeatherManager) {
      this.timeWeatherManager.destroy();
    }
    
    console.log(`‚úÖ [DayNightWeatherManagerPhaser] D√©truit`);
  }
}

export { DayNightWeatherManagerPhaser as DayNightWeatherManager };

// =====================================
// V√âRIFICATION P√âRIODIQUE GLOBALE
// =====================================

// V√©rification p√©riodique pour s'assurer que la synchronisation reste active
if (typeof window !== 'undefined') {
  setInterval(() => {
    if (window.checkTimeWeatherSync) {
      window.checkTimeWeatherSync();
    }
  }, 60000); // V√©rification toutes les minutes
  
  console.log('‚úÖ [DayNightWeatherManager] V√©rification p√©riodique activ√©e (1 minute)');
}
