// server/src/quest/services/QuestDeliveryDetector.ts
// Service de d√©tection automatique des livraisons de qu√™te lors d'interaction NPC

import { 
  QuestDefinition, 
  QuestObjective,
  Quest
} from "../core/types/QuestTypes";

import { InventoryManager } from "../../managers/InventoryManager";

// ===== TYPES POUR LE SYST√àME DE LIVRAISON =====

/**
 * üéØ Objectif de livraison d√©tect√©
 */
export interface DeliveryObjective {
  questId: string;
  questName: string;
  stepIndex: number;
  stepName: string;
  objectiveId: string;
  objectiveDescription: string;
  
  // Donn√©es de l'item √† livrer
  itemId: string;
  itemName: string;
  requiredAmount: number;
  playerHasAmount: number;
  canDeliver: boolean;
  
  // M√©tadonn√©es
  isCompleted: boolean;
  npcId: string;
}

/**
 * üéØ R√©sultat de d√©tection de livraisons
 */
export interface DeliveryDetectionResult {
  hasDeliveries: boolean;
  npcId: string;
  npcName?: string;
  
  // Livraisons disponibles
  deliveries: DeliveryObjective[];
  
  // √âtats globaux
  allItemsAvailable: boolean;
  totalDeliveries: number;
  readyDeliveries: number;
  
  // M√©tadonn√©es
  detectionTime: number;
  lastUpdated: Date;
}

/**
 * üéØ Configuration du d√©tecteur
 */
export interface QuestDeliveryDetectorConfig {
  enableCaching: boolean;
  cacheTTL: number; // en millisecondes
  enableLogging: boolean;
  strictValidation: boolean;
  maxDetectionTime: number; // timeout en ms
  enableInventoryValidation: boolean;
}

// ===== CLASSE PRINCIPALE =====

/**
 * üéØ D√©tecteur de livraisons de qu√™te
 * 
 * Analyse les qu√™tes actives d'un joueur pour d√©tecter automatiquement
 * les livraisons possibles lors d'une interaction avec un NPC.
 */
export class QuestDeliveryDetector {
  private config: QuestDeliveryDetectorConfig;
  private detectionCache: Map<string, { result: DeliveryDetectionResult; expires: number }>;

  constructor(config?: Partial<QuestDeliveryDetectorConfig>) {
    this.config = {
      enableCaching: true,
      cacheTTL: 30000, // 30 secondes
      enableLogging: process.env.NODE_ENV === 'development',
      strictValidation: true,
      maxDetectionTime: 5000, // 5 secondes max
      enableInventoryValidation: true,
      ...config
    };

    this.detectionCache = new Map();
    
    if (this.config.enableLogging) {
      console.log('üöö [QuestDeliveryDetector] Service initialis√©');
    }
  }

  // ===== M√âTHODE PRINCIPALE =====

  /**
   * üéØ D√©tecte automatiquement les livraisons possibles pour un NPC
   * 
   * @param playerId - ID du joueur
   * @param npcId - ID du NPC avec lequel il interagit
   * @param activeQuests - Qu√™tes actives du joueur
   * @param questDefinitions - D√©finitions de toutes les qu√™tes
   * @returns R√©sultat de d√©tection avec toutes les livraisons possibles
   */
  async detectDeliveries(
    playerId: string,
    npcId: string,
    activeQuests: Quest[],
    questDefinitions: Map<string, QuestDefinition>
  ): Promise<DeliveryDetectionResult> {
    
    const startTime = Date.now();
    
    this.log('info', `üîç D√©tection livraisons: ${playerId} -> NPC ${npcId}`);

    // ‚úÖ V√âRIFICATION CACHE
    if (this.config.enableCaching) {
      const cacheKey = this.generateCacheKey(playerId, npcId);
      const cached = this.getFromCache(cacheKey);
      if (cached) {
        this.log('debug', `üìã Cache hit pour ${playerId}-${npcId}`);
        return cached;
      }
    }

    // ‚úÖ R√âSULTAT INITIAL
    const result: DeliveryDetectionResult = {
      hasDeliveries: false,
      npcId: npcId,
      deliveries: [],
      allItemsAvailable: false,
      totalDeliveries: 0,
      readyDeliveries: 0,
      detectionTime: 0,
      lastUpdated: new Date()
    };

    try {
      // ‚úÖ PHASE 1 : Scanner toutes les qu√™tes actives
      for (const activeQuest of activeQuests) {
        if (activeQuest.status !== 'active') {
          continue; // Ignorer les qu√™tes non actives
        }

        const definition = questDefinitions.get(activeQuest.id);
        if (!definition) {
          this.log('warn', `‚ö†Ô∏è D√©finition manquante pour qu√™te ${activeQuest.id}`);
          continue;
        }

        // ‚úÖ PHASE 2 : Analyser l'√©tape courante
        const currentStep = definition.steps[activeQuest.currentStepIndex];
        if (!currentStep) {
          this.log('warn', `‚ö†Ô∏è √âtape courante introuvable pour ${definition.name}`);
          continue;
        }

        // ‚úÖ PHASE 3 : Chercher les objectifs 'deliver' pour ce NPC
        await this.scanStepForDeliveries(
          playerId,
          npcId,
          activeQuest,
          definition,
          currentStep,
          result
        );
      }

      // ‚úÖ PHASE 4 : Calculer les √©tats globaux
      this.calculateGlobalStates(result);

      // ‚úÖ PHASE 5 : Mise en cache si applicable
      if (this.config.enableCaching && result.hasDeliveries) {
        const cacheKey = this.generateCacheKey(playerId, npcId);
        this.setCache(cacheKey, result);
      }

      result.detectionTime = Date.now() - startTime;
      
      this.log('info', `‚úÖ D√©tection termin√©e: ${result.totalDeliveries} livraison(s), ${result.readyDeliveries} pr√™te(s) (${result.detectionTime}ms)`);

      return result;

    } catch (error) {
      this.log('error', `‚ùå Erreur d√©tection livraisons:`, error);
      result.detectionTime = Date.now() - startTime;
      return result;
    }
  }

  // ===== M√âTHODES PRIV√âES =====

  /**
   * üéØ Scanne une √©tape pour les livraisons vers un NPC sp√©cifique
   */
  private async scanStepForDeliveries(
    playerId: string,
    npcId: string,
    activeQuest: Quest,
    definition: QuestDefinition,
    currentStep: any,
    result: DeliveryDetectionResult
  ): Promise<void> {

    for (const objective of currentStep.objectives) {
      // ‚úÖ FILTRER : Seulement les objectifs 'deliver'
      if (objective.type !== 'deliver') {
        continue;
      }

      // ‚úÖ FILTRER : Seulement pour ce NPC
      if (objective.target !== npcId.toString()) {
        continue;
      }

      // ‚úÖ V√âRIFIER : Objectif pas d√©j√† compl√©t√©
      const objectiveProgress = this.getObjectiveProgress(activeQuest, objective.id);
      if (objectiveProgress?.completed) {
        this.log('debug', `‚è≠Ô∏è Objectif ${objective.id} d√©j√† compl√©t√©`);
        continue;
      }

      this.log('info', `üéØ Objectif de livraison trouv√©: ${objective.description} (${objective.itemId} -> NPC ${npcId})`);

      // ‚úÖ CR√âER L'OBJECTIF DE LIVRAISON
      const deliveryObjective = await this.createDeliveryObjective(
        playerId,
        activeQuest,
        definition,
        currentStep,
        objective,
        npcId
      );

      if (deliveryObjective) {
        result.deliveries.push(deliveryObjective);
        result.totalDeliveries++;

        if (deliveryObjective.canDeliver) {
          result.readyDeliveries++;
        }
      }
    }
  }

  /**
   * üéØ Cr√©e un objectif de livraison avec v√©rification inventaire
   */
  private async createDeliveryObjective(
    playerId: string,
    activeQuest: Quest,
    definition: QuestDefinition,
    currentStep: any,
    objective: any,
    npcId: string
  ): Promise<DeliveryObjective | null> {

    try {
      // ‚úÖ V√âRIFICATION INVENTAIRE
      let playerHasAmount = 0;
      let itemName = objective.itemId || 'Objet inconnu';

      if (this.config.enableInventoryValidation && objective.itemId) {
        try {
          playerHasAmount = await InventoryManager.getItemCount(playerId, objective.itemId);
          
          // Tenter de r√©cup√©rer le nom de l'item
          const itemData = await InventoryManager.getItemDataHybrid(objective.itemId);
          if (itemData?.data?.name) {
            itemName = itemData.data.name;
          }
        } catch (inventoryError) {
          this.log('warn', `‚ö†Ô∏è Erreur v√©rification inventaire pour ${objective.itemId}:`, inventoryError);
        }
      }

      const requiredAmount = objective.requiredAmount || 1;
      const canDeliver = playerHasAmount >= requiredAmount;

      return {
        questId: activeQuest.id,
        questName: definition.name,
        stepIndex: activeQuest.currentStepIndex,
        stepName: currentStep.name || `√âtape ${activeQuest.currentStepIndex + 1}`,
        objectiveId: objective.id,
        objectiveDescription: objective.description,
        
        itemId: objective.itemId || '',
        itemName: itemName,
        requiredAmount: requiredAmount,
        playerHasAmount: playerHasAmount,
        canDeliver: canDeliver,
        
        isCompleted: false,
        npcId: npcId
      };

    } catch (error) {
      this.log('error', `‚ùå Erreur cr√©ation objectif livraison:`, error);
      return null;
    }
  }

  /**
   * üéØ R√©cup√®re la progression d'un objectif sp√©cifique
   */
  private getObjectiveProgress(activeQuest: Quest, objectiveId: string): { completed: boolean; currentAmount?: number } | null {
    try {
      // G√©rer Map vs Object pour la compatibilit√©
      const objectivesMap = activeQuest.steps[activeQuest.currentStepIndex]?.objectives 
        ? new Map(activeQuest.steps[activeQuest.currentStepIndex].objectives.map(obj => [obj.id, obj]))
        : new Map();

      const objective = objectivesMap.get(objectiveId);
      return objective ? { 
        completed: objective.completed || false, 
        currentAmount: objective.currentAmount || 0 
      } : null;

    } catch (error) {
      this.log('warn', `‚ö†Ô∏è Erreur r√©cup√©ration progression objectif ${objectiveId}:`, error);
      return null;
    }
  }

  /**
   * üéØ Calcule les √©tats globaux du r√©sultat
   */
  private calculateGlobalStates(result: DeliveryDetectionResult): void {
    result.hasDeliveries = result.totalDeliveries > 0;
    result.allItemsAvailable = result.deliveries.length > 0 && 
                               result.deliveries.every(d => d.canDeliver);
  }

  // ===== GESTION DU CACHE =====

  private generateCacheKey(playerId: string, npcId: string): string {
    return `delivery_${playerId}_${npcId}`;
  }

  private getFromCache(key: string): DeliveryDetectionResult | null {
    const cached = this.detectionCache.get(key);
    if (!cached) return null;

    if (Date.now() > cached.expires) {
      this.detectionCache.delete(key);
      return null;
    }

    return cached.result;
  }

  private setCache(key: string, result: DeliveryDetectionResult): void {
    // Nettoyage du cache si trop grand
    if (this.detectionCache.size > 100) {
      const oldestKeys = Array.from(this.detectionCache.keys()).slice(0, 20);
      oldestKeys.forEach(k => this.detectionCache.delete(k));
    }

    this.detectionCache.set(key, {
      result: { ...result }, // Copie pour √©viter les mutations
      expires: Date.now() + this.config.cacheTTL
    });
  }

  // ===== M√âTHODES UTILITAIRES =====

  /**
   * üéØ Invalide le cache pour un joueur sp√©cifique
   */
  public invalidatePlayerCache(playerId: string): void {
    const keysToDelete = Array.from(this.detectionCache.keys())
      .filter(key => key.includes(`delivery_${playerId}_`));
    
    keysToDelete.forEach(key => this.detectionCache.delete(key));
    
    if (keysToDelete.length > 0) {
      this.log('debug', `üóëÔ∏è Cache invalid√© pour ${playerId}: ${keysToDelete.length} entr√©e(s)`);
    }
  }

  /**
   * üéØ Vide tout le cache
   */
  public clearCache(): void {
    this.detectionCache.clear();
    this.log('info', 'üóëÔ∏è Cache de d√©tection livraisons vid√©');
  }

  /**
   * üéØ Informations de debug
   */
  public getDebugInfo(): any {
    return {
      config: this.config,
      cacheSize: this.detectionCache.size,
      version: '1.0.0',
      features: {
        caching: this.config.enableCaching,
        inventoryValidation: this.config.enableInventoryValidation,
        strictValidation: this.config.strictValidation
      }
    };
  }

  /**
   * üéØ Logging intelligent
   */
  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: any): void {
    if (!this.config.enableLogging && level === 'debug') return;

    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [QuestDeliveryDetector] ${message}`;

    switch (level) {
      case 'debug':
        if (this.config.enableLogging) {
          console.log(logMessage, data || '');
        }
        break;
      case 'info':
        console.log(logMessage, data || '');
        break;
      case 'warn':
        console.warn(logMessage, data || '');
        break;
      case 'error':
        console.error(logMessage, data || '');
        break;
    }
  }

  /**
   * üéØ Met √† jour la configuration
   */
  public updateConfig(newConfig: Partial<QuestDeliveryDetectorConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.log('info', '‚öôÔ∏è Configuration mise √† jour');
  }

  /**
   * üéØ Nettoyage du service
   */
  public cleanup(): void {
    this.clearCache();
    this.log('info', 'üßπ Service nettoy√©');
  }
}

// ===== EXPORT PAR D√âFAUT =====
export default QuestDeliveryDetector;
