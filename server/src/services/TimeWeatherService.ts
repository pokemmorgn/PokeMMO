// server/src/services/TimeWeatherService.ts - VERSION SYNCHRONISATION GARANTIE
import { getServerConfig, getRandomWeatherType, WeatherType } from "../config/serverConfig";
import { PokeWorldState } from "../schema/PokeWorldState";

export class TimeWeatherService {
  private state: PokeWorldState;
  private timeClockId: any;
  private weatherClockId: any;
  private currentWeather: WeatherType;
  private onWeatherChangeCallback?: (weather: WeatherType) => void;
  private onTimeChangeCallback?: (hour: number, isDayTime: boolean) => void;
  
  // ‚úÖ NOUVEAU: Syst√®me de synchronisation garantie
  private connectedClients: Set<any> = new Set();
  private syncClockId: any;
  private lastSyncTime: number = 0;

  constructor(state: PokeWorldState, clockService: any) {
    this.state = state;
    this.setupInitialState();
    this.startSystems(clockService);
    this.startSyncSystem(clockService);
  }

  private setupInitialState() {
    const config = getServerConfig();
    
    // ‚úÖ √âtat initial temps
    this.state.gameHour = config.timeSystem.startHour;
    this.state.isDayTime = this.calculateDayTime(this.state.gameHour);
    
    // ‚úÖ √âtat initial m√©t√©o
    this.currentWeather = this.getWeatherByName("clear") || getRandomWeatherType();
    this.state.weather = this.currentWeather.name;
    
    console.log(`üïê [TimeWeatherService] √âtat initial: ${this.state.gameHour}h ${this.state.isDayTime ? '(JOUR)' : '(NUIT)'}`);
    console.log(`üå§Ô∏è [TimeWeatherService] M√©t√©o: ${this.currentWeather.displayName}`);
  }

  private startSystems(clockService: any) {
    const config = getServerConfig();
    
    // ‚úÖ Syst√®me temps
    if (config.timeSystem.enabled) {
      this.timeClockId = clockService.setInterval(() => {
        this.updateTime();
      }, config.timeSystem.timeIntervalMs);
      
      console.log(`‚úÖ [TimeWeatherService] Syst√®me temps d√©marr√© (${config.timeSystem.timeIntervalMs}ms)`);
    }

    // ‚úÖ Syst√®me m√©t√©o
    if (config.weatherSystem.enabled) {
      this.weatherClockId = clockService.setInterval(() => {
        this.updateWeather();
      }, config.weatherSystem.changeIntervalMs);
      
      console.log(`‚úÖ [TimeWeatherService] Syst√®me m√©t√©o d√©marr√© (${config.weatherSystem.changeIntervalMs}ms)`);
    }
  }

  // ‚úÖ NOUVEAU: Syst√®me de synchronisation p√©riodique
  private startSyncSystem(clockService: any) {
    // ‚úÖ Envoyer l'√©tat actuel toutes les 30 secondes pour garantir la sync
    this.syncClockId = clockService.setInterval(() => {
      this.broadcastCurrentState();
    }, 30000); // 30 secondes
    
    console.log(`‚úÖ [TimeWeatherService] Syst√®me de sync p√©riodique d√©marr√© (30s)`);
  }

  private updateTime() {
    const config = getServerConfig();
    const oldHour = this.state.gameHour;
    const oldDayTime = this.state.isDayTime;
    
    this.state.gameHour = (this.state.gameHour + 1) % 24;
    this.state.isDayTime = this.calculateDayTime(this.state.gameHour);
    
    if (oldDayTime !== this.state.isDayTime) {
      console.log(`üåÖ [TimeWeatherService] Transition: ${oldDayTime ? 'JOUR' : 'NUIT'} ‚Üí ${this.state.isDayTime ? 'JOUR' : 'NUIT'} (${this.state.gameHour}h)`);
    }
    
    // ‚úÖ BROADCAST IMM√âDIAT √† tous les clients connect√©s
    this.broadcastTimeUpdate();
  }

  private updateWeather() {
    const oldWeather = this.currentWeather;
    this.currentWeather = getRandomWeatherType();
    this.state.weather = this.currentWeather.name;
    
    console.log(`üå§Ô∏è [TimeWeatherService] M√©t√©o: ${oldWeather.displayName} ‚Üí ${this.currentWeather.displayName}`);
    
    // ‚úÖ BROADCAST IMM√âDIAT √† tous les clients connect√©s
    this.broadcastWeatherUpdate();
  }

  private calculateDayTime(hour: number): boolean {
    const config = getServerConfig();
    return hour >= config.timeSystem.dayStartHour && hour < config.timeSystem.nightStartHour;
  }

  private getWeatherByName(name: string): WeatherType | undefined {
    const config = getServerConfig();
    return config.weatherSystem.weatherTypes.find(w => w.name === name);
  }

  // ‚úÖ NOUVEAUX M√âTHODES DE BROADCAST

  private broadcastTimeUpdate() {
    const timeData = {
      gameHour: this.state.gameHour,
      isDayTime: this.state.isDayTime,
      displayTime: this.formatTime(),
      timestamp: Date.now()
    };
    
    console.log(`üì° [TimeWeatherService] Broadcast temps: ${timeData.displayTime} ‚Üí ${this.connectedClients.size} clients`);
    
    // ‚úÖ Utiliser le callback pour envoyer via WorldRoom
    if (this.onTimeChangeCallback) {
      this.onTimeChangeCallback(this.state.gameHour, this.state.isDayTime);
    }
    
    this.lastSyncTime = Date.now();
  }

  private broadcastWeatherUpdate() {
    const weatherData = {
      weather: this.currentWeather.name,
      displayName: this.currentWeather.displayName,
      timestamp: Date.now()
    };
    
    console.log(`üì° [TimeWeatherService] Broadcast m√©t√©o: ${weatherData.displayName} ‚Üí ${this.connectedClients.size} clients`);
    
    // ‚úÖ Utiliser le callback pour envoyer via WorldRoom
    if (this.onWeatherChangeCallback) {
      this.onWeatherChangeCallback(this.currentWeather);
    }
  }

  private broadcastCurrentState() {
    if (this.connectedClients.size === 0) {
      return; // Pas de clients connect√©s
    }
    
    console.log(`üîÑ [TimeWeatherService] Sync p√©riodique: ${this.connectedClients.size} clients`);
    
    // ‚úÖ Forcer l'envoi de l'√©tat actuel
    this.broadcastTimeUpdate();
    this.broadcastWeatherUpdate();
  }

  // ‚úÖ NOUVELLES M√âTHODES DE GESTION DES CLIENTS

  public addClient(client: any) {
    this.connectedClients.add(client);
    console.log(`üë§ [TimeWeatherService] Client ajout√©: ${client.sessionId} (total: ${this.connectedClients.size})`);
    
    // ‚úÖ ENVOYER IMM√âDIATEMENT L'√âTAT ACTUEL AU NOUVEAU CLIENT
    setTimeout(() => {
      this.sendCurrentStateToClient(client);
    }, 500); // Petit d√©lai pour laisser le client s'initialiser
  }

  public removeClient(client: any) {
    this.connectedClients.delete(client);
    console.log(`üëã [TimeWeatherService] Client retir√©: ${client.sessionId} (restant: ${this.connectedClients.size})`);
  }

  private sendCurrentStateToClient(client: any) {
    console.log(`üì§ [TimeWeatherService] Envoi √©tat actuel √† ${client.sessionId}`);
    
    // ‚úÖ Envoyer l'√©tat temps actuel
    client.send("currentTime", {
      gameHour: this.state.gameHour,
      isDayTime: this.state.isDayTime,
      displayTime: this.formatTime()
    });
    
    // ‚úÖ Envoyer l'√©tat m√©t√©o actuel
    client.send("currentWeather", {
      weather: this.currentWeather.name,
      displayName: this.currentWeather.displayName
    });
    
    console.log(`‚úÖ [TimeWeatherService] √âtat envoy√©: ${this.formatTime()}, ${this.currentWeather.displayName}`);
  }

  // ‚úÖ API PUBLIQUE - INCHANG√âE
  
  getCurrentWeather(): WeatherType {
    return this.currentWeather;
  }

  getCurrentTime(): { hour: number; isDayTime: boolean } {
    return {
      hour: this.state.gameHour,
      isDayTime: this.state.isDayTime
    };
  }

  setWeatherChangeCallback(callback: (weather: WeatherType) => void) {
    this.onWeatherChangeCallback = callback;
  }

  setTimeChangeCallback(callback: (hour: number, isDayTime: boolean) => void) {
    this.onTimeChangeCallback = callback;
  }

  getWeatherEffect(effectName: string): number {
    return this.currentWeather.effects[effectName as keyof typeof this.currentWeather.effects] as number || 1.0;
  }

  // ‚úÖ M√âTHODE SIMPLIFI√âE: Retourne les conditions actuelles pour les rencontres
  getEncounterConditions(): { timeOfDay: 'day' | 'night', weather: 'clear' | 'rain' } {
    return {
      timeOfDay: this.state.isDayTime ? 'day' : 'night',
      weather: this.currentWeather.name === 'rain' ? 'rain' : 'clear' // Force clear pour tous sauf rain
    };
  }

  getAvailableWeatherTypes(): string[] {
    const config = getServerConfig();
    return config.weatherSystem.weatherTypes.map(w => w.name);
  }

  formatTime(): string {
    const period = this.state.gameHour < 12 ? 'AM' : 'PM';
    const displayHour = this.state.gameHour === 0 ? 12 : this.state.gameHour > 12 ? this.state.gameHour - 12 : this.state.gameHour;
    return `${displayHour}:00 ${period}`;
  }

  // ‚úÖ NOUVELLES M√âTHODES DE GESTION MANUELLE

  public sendCurrentStateToAllClients() {
    console.log(`üì° [TimeWeatherService] Force envoi √©tat √† tous les clients (${this.connectedClients.size})`);
    
    this.connectedClients.forEach(client => {
      this.sendCurrentStateToClient(client);
    });
  }

  public getConnectedClientsCount(): number {
    return this.connectedClients.size;
  }

  public debugSyncStatus() {
    console.log(`üîç [TimeWeatherService] === √âTAT DE SYNCHRONISATION ===`);
    console.log(`üë• Clients connect√©s: ${this.connectedClients.size}`);
    console.log(`üïê Heure actuelle: ${this.formatTime()} (${this.state.gameHour}h)`);
    console.log(`üå§Ô∏è M√©t√©o actuelle: ${this.currentWeather.displayName}`);
    console.log(`‚è∞ Derni√®re sync: ${this.lastSyncTime ? new Date(this.lastSyncTime).toLocaleTimeString() : 'jamais'}`);
    console.log(`üì° Syst√®me temps actif: ${!!this.timeClockId}`);
    console.log(`üå¶Ô∏è Syst√®me m√©t√©o actif: ${!!this.weatherClockId}`);
    console.log(`üîÑ Syst√®me sync actif: ${!!this.syncClockId}`);
    
    // ‚úÖ Lister les clients connect√©s
    if (this.connectedClients.size > 0) {
      console.log(`üë§ Clients:`);
      this.connectedClients.forEach((client, index) => {
        console.log(`  ${index + 1}. ${client.sessionId}`);
      });
    }
  }

  // ‚úÖ M√âTHODES DE TEST AM√âLIOR√âES

  public forceTime(hour: number, minute: number = 0): void {
    if (hour < 0 || hour > 23) {
      console.warn(`‚ö†Ô∏è [TimeWeatherService] Heure invalide: ${hour}`);
      return;
    }
    
    const oldHour = this.state.gameHour;
    const oldDayTime = this.state.isDayTime;
    
    this.state.gameHour = hour;
    this.state.isDayTime = this.calculateDayTime(hour);
    
    console.log(`üïê [TEST] Heure forc√©e: ${oldHour}h ‚Üí ${hour}h (${this.state.isDayTime ? 'JOUR' : 'NUIT'})`);
    
    // ‚úÖ BROADCAST IMM√âDIAT √† tous les clients
    this.broadcastTimeUpdate();
  }

  public forceWeather(weatherName: string): void {
    const weather = this.getWeatherByName(weatherName);
    
    if (!weather) {
      console.warn(`‚ö†Ô∏è [TimeWeatherService] M√©t√©o inconnue: ${weatherName}`);
      const config = getServerConfig();
      console.log(`üìã M√©t√©os disponibles:`, config.weatherSystem.weatherTypes.map(w => w.name));
      return;
    }
    
    const oldWeather = this.currentWeather.name;
    this.currentWeather = weather;
    this.state.weather = weather.name;
    
    console.log(`üå¶Ô∏è [TEST] M√©t√©o forc√©e: ${oldWeather} ‚Üí ${weatherName}`);
    
    // ‚úÖ BROADCAST IMM√âDIAT √† tous les clients
    this.broadcastWeatherUpdate();
  }

  // ‚úÖ M√âTHODE DE SYNCHRONISATION FORC√âE

  public forceSyncAll(): void {
    console.log(`üîÑ [TimeWeatherService] SYNCHRONISATION FORC√âE DE TOUS LES CLIENTS`);
    
    if (this.connectedClients.size === 0) {
      console.log(`‚ÑπÔ∏è [TimeWeatherService] Aucun client √† synchroniser`);
      return;
    }
    
    this.broadcastCurrentState();
    console.log(`‚úÖ [TimeWeatherService] Synchronisation forc√©e termin√©e`);
  }

  // ‚úÖ M√âTHODE POUR V√âRIFIER LA SANT√â DU SYST√àME

  public healthCheck(): { healthy: boolean; issues: string[] } {
    const issues: string[] = [];
    
    if (!this.timeClockId) {
      issues.push("Syst√®me de temps non actif");
    }
    
    if (!this.weatherClockId) {
      issues.push("Syst√®me de m√©t√©o non actif");
    }
    
    if (!this.syncClockId) {
      issues.push("Syst√®me de synchronisation non actif");
    }
    
    if (this.connectedClients.size === 0) {
      issues.push("Aucun client connect√©");
    }
    
    const timeSinceLastSync = Date.now() - this.lastSyncTime;
    if (timeSinceLastSync > 60000) { // Plus de 1 minute
      issues.push(`Derni√®re sync il y a ${Math.round(timeSinceLastSync / 1000)}s`);
    }
    
    return {
      healthy: issues.length === 0,
      issues: issues
    };
  }

  destroy() {
    console.log(`üßπ [TimeWeatherService] Destruction...`);
    
    if (this.timeClockId) {
      this.timeClockId.clear();
      this.timeClockId = null;
    }
    
    if (this.weatherClockId) {
      this.weatherClockId.clear();
      this.weatherClockId = null;
    }
    
    if (this.syncClockId) {
      this.syncClockId.clear();
      this.syncClockId = null;
    }
    
    this.connectedClients.clear();
    
    console.log(`‚úÖ [TimeWeatherService] Service d√©truit`);
  }
}
