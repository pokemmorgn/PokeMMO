// server/src/rooms/BaseChannelRoom.tsimport { Room, Client } from "@colyseus/core";import { PokeWorldState, Player } from "../schema/PokeWorldState";import { PlayerData } from "../models/PlayerData";import { NpcManager } from "../managers/NPCManager";import { QuestManager } from "../managers/QuestManager";import { MovementController } from "../controllers/MovementController";import { TransitionController } from "../controllers/TransitionController";import { InteractionManager } from "../managers/InteractionManager";import { TransitionValidator, TransitionRequest } from "../managers/TransitionValidator";import { ChannelManager } from "../managers/ChannelManager";import { OwnedPokemon, IOwnedPokemon } from "../models/OwnedPokemon";import { convertOwnedPokemonToTeam } from "../utils/convertOwnedPokemonToTeam";import { giveStarterToPlayer } from "../services/PokemonService";import { ArraySchema } from "@colyseus/schema";export type SpawnData = {  targetZone: string;  targetSpawn?: string;  targetX?: number;  targetY?: number;  fromZone?: string;};export abstract class BaseChannelRoom extends Room<PokeWorldState> {  maxClients = 50; // Réduit pour les channels  public abstract mapName: string;  protected abstract defaultX: number;  protected abstract defaultY: number;  // Managers existants  protected npcManager: NpcManager;  protected questManager: QuestManager;  public movementController: MovementController;  public transitionController: TransitionController;  protected interactionManager: InteractionManager;  // Nouveaux managers pour les channels  protected transitionValidator: TransitionValidator;  protected channelManager: ChannelManager;  // Informations du channel  public channelIndex: number = 0;  public isChannelRoom: boolean = false;  onCreate(options: any) {    this.setState(new PokeWorldState());        // Configurer le channel    this.channelIndex = options.channelIndex || 0;    this.isChannelRoom = options.isChannel || false;        console.log(`?? DEBUT onCreate ${this.mapName} [Channel ${this.channelIndex}]`);    // Initialisation des managers existants    this.npcManager = new NpcManager(`../assets/maps/${this.mapName.replace('Room', '').toLowerCase()}.tmj`);    this.questManager = new QuestManager(`../data/quests/quests.json`);    this.interactionManager = new InteractionManager(this.npcManager, this.questManager);    this.movementController = new MovementController();    this.transitionController = new TransitionController(this);    // Nouveaux managers pour channels    this.transitionValidator = new TransitionValidator();        // Accès au ChannelManager global (sera injecté via gameServer)    this.channelManager = (this as any).gameServer?.channelManager;    // Sauvegarde automatique toutes les 30 secondes    this.clock.setInterval(() => {      this.saveAllPlayers();    }, 30000);    // Nettoyage des cooldowns toutes les minutes    this.clock.setInterval(() => {      this.transitionValidator.cleanupExpiredCooldowns();    }, 60000);    this.setupMessageHandlers();  }  private setupMessageHandlers(): void {    // === HANDLERS DE TRANSITION AVEC VALIDATION ===        this.onMessage("requestTransition", async (client: Client, data: {      targetZone: string;      teleportData?: { x: number; y: number; targetSpawn?: string };    }) => {      await this.handleValidatedTransition(client, data);    });    // === HANDLERS DE MOUVEMENT AVEC DETECTION AUTO ===        this.onMessage("move", async (client: Client, data: any) => {      const player = this.state.players.get(client.sessionId);      if (player) {        const skipAnticheat = (player as any).justSpawned === true;        const moveResult = this.movementController.handleMove(client.sessionId, player, data, skipAnticheat);        if (skipAnticheat) (player as any).justSpawned = false;                player.x = moveResult.x;        player.y = moveResult.y;        if ('direction' in moveResult) player.direction = moveResult.direction;        if ('isMoving' in moveResult) player.isMoving = moveResult.isMoving;                if (moveResult.snapped) {          client.send("snap", { x: moveResult.x, y: moveResult.y });        }        // ? NOUVEAU : Vérification des téléports automatiques avec validation        await this.checkAutoTransition(client, player);        // Vérifier la progression des quêtes de type "reach"        this.handleZoneReachProgress(player.name, player.x, player.y);      }    });    // === HANDLERS DE QUÊTES (INCHANGÉS) ===        this.onMessage("npcInteract", async (client: Client, data: { npcId: number }) => {      const player = this.state.players.get(client.sessionId);      if (!player) return;            const result = await this.interactionManager.handleNpcInteraction(player, data.npcId);      client.send("npcInteractionResult", { ...result, npcId: data.npcId });    });    this.onMessage("startQuest", async (client: Client, data: { questId: string }) => {      const player = this.state.players.get(client.sessionId);      if (!player) return;      const result = await this.interactionManager.handleQuestStart(player.name, data.questId);      client.send("questStartResult", result);      if (result.success) {        this.broadcast("questUpdate", {          player: player.name,          action: "started",          questId: data.questId        }, { except: client });      }    });    this.onMessage("getActiveQuests", async (client: Client) => {      const player = this.state.players.get(client.sessionId);      if (!player) return;      const activeQuests = await this.questManager.getActiveQuests(player.name);      client.send("activeQuestsList", { quests: activeQuests });    });    this.onMessage("getAvailableQuests", async (client: Client) => {      const player = this.state.players.get(client.sessionId);      if (!player) return;      const availableQuests = await this.questManager.getAvailableQuests(player.name);      client.send("availableQuestsList", { quests: availableQuests });    });    this.onMessage("questProgress", async (client: Client, data: any) => {      const player = this.state.players.get(client.sessionId);      if (!player) return;      const results = await this.interactionManager.updatePlayerProgress(        player.name,         data.type,         data      );      if (results.length > 0) {        client.send("questProgressUpdate", results);                for (const result of results) {          if (result.rewards && result.rewards.length > 0) {            client.send("questRewards", {              questId: result.questId,              rewards: result.rewards,              message: result.message            });          }        }      }    });    // === HANDLERS DE STARTER (INCHANGÉS) ===        this.onMessage("selectStarter", async (client: Client, data: { starterId: 1 | 4 | 7 }) => {      const player = this.state.players.get(client.sessionId);      if (!player) return;      console.log(`?? ${player.name} choisit le starter ${data.starterId} [Channel ${this.channelIndex}]`);      try {        const playerData = await PlayerData.findOne({ username: player.name });        if (!playerData) {          client.send("starterSelectionResult", {             success: false,             message: "Erreur: données joueur non trouvées"           });          return;        }        if (playerData.team && playerData.team.length > 0) {          client.send("starterSelectionResult", {             success: false,             message: "Vous avez déjà choisi votre starter!"           });          return;        }        const starterPokemon = await giveStarterToPlayer(player.name, data.starterId);                playerData.team = [starterPokemon._id];        await playerData.save();        const teamPokemons = await OwnedPokemon.find({ _id: { $in: playerData.team } });        player.team = new ArraySchema(...teamPokemons.map(convertOwnedPokemonToTeam));        const starterNames = { 1: "Bulbasaur", 4: "Charmander", 7: "Squirtle" };                client.send("starterSelectionResult", {          success: true,          message: `Félicitations! Vous avez choisi ${starterNames[data.starterId]}!`,          pokemon: {            id: starterPokemon._id.toString(),            pokemonId: starterPokemon.pokemonId,            name: starterNames[data.starterId],            level: starterPokemon.level,            shiny: starterPokemon.shiny,            nature: starterPokemon.nature,            moves: starterPokemon.moves,            nickname: starterPokemon.nickname,            gender: starterPokemon.gender          }        });        console.log(`? ${player.name} a reçu ${starterNames[data.starterId]} (Channel ${this.channelIndex})`);        this.triggerTutorialQuest(client, player.name);      } catch (error) {        console.error(`? Erreur sélection starter pour ${player.name}:`, error);        client.send("starterSelectionResult", {           success: false,           message: "Erreur lors de la sélection du starter"         });      }    });    this.onMessage("requestStarterSelection", async (client: Client) => {      const player = this.state.players.get(client.sessionId);      if (!player) return;      const playerData = await PlayerData.findOne({ username: player.name });      const canSelect = !playerData || !playerData.team || playerData.team.length === 0;      if (canSelect) {        client.send("showStarterSelection", {          starters: [            {              id: 1,              name: "Bulbasaur",              types: ["Grass", "Poison"],              description: "Un Pokémon Graine robuste et fiable"            },            {              id: 4,              name: "Charmander",              types: ["Fire"],              description: "Un Pokémon Lézard fougueux et courageux"            },            {              id: 7,              name: "Squirtle",              types: ["Water"],              description: "Un Pokémon Minitortue calme et stratégique"            }          ]        });      } else {        client.send("starterSelectionResult", {           success: false,           message: "Vous avez déjà un Pokémon!"         });      }    });    // === HANDLERS DE DEBUG CHANNELS ===        this.onMessage("getChannelInfo", async (client: Client) => {      if (this.channelManager) {        const stats = await this.channelManager.getChannelStats(this.mapName);        client.send("channelInfo", {          currentChannel: this.channelIndex,          roomId: this.roomId,          stats: stats[this.mapName] || {}        });      }    });  }  /**   * ? NOUVELLE MÉTHODE : Gère les transitions avec validation complète   */  private async handleValidatedTransition(    client: Client,     data: { targetZone: string; teleportData?: { x: number; y: number; targetSpawn?: string } }  ): Promise<void> {    const player = this.state.players.get(client.sessionId);    if (!player) {      client.send("transitionFailed", { reason: "Joueur non trouvé" });      return;    }    const currentZone = this.mapName.replace('Room', '').toLowerCase();    const targetZone = data.targetZone.toLowerCase();    console.log(`?? Demande transition: ${player.name} (${currentZone} ? ${targetZone}) [Channel ${this.channelIndex}]`);    // Créer la requête de transition    const request: TransitionRequest = {      client,      player,      fromZone: currentZone,      toZone: targetZone,      teleportData: data.teleportData    };    try {      // Valider la transition      const validation = await this.transitionValidator.validateTransition(request);      if (!validation.allowed) {        console.log(`? Transition refusée: ${validation.reason}`);        client.send("transitionFailed", {          reason: validation.reason,          cooldownRemaining: validation.cooldownRemaining,          requiredLevel: validation.requiredLevel,          missingItems: validation.missingItems        });        return;      }      console.log(`? Transition validée: ${currentZone} ? ${targetZone}`);      // Exécuter la transition      await this.executeChannelTransition(client, player, targetZone, validation.targetSpawn);    } catch (error) {      console.error(`? Erreur lors de la validation de transition:`, error);      client.send("transitionFailed", {         reason: "Erreur serveur lors de la transition"       });    }  }  /**   * ? NOUVELLE MÉTHODE : Vérifie automatiquement les transitions lors des mouvements   */  private async checkAutoTransition(client: Client, player: Player): Promise<void> {    // Utiliser le système de téléport existant mais avec validation    const teleportResult = this.transitionController.checkAutoTeleport(client, player);        if (teleportResult) {      const currentZone = this.mapName.replace('Room', '').toLowerCase();      const targetZone = player.map.toLowerCase();      // Valider la transition automatique      const request: TransitionRequest = {        client,        player,        fromZone: currentZone,        toZone: targetZone,        teleportData: {          x: player.x,          y: player.y        }      };      const validation = await this.transitionValidator.validateTransition(request);      if (validation.allowed) {        console.log(`?? Transition automatique validée: ${currentZone} ? ${targetZone}`);        // La transition est déjà gérée par checkAutoTeleport      } else {        console.log(`?? Transition automatique bloquée: ${validation.reason}`);        // Remettre le joueur à sa position précédente        client.send("snap", { x: player.x, y: player.y });        client.send("transitionFailed", { reason: validation.reason });      }    }  }  /**   * ? NOUVELLE MÉTHODE : Exécute une transition entre channels   */  private async executeChannelTransition(    client: Client,    player: Player,    targetZone: string,    targetSpawn?: { x: number; y: number; spawnPoint: string }  ): Promise<void> {    try {      const targetRoomName = this.getTargetRoomName(targetZone);            if (!this.channelManager) {        throw new Error("ChannelManager non disponible");      }      // Trouver le channel optimal pour la destination      const targetChannelId = await this.channelManager.findOptimalChannel(targetRoomName);      // Préparer les données de spawn      const spawnData = {        fromZone: this.mapName.replace('Room', '').toLowerCase(),        spawnX: targetSpawn?.x,        spawnY: targetSpawn?.y,        targetSpawn: targetSpawn?.spawnPoint,        username: player.name      };      console.log(`?? Transition vers channel ${targetChannelId} avec spawn:`, spawnData);      // Notifier le client de la transition réussie      client.send("transitionSuccess", {        targetZone: targetRoomName,        targetChannelId,        spawnData      });      // Sauvegarder la position actuelle avant de quitter      await this.savePlayerPosition(player);    } catch (error) {      console.error(`? Erreur exécution transition:`, error);      client.send("transitionFailed", {         reason: "Erreur lors de l'exécution de la transition"       });    }  }  /**   * Convertit un nom de zone en nom de room   */  private getTargetRoomName(zoneName: string): string {    const zoneToRoom: Record<string, string> = {      'beach': 'BeachRoom',      'village': 'VillageRoom',      'villagelab': 'VillageLabRoom',      'villagehouse1': 'VillageHouse1Room',      'road1': 'Road1Room',      'lavandia': 'LavandiaRoom'    };    return zoneToRoom[zoneName.toLowerCase()] || 'BeachRoom';  }  /**   * Sauvegarde la position d'un joueur   */  private async savePlayerPosition(player: Player): Promise<void> {    try {      await PlayerData.updateOne(        { username: player.name },        {           $set: {             lastX: player.x,             lastY: player.y,             lastMap: this.mapName.replace('Room', '')           }         }      );    } catch (error) {      console.error(`? Erreur sauvegarde position ${player.name}:`, error);    }  }  // === MÉTHODES UTILITAIRES POUR LES QUÊTES (INCHANGÉES) ===  private async triggerTutorialQuest(client: Client, username: string): Promise<void> {    try {      const tutorialQuest = await this.questManager.startQuest(username, "tutorial_first_steps");      if (tutorialQuest) {        client.send("questStarted", {          quest: tutorialQuest,          message: "Nouvelle quête disponible !"        });      }    } catch (error) {      console.error("? Erreur démarrage quête tutoriel:", error);    }  }  private async handleZoneReachProgress(username: string, x: number, y: number): Promise<void> {    const currentMap = this.mapName.replace('Room', '').toLowerCase();        await this.interactionManager.updatePlayerProgress(username, 'reach', {      zoneId: currentMap,      x: x,      y: y,      map: currentMap    });  }  // === MÉTHODES EXISTANTES (INCHANGÉES) ===  async saveAllPlayers() {    if (this.state.players.size === 0) return;    try {      for (const [sessionId, player] of this.state.players) {        await PlayerData.updateOne(          { username: player.name },          { $set: { lastX: player.x, lastY: player.y, lastMap: this.mapName.replace('Room', '') } }        );      }    } catch (error) {      console.error(`? Erreur saveAllPlayers ${this.mapName} [Channel ${this.channelIndex}]:`, error);    }  }  async onJoin(client: Client, options: any) {    console.log(`?? [onJoin] Nouvelle connexion Channel ${this.channelIndex}!`, options.username);    const username = options.username || "Anonymous";        // Envoyer les NPCs    const availableQuests = await this.questManager.getAvailableQuests(username);    const rawNpcs = this.npcManager.getAllNpcs();    const npcListWithQuests = rawNpcs.map(npc => {      const questsForNpc = availableQuests.filter(q => q.startNpcId === npc.id);      return {        ...npc,        availableQuests: questsForNpc.map(q => q.id),      };    });    client.send("npcList", npcListWithQuests);    // Supprime un joueur en double si existant    const existingPlayer = Array.from(this.state.players.values()).find(p => p.name === username);    if (existingPlayer) {      const oldSessionId = Array.from(this.state.players.entries()).find(([_, p]) => p.name === username)?.[0];      if (oldSessionId) {        this.state.players.delete(oldSessionId);        this.movementController?.resetPlayer?.(oldSessionId);      }    }    let playerData = await PlayerData.findOne({ username });    let isNewPlayer = false;    if (!playerData) {      isNewPlayer = true;      const mapName = this.mapName.replace('Room', '');      playerData = await PlayerData.create({        username,        lastX: this.defaultX,        lastY: this.defaultY,        lastMap: mapName,        team: []      });      console.log(`?? Nouveau joueur créé: ${username} [Channel ${this.channelIndex}]`);    }    // Récupération des Pokémon de la team depuis la BDD    let teamPokemons: IOwnedPokemon[] = [];    if (playerData.team && playerData.team.length > 0) {      teamPokemons = await OwnedPokemon.find({ _id: { $in: playerData.team } });    }    const player = new Player();    player.name = username;    (player as any).justSpawned = true;    (player as any).isTransitioning = false;    if (options.spawnX !== undefined && options.spawnY !== undefined) {      player.x = options.spawnX;      player.y = options.spawnY;    } else {      player.x = playerData.lastX;      player.y = playerData.lastY;    }    player.map = this.mapName.replace('Room', '');    // Injection de la team synchronisée    player.team = new ArraySchema(...teamPokemons.map(convertOwnedPokemonToTeam));    this.state.players.set(client.sessionId, player);    // Envoyer les informations du channel    client.send("channelInfo", {      channelIndex: this.channelIndex,      roomId: this.roomId,      playersInChannel: this.state.players.size,      maxPlayers: this.maxClients    });    // Envoyer les quêtes actives    const activeQuests = await this.questManager.getActiveQuests(username);    if (activeQuests.length > 0) {      client.send("activeQuestsList", { quests: activeQuests });    }    // Gestion de l'affichage du HUD de starter    if (isNewPlayer || teamPokemons.length === 0) {      console.log(`?? Affichage du HUD de sélection de starter pour ${username} [Channel ${this.channelIndex}]`);            this.clock.setTimeout(() => {        client.send("showStarterSelection", {          isNewPlayer: isNewPlayer,          message: isNewPlayer             ? `Bienvenue dans le monde Pokémon, ${username}! Choisissez votre premier compagnon :`            : `Bon retour, ${username}! Vous devez choisir votre Pokémon :`,          starters: [            {              id: 1,              name: "Bulbasaur",              types: ["Grass", "Poison"],              description: "Un Pokémon Graine robuste et fiable. Bon pour débuter !",              sprite: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/1.png"            },            {              id: 4,              name: "Charmander",              types: ["Fire"],              description: "Un Pokémon Lézard fougueux et courageux. Parfait pour l'attaque !",              sprite: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/4.png"            },            {              id: 7,              name: "Squirtle",              types: ["Water"],              description: "Un Pokémon Minitortue calme et stratégique. Excellent en défense !",              sprite: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/7.png"            }          ]        });      }, 500);    } else {      client.send("welcomeMessage", {        message: `Bon retour, ${username}! [Channel ${this.channelIndex}]`,        isNewPlayer: false,        teamCount: teamPokemons.length,        channelInfo: {          index: this.channelIndex,          playersCount: this.state.players.size        }      });    }  }    async onLeave(client: Client) {    const player = this.state.players.get(client.sessionId);    if (player) {      await PlayerData.updateOne({ username: player.name }, {        $set: { lastX: player.x, lastY: player.y, lastMap: player.map }      });      this.movementController?.resetPlayer?.(client.sessionId);      this.transitionValidator.clearPlayerCooldowns(client.sessionId);      this.state.players.delete(client.sessionId);            console.log(`?? ${player.name} a quitté le channel ${this.channelIndex}`);    }  }  async onDispose() {    await this.saveAllPlayers();    console.log(`??? Channel ${this.channelIndex} du ${this.mapName} supprimé`);  }}