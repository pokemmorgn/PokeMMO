// server/src/managers/JWTManager.ts
import { QuestManager } from "./QuestManager";
import { PlayerData, IPlayerData } from "../models/PlayerData";

export class JWTManager {
  private static instance: JWTManager;
  private sessionToUser: Map<string, string> = new Map(); // sessionId -> userId
  private userToSession: Map<string, string> = new Map(); // userId -> sessionId
  private userJWTData: Map<string, any> = new Map(); // userId -> JWT data
  private activeBattleStates: Map<string, any> = new Map(); // ‚úÖ NOUVEAU: userId -> battle state
  private questManager: QuestManager;
  
  static getInstance(): JWTManager {
    if (!JWTManager.instance) {
      JWTManager.instance = new JWTManager();
      JWTManager.instance.questManager = new QuestManager();
    }
    return JWTManager.instance;
  }
  
  /**
   * Enregistrer un utilisateur √† la connexion
   */
async registerUser(sessionId: string, jwt: any): Promise<void> {
  const userId = jwt.userId;

  console.log(`üîó [JWTManager] Enregistrement: ${sessionId} -> ${userId} (${jwt.username})`);

  // Refuser si le compte est d√©j√† connect√© sur une autre session
  const oldSessionId = this.userToSession.get(userId);
  if (oldSessionId && oldSessionId !== sessionId) {
    console.log(`‚õî [JWTManager] Connexion refus√©e : ${userId} d√©j√† connect√© (session ${oldSessionId})`);
    throw new Error("Vous √™tes d√©j√† connect√© sur un autre onglet ou appareil.");
  }

  // Nouveau mapping (connexion normale)
  this.sessionToUser.set(sessionId, userId);
  this.userToSession.set(userId, sessionId);
  this.userJWTData.set(userId, jwt);
  await this.handleQuestAutoReset(jwt.username);

    // ‚úÖ NOUVEAU: Reset objets en mode dev
  const { getServerConfig } = require('../config/serverConfig');
  const serverConfig = getServerConfig();
  
  if (serverConfig.autoresetObjects) {
    await this.resetPlayerObjects(jwt.username);
  }

  console.log(`‚úÖ [JWTManager] Utilisateur enregistr√©: ${jwt.username} (${userId})`);
}
  
  /**
   * Traduire sessionId -> userId
   */
  getUserId(sessionId: string): string | null {
    return this.sessionToUser.get(sessionId) || null;
  }
  
  /**
   * Traduire userId -> sessionId actuel
   */
  getSessionId(userId: string): string | null {
    return this.userToSession.get(userId) || null;
  }
  
  /**
   * Obtenir les donn√©es JWT d'un utilisateur
   */
  getUserJWTData(userId: string): any | null {
    return this.userJWTData.get(userId) || null;
  }
  
  /**
   * Obtenir les donn√©es JWT via sessionId
   */
  getJWTDataBySession(sessionId: string): any | null {
    const userId = this.getUserId(sessionId);
    return userId ? this.getUserJWTData(userId) : null;
  }
getUserIdByPlayerName(playerName: string): string | null {
  for (const [sessionId, userId] of this.sessionToUser.entries()) {
    const jwtData = this.userJWTData.get(userId);
    if (jwtData?.username === playerName) {
      return userId;
    }
  }
  return null;
}
  /**
 * ‚úÖ NOUVELLE M√âTHODE: Maintenir coh√©rence JWT
 */
ensureMapping(sessionId: string, userId: string, jwtData: any): void {
  const existingUserId = this.getUserId(sessionId);
  
  if (existingUserId && existingUserId !== userId) {
    console.log(`üîÑ [JWTManager] Changement session: ${existingUserId} -> ${userId}`);
    
    // Transf√©rer √©tat de combat si n√©cessaire
    const battleState = this.getBattleState(existingUserId);
    if (battleState) {
      this.saveBattleState(userId, battleState);
      this.clearBattleState(existingUserId);
      console.log(`‚öîÔ∏è [JWTManager] Combat transf√©r√©: ${existingUserId} -> ${userId}`);
    }
  }
  
  this.sessionToUser.set(sessionId, userId);
  this.userToSession.set(userId, sessionId);
  this.userJWTData.set(userId, jwtData);
}

/**
 * ‚úÖ NOUVELLE M√âTHODE: Validation actions critiques
 */
validateCriticalAction(sessionId: string, action: string): boolean {
  const userId = this.getUserId(sessionId);
  const jwtData = this.getJWTDataBySession(sessionId);
  
  if (!userId || !jwtData) {
    console.error(`‚ùå [JWTManager] Action ${action} bloqu√©e: session invalide ${sessionId}`);
    return false;
  }
  
  if (jwtData.exp && Date.now() >= jwtData.exp * 1000) {
    console.error(`‚ùå [JWTManager] Action ${action} bloqu√©e: JWT expir√©`);
    this.removeUser(sessionId);
    return false;
  }
  
  return true;
}
  /**
   * V√©rifier si un utilisateur est connect√©
   */
  isUserConnected(userId: string): boolean {
    return this.userToSession.has(userId);
  }
  
  /**
   * Nettoyer un utilisateur √† la d√©connexion
   */
removeUser(sessionId: string): void {
  const userId = this.sessionToUser.get(sessionId);
  if (userId) {
    console.log(`üßπ [JWTManager] D√©connexion: ${sessionId} -> ${userId}`);
    
    // ‚úÖ NOUVEAU: V√©rifier si l'utilisateur a un combat actif
    const hasActiveBattle = this.hasActiveBattle(userId);
    
    if (hasActiveBattle) {
      console.log(`‚öîÔ∏è [JWTManager] Pr√©servation JWT pour combat actif: ${userId}`);
      
      // NE PAS supprimer le JWT, juste la session courante
      this.sessionToUser.delete(sessionId);
      // Garder userToSession et userJWTData pour reconnexion
      
      console.log(`üíæ [JWTManager] JWT pr√©serv√© pour reconnexion: ${userId}`);
      return;
    }
    
    // ‚úÖ Nettoyage normal si pas de combat
    this.sessionToUser.delete(sessionId);
    this.userToSession.delete(userId);
    this.userJWTData.delete(userId);
    
    console.log(`‚úÖ [JWTManager] Utilisateur supprim√©: ${userId}`);
  }
}

// ‚úÖ NOUVELLE M√âTHODE: Re-association automatique
async restoreUserSession(sessionId: string, username: string): Promise<boolean> {
  console.log(`üîÑ [JWTManager] Tentative restauration session pour ${username}`);
  
  // Chercher l'userId par nom d'utilisateur
  for (const [userId, jwtData] of this.userJWTData.entries()) {
    if (jwtData.username === username) {
      console.log(`‚úÖ [JWTManager] JWT trouv√© pour ${username}: ${userId}`);
      
      // Re-cr√©er les mappings
      this.sessionToUser.set(sessionId, userId);
      this.userToSession.set(userId, sessionId);
      
      console.log(`üîó [JWTManager] Session restaur√©e: ${sessionId} -> ${userId}`);
      return true;
    }
  }
  
  console.log(`‚ùå [JWTManager] Aucun JWT trouv√© pour ${username}`);
  return false;
}

  // ‚úÖ DANS JWTManager.ts - AJOUTER CETTE M√âTHODE GLOBALE

/**
 * ‚úÖ M√âTHODE UNIVERSELLE: R√©cup√®re userId de mani√®re robuste avec auto-restauration
 */
async getUserIdRobust(sessionId: string, playerName?: string): Promise<string | null> {
  console.log(`üîç [JWTManager] getUserIdRobust pour session: ${sessionId}`);
  
  // ‚úÖ √âTAPE 1: Essayer mapping normal
  let userId = this.getUserId(sessionId);
  
  if (userId) {
    console.log(`‚úÖ [JWTManager] UserId trouv√© directement: ${userId}`);
    return userId;
  }
  
  // ‚úÖ √âTAPE 2: Si pas de mapping et nom fourni, essayer restauration
  if (playerName) {
    console.log(`üîÑ [JWTManager] Tentative restauration pour: ${playerName}`);
    
    try {
      const restored = await this.restoreUserSession(sessionId, playerName);
      
      if (restored) {
        userId = this.getUserId(sessionId);
        console.log(`‚úÖ [JWTManager] UserId restaur√©: ${userId}`);
        return userId;
      }
    } catch (error) {
      console.error(`‚ùå [JWTManager] Erreur restauration:`, error);
    }
  }
  
  // ‚úÖ √âTAPE 3: Dernier recours - chercher par nom dans tous les mappings
  if (playerName) {
    console.log(`üîÑ [JWTManager] Recherche par nom dans mappings: ${playerName}`);
    
    for (const [existingSessionId, existingUserId] of this.sessionToUser.entries()) {
      const jwtData = this.userJWTData.get(existingUserId);
      if (jwtData?.username === playerName) {
        console.log(`üîó [JWTManager] Mapping trouv√©, re-association: ${sessionId} -> ${existingUserId}`);
        
        // Re-cr√©er le mapping pour cette session
        this.sessionToUser.set(sessionId, existingUserId);
        this.userToSession.set(existingUserId, sessionId);
        
        return existingUserId;
      }
    }
  }
  
  console.log(`‚ùå [JWTManager] Impossible de r√©soudre userId pour session: ${sessionId}`);
  return null;
}

/**
 * ‚úÖ M√âTHODE UNIVERSELLE: Valide session avec auto-restauration
 */
async validateSessionRobust(sessionId: string, playerName?: string, action?: string): Promise<{
  valid: boolean;
  userId?: string;
  jwtData?: any;
  reason?: string;
}> {
  console.log(`üîç [JWTManager] validateSessionRobust: ${sessionId} (${playerName}) pour ${action || 'action'}`);
  
  // ‚úÖ R√©cup√©rer userId de mani√®re robuste
  const userId = await this.getUserIdRobust(sessionId, playerName);
  
  if (!userId) {
    return {
      valid: false,
      reason: `Impossible de r√©soudre userId pour session ${sessionId}`
    };
  }
  
  // ‚úÖ R√©cup√©rer JWT data
  const jwtData = this.getJWTDataBySession(sessionId);
  
  if (!jwtData) {
    return {
      valid: false,
      userId,
      reason: `JWT Data manquant pour userId ${userId}`
    };
  }
  
  // ‚úÖ V√©rifier expiration
  if (jwtData.exp && Date.now() >= jwtData.exp * 1000) {
    const expiredSince = Math.round((Date.now() - jwtData.exp * 1000) / 1000);
    return {
      valid: false,
      userId,
      jwtData,
      reason: `JWT expir√© depuis ${expiredSince}s`
    };
  }
  
  console.log(`‚úÖ [JWTManager] Session valid√©e: ${sessionId} -> ${userId} (${jwtData.username})`);
  
  return {
    valid: true,
    userId,
    jwtData
  };
}

  /**
   * ‚úÖ NOUVEAU: Sauvegarder l'√©tat de combat d'un utilisateur
   */
  saveBattleState(userId: string, battleState: any): void {
    this.activeBattleStates.set(userId, {
      ...battleState,
      timestamp: Date.now() // Mettre √† jour le timestamp
    });
    console.log(`üíæ [JWTManager] √âtat combat sauv√© pour ${userId}`);
  }

  /**
   * ‚úÖ NOUVEAU: R√©cup√©rer l'√©tat de combat d'un utilisateur
   */
  getBattleState(userId: string): any | null {
    return this.activeBattleStates.get(userId) || null;
  }

  /**
   * ‚úÖ NOUVEAU: Supprimer l'√©tat de combat (combat termin√©)
   */
  clearBattleState(userId: string): void {
    if (this.activeBattleStates.has(userId)) {
      this.activeBattleStates.delete(userId);
      console.log(`üóëÔ∏è [JWTManager] √âtat combat supprim√© pour ${userId}`);
    }
  }

  /**
   * ‚úÖ NOUVEAU: V√©rifier si un utilisateur a un combat en cours
   */
  hasActiveBattle(userId: string): boolean {
    const battleState = this.activeBattleStates.get(userId);
    if (!battleState) return false;
    
    // V√©rifier que le combat n'est pas trop ancien (5 minutes max)
    const timeDiff = Date.now() - battleState.timestamp;
    const maxAge = 5 * 60 * 1000; // 5 minutes
    
    if (timeDiff > maxAge) {
      console.log(`‚è∞ [JWTManager] Combat expir√© pour ${userId} (${Math.round(timeDiff/1000)}s)`);
      this.clearBattleState(userId);
      return false;
    }
    
    return true;
  }

  /**
   * ‚úÖ NOUVEAU: Obtenir les informations de combat actif
   */
  getActiveBattleInfo(userId: string): any | null {
    if (!this.hasActiveBattle(userId)) return null;
    
    const battleState = this.activeBattleStates.get(userId);
    if (!battleState) return null;
    
    return {
      battleId: battleState.battleId,
      battleType: battleState.battleType,
      phase: battleState.phase,
      turnNumber: battleState.turnNumber,
      player1Pokemon: battleState.player1?.pokemon?.name,
      player2Pokemon: battleState.player2?.pokemon?.name,
      timeElapsed: Math.round((Date.now() - battleState.timestamp) / 1000),
      canRestore: true
    };
  }

  /**
   * ‚úÖ NOUVEAU: Nettoyage automatique des combats expir√©s
   */
  cleanupExpiredBattles(): number {
    let cleaned = 0;
    const maxAge = 5 * 60 * 1000; // 5 minutes
    const now = Date.now();
    
    for (const [userId, battleState] of this.activeBattleStates.entries()) {
      if (now - battleState.timestamp > maxAge) {
        this.activeBattleStates.delete(userId);
        cleaned++;
        console.log(`üßπ [JWTManager] Combat expir√© nettoy√©: ${userId}`);
      }
    }
    
    if (cleaned > 0) {
      console.log(`‚úÖ [JWTManager] ${cleaned} combat(s) expir√©(s) nettoy√©(s)`);
    }
    
    return cleaned;
  }

  /**
   * ‚úÖ NOUVEAU: Lister tous les combats actifs
   */
  getAllActiveBattles(): Array<{userId: string, username: string, battleInfo: any}> {
    const activeBattles: Array<{userId: string, username: string, battleInfo: any}> = [];
    
    for (const [userId, battleState] of this.activeBattleStates.entries()) {
      if (this.hasActiveBattle(userId)) {
        const jwtData = this.getUserJWTData(userId);
        activeBattles.push({
          userId,
          username: jwtData?.username || 'unknown',
          battleInfo: this.getActiveBattleInfo(userId)
        });
      }
    }
    
    return activeBattles;
  }

  /**
   * ‚úÖ NOUVEAU: Reset tous les objets collect√©s d'un joueur (mode dev)
   */
  async resetPlayerObjects(username: string): Promise<void> {
    try {
      console.log(`üîÑ [JWTManager] Reset objets pour ${username}`);
      
      const playerDataDoc = await PlayerData.findOne({ username });
      if (!playerDataDoc) {
        console.log(`‚ö†Ô∏è [JWTManager] Joueur ${username} non trouv√© pour reset objets`);
        return;
      }

      const playerData = playerDataDoc as IPlayerData;
      
      // Supprimer tous les cooldowns objets
      const initialCount = playerData.objectStates.length;
      playerData.objectStates = [];
      await playerData.save();
      
      console.log(`‚úÖ [JWTManager] ${initialCount} cooldowns objets supprim√©s pour ${username}`);
      
    } catch (error) {
      console.error(`‚ùå [JWTManager] Erreur reset objets pour ${username}:`, error);
    }
  }
  
  /**
   * Debug - Afficher tous les mappings
   */
  debugMappings(): void {
    console.log(`üîç [JWTManager] === DEBUG MAPPINGS ===`);
    console.log(`üìä Sessions actives: ${this.sessionToUser.size}`);
    console.log(`‚öîÔ∏è Combats actifs: ${this.activeBattleStates.size}`);
    
    for (const [sessionId, userId] of this.sessionToUser.entries()) {
      const jwt = this.userJWTData.get(userId);
      const hasBattle = this.hasActiveBattle(userId);
      console.log(`  üîó ${sessionId} -> ${userId} (${jwt?.username || 'unknown'}) ${hasBattle ? '‚öîÔ∏è' : ''}`);
    }
    
    // ‚úÖ NOUVEAU: Debug des combats actifs
    if (this.activeBattleStates.size > 0) {
      console.log(`üîç [JWTManager] === COMBATS ACTIFS ===`);
      for (const [userId, battleState] of this.activeBattleStates.entries()) {
        const jwtData = this.getUserJWTData(userId);
        const timeElapsed = Math.round((Date.now() - battleState.timestamp) / 1000);
        console.log(`  ‚öîÔ∏è ${userId} (${jwtData?.username || 'unknown'}): ${battleState.battleId} - Tour ${battleState.turnNumber} - ${timeElapsed}s`);
      }
    }
  }
  
  /**
   * Obtenir les statistiques
   */
  getStats(): any {
    return {
      activeSessions: this.sessionToUser.size,
      activeUsers: this.userToSession.size,
      activeBattles: this.activeBattleStates.size, // ‚úÖ NOUVEAU
      mappings: Array.from(this.sessionToUser.entries()).map(([sessionId, userId]) => ({
        sessionId,
        userId,
        username: this.userJWTData.get(userId)?.username || 'unknown',
        hasActiveBattle: this.hasActiveBattle(userId) // ‚úÖ NOUVEAU
      })),
      battleStates: this.getAllActiveBattles() // ‚úÖ NOUVEAU
    };
  }

  /**
   * ‚úÖ NOUVEAU: M√©thode utilitaire pour debug admin
   */
  debugBattleStates(): void {
    console.log(`üîç [JWTManager] === DEBUG BATTLE STATES ===`);
    console.log(`‚öîÔ∏è Total combats: ${this.activeBattleStates.size}`);
    
    if (this.activeBattleStates.size === 0) {
      console.log(`  Aucun combat actif`);
      return;
    }
    
    for (const [userId, battleState] of this.activeBattleStates.entries()) {
      const jwtData = this.getUserJWTData(userId);
      const timeElapsed = Math.round((Date.now() - battleState.timestamp) / 1000);
      const isExpired = !this.hasActiveBattle(userId);
      
      console.log(`  üë§ ${jwtData?.username || userId}:`);
      console.log(`    üÜî Battle ID: ${battleState.battleId}`);
      console.log(`    üéÆ Type: ${battleState.battleType}`);
      console.log(`    üìä Phase: ${battleState.phase} | Tour: ${battleState.turnNumber}`);
      console.log(`    ‚è∞ Temps: ${timeElapsed}s ${isExpired ? '(EXPIR√â)' : ''}`);
      console.log(`    üêæ Pok√©mon: ${battleState.player1?.pokemon?.name} vs ${battleState.player2?.pokemon?.name}`);
    }
  }

  /**
 * ‚úÖ NOUVEAU: Gestion auto-reset des qu√™tes √† la reconnexion
 */
private async handleQuestAutoReset(username: string): Promise<void> {
  try {
    const resetResult = await this.questManager.handlePlayerReconnection(username);
    
    if (resetResult.resetOccurred) {
      console.log(`üîÑ [JWTManager] Auto-reset qu√™tes pour ${username}: ${resetResult.message}`);
    }
  } catch (error) {
    console.error(`‚ùå [JWTManager] Erreur auto-reset qu√™tes pour ${username}:`, error);
  }
}
}
