// server/src/managers/battle/BattleSequencer.ts
// Orchestrateur principal du syst√®me de combat - G√®re timing et s√©quences
// ‚úÖ VERSION FINALE ANTI-SPAM IA

import { 
  BattleContext, 
  BattleAction, 
  BattleEvent, 
  BattleSequence,
  BattlePokemonData,
  BATTLE_TIMINGS,
  ActionType,
  BattleEventType
} from './types/BattleTypes';
import { DamageCalculator } from './DamageCalculator';
import { TypeEffectiveness } from './TypeEffectiveness';
import { BattleMessageHandler, createBattleMessage, createAttackMessages } from './BattleMessageHandler';
import { BattleEffectSystem } from './BattleEffectSystem';

// Interfaces pour les handlers sp√©cialis√©s
export interface IBattleHandler {
  canHandle(context: BattleContext): boolean;
  processAction(action: BattleAction, context: BattleContext): Promise<BattleSequence>;
  shouldPlayAITurn(context: BattleContext): boolean;
  generateAIAction(context: BattleContext): Promise<BattleAction>;
}

// Interface pour les callbacks du BattleRoom
export interface IBattleRoomCallbacks {
  broadcastMessage(messageId: string, data: any): void;
  broadcastUpdate(updateData: any): void;
  updatePokemonHP(pokemonId: string, newHp: number): void;
  changeTurn(newTurn: string): void;
  endBattle(result: any): void;
  logBattleEvent(event: BattleEvent): void;
}

/**
 * ORCHESTRATEUR PRINCIPAL DU SYST√àME DE COMBAT
 * 
 * Responsabilit√©s :
 * - Router les actions vers les bons handlers (Solo/Multi)
 * - G√©rer le timing authentique Pok√©mon
 * - Coordonner les messages et animations
 * - Maintenir la s√©quence de combat
 */
export class BattleSequencer {
  
  private handlers: Map<string, IBattleHandler> = new Map();
  private activeSequences: Map<string, BattleSequence> = new Map();
  private battleRoomCallbacks?: IBattleRoomCallbacks;
  
  // Queue d'√©v√©nements temporis√©s
  private eventQueue: Array<{
    event: BattleEvent;
    executeAt: number;
    battleId: string;
  }> = [];
  
  // ‚úÖ NOUVEAU: Gestion compl√®te des timers par combat
  private activeTimers: Map<string, NodeJS.Timeout> = new Map();
  private battleTimers: Map<string, Set<string>> = new Map(); // battleId -> Set<timerId>
  
  constructor(callbacks?: IBattleRoomCallbacks) {
    this.battleRoomCallbacks = callbacks;
    console.log('üéº [BattleSequencer] Orchestrateur initialis√©');
  }
  
  // === REGISTRATION DES HANDLERS ===
  
  /**
   * Enregistre un handler pour un type de combat
   */
  registerHandler(type: string, handler: IBattleHandler): void {
    this.handlers.set(type, handler);
    console.log(`üîß [BattleSequencer] Handler "${type}" enregistr√©`);
  }
  
  /**
   * Trouve le bon handler pour un contexte de combat
   */
  private findHandler(context: BattleContext): IBattleHandler | null {
    for (const [type, handler] of this.handlers) {
      if (handler.canHandle(context)) {
        console.log(`üéØ [BattleSequencer] Handler "${type}" s√©lectionn√©`);
        return handler;
      }
    }
    
    console.warn(`‚ö†Ô∏è [BattleSequencer] Aucun handler trouv√© pour le contexte`, context.battleType);
    return null;
  }
  
  // === TRAITEMENT DES ACTIONS ===
  
  /**
   * M√âTHODE PRINCIPALE : Traite une action de combat
   */
  async processAction(action: BattleAction, context: BattleContext): Promise<boolean> {
    console.log(`üéÆ [BattleSequencer] === TRAITEMENT ACTION ===`);
    console.log(`üéØ Action: ${action.type} par ${action.playerId}`);
    console.log(`‚öîÔ∏è Combat: ${context.battleId} (${context.battleType})`);

    try {
      // 1. Trouver le handler appropri√©
      const handler = this.findHandler(context);
      if (!handler) {
        console.error(`‚ùå [BattleSequencer] Aucun handler disponible`);
        return false;
      }

      // 2.1 D√©clencher les hooks "d√©but de tour"
      const turnStartResults = BattleEffectSystem.triggerHook(context, "onTurnStart", { action });
      turnStartResults.forEach(res => {
        if (res?.message) console.log('üîî [EffectTurnStart]', res.message);
      });

      // 2. Traiter l'action via le handler
      const sequence = await handler.processAction(action, context);

      // 3. Ex√©cuter la s√©quence avec timing
      await this.executeSequence(sequence, context);

      // 4. V√©rifier si l'IA doit jouer
      if (handler.shouldPlayAITurn(context)) {
        await this.scheduleAITurn(handler, context);
      }

      return true;

    } catch (error) {
      console.error(`üí• [BattleSequencer] Erreur traitement action:`, error);
      return false;
    }
  }
  
  /**
   * ‚úÖ FINAL: Ex√©cute une s√©quence avec gestion compl√®te des timers
   */
  private async executeSequence(sequence: BattleSequence, context: BattleContext): Promise<void> {
    console.log(`üé¨ [BattleSequencer] Ex√©cution s√©quence "${sequence.sequenceId}"`);
    console.log(`üìã [BattleSequencer] ${sequence.events.length} √©v√©nements, dur√©e: ${sequence.totalDuration}ms`);
    
    this.activeSequences.set(context.battleId, sequence);
    
    let currentTime = 0;
    let hasBattleEndEvent = false;
    let battleEndData: any = null;
    
    for (const event of sequence.events) {
      // ‚úÖ V√âRIFIER si c'est un √©v√©nement de fin de combat
      if (event.type === 'battle_end') {
        hasBattleEndEvent = true;
        battleEndData = event.data;
        console.log(`üèÅ [BattleSequencer] √âV√âNEMENT FIN COMBAT d√©tect√©:`, battleEndData);
      }
      
      // Programmer l'√©v√©nement
      this.scheduleEvent(event, currentTime, context.battleId);
      currentTime += event.delay;
    }
    
    const sequenceTimerId = `sequence_${sequence.sequenceId}_${Date.now()}`;
    
    const timer = setTimeout(() => {
      try {
        this.removeTimer(sequenceTimerId, context.battleId);
        
        // ‚úÖ CRITIQUE: V√©rifier IMM√âDIATEMENT l'√©tat des Pok√©mon
        let battleShouldEnd = false;
        let endReason = '';
        let winnerPlayerId = '';
        
        context.participants.forEach(participant => {
          if (participant.team[0] && participant.team[0].currentHp <= 0) {
            battleShouldEnd = true;
            
            if (participant.isAI) {
              endReason = 'ai_pokemon_fainted';
              winnerPlayerId = context.participants.find(p => !p.isAI)?.sessionId || 'player1';
            } else {
              endReason = 'player_pokemon_fainted';
              winnerPlayerId = 'ai';
            }
            
            console.log(`üíÄ [BattleSequencer] Pok√©mon K.O. d√©tect√©: ${participant.team[0].name} (${participant.sessionId})`);
          }
        });
        
        // ‚úÖ SI POK√âMON K.O. OU √âV√âNEMENT FIN ‚Üí ARR√äTER TOUT DE SUITE
        if (battleShouldEnd || hasBattleEndEvent) {
          console.log(`üèÅ [BattleSequencer] Combat termin√©: ${endReason || '√©v√©nement'}`);
          
          context.phase = 'ended' as any;
          
          // D√©clencher fin combat via callbacks
          if (this.battleRoomCallbacks) {
            this.battleRoomCallbacks.endBattle({
              result: endReason.includes('player') ? 'defeat' : 'victory',
              winner: winnerPlayerId || battleEndData?.winner,
              reason: endReason || battleEndData?.reason || 'battle_end_event'
            });
          }
          
          // ‚úÖ ANNULER TOUS LES TIMERS ET ARR√äTER
          this.cancelAllBattleTimers(context.battleId);
          this.activeSequences.delete(context.battleId);
          console.log(`‚úÖ [BattleSequencer] Combat termin√©, TOUS les timers annul√©s`);
          return; // ‚úÖ SORTIR IMM√âDIATEMENT
        }
        
        // ‚úÖ SI COMBAT CONTINUE : Changer de tour correctement
        console.log(`üîÑ [BattleSequencer] Combat continue, changement de tour...`);
        console.log(`üîÑ [BattleSequencer] Tour actuel: ${context.currentPlayer}`);
        
        // ‚úÖ ALTERNANCE CORRECTE DES TOURS
        const playerSessionId = context.participants.find(p => !p.isAI)?.sessionId || 'player1';
        
        if (context.currentPlayer === playerSessionId) {
          // Tour du joueur ‚Üí Tour de l'IA
          context.currentPlayer = 'ai';
          console.log(`üîÑ [BattleSequencer] Nouveau tour: ai`);
          this.battleRoomCallbacks?.changeTurn('ai');
          
        } else if (context.currentPlayer === 'ai') {
          // Tour de l'IA ‚Üí Tour du joueur
          context.currentPlayer = playerSessionId;
          console.log(`üîÑ [BattleSequencer] Nouveau tour: ${playerSessionId}`);
          this.battleRoomCallbacks?.changeTurn(playerSessionId);
        }
        
        // ‚úÖ V√âRIFIER si l'IA doit jouer APR√àS le changement de tour
        const handler = this.findHandler(context);
        if (handler && handler.shouldPlayAITurn(context)) {
          console.log(`ü§ñ [BattleSequencer] Programmation tour IA apr√®s changement...`);
          
          const aiTimerId = `ai_turn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          const aiTimer = setTimeout(async () => {
            this.removeTimer(aiTimerId, context.battleId);
            
            // ‚úÖ DOUBLE V√âRIFICATION avant de jouer
            if (context.phase === 'ended' || !handler.shouldPlayAITurn(context)) {
              console.log(`ü§ñ [BattleSequencer] IA annul√©e - combat termin√© ou pas son tour`);
              return;
            }
            
            try {
              const aiAction = await handler.generateAIAction(context);
              await this.processAction(aiAction, context);
            } catch (error) {
              console.error(`ü§ñ [BattleSequencer] Erreur tour IA:`, error);
            }
          }, 2000);
          
          this.storeTimer(aiTimerId, aiTimer, context.battleId);
        }
        
      } catch (err) {
        console.error("[BattleSequencer] Erreur dans executeSequence:", err);
      }

      // Nettoyage normal
      this.activeSequences.delete(context.battleId);
      console.log(`‚úÖ [BattleSequencer] S√©quence "${sequence.sequenceId}" termin√©e`);
    }, sequence.totalDuration);
    
    this.storeTimer(sequenceTimerId, timer, context.battleId);
  }
  
  // ‚úÖ NOUVELLES M√âTHODES DE GESTION DES TIMERS
  
  /**
   * Stocke un timer avec son ID pour un combat
   */
  private storeTimer(timerId: string, timer: NodeJS.Timeout, battleId: string): void {
    this.activeTimers.set(timerId, timer);
    
    if (!this.battleTimers.has(battleId)) {
      this.battleTimers.set(battleId, new Set());
    }
    this.battleTimers.get(battleId)!.add(timerId);
    
    console.log(`‚è∞ [BattleSequencer] Timer ${timerId} stock√© pour combat ${battleId}`);
  }
  
  /**
   * Retire un timer de la liste
   */
  private removeTimer(timerId: string, battleId: string): void {
    this.activeTimers.delete(timerId);
    this.battleTimers.get(battleId)?.delete(timerId);
  }
  
  /**
   * ‚úÖ CRITIQUE: Annule TOUS les timers actifs d'un combat
   */
  private cancelAllBattleTimers(battleId: string): void {
    console.log(`üö´ [BattleSequencer] Annulation TOUS les timers pour combat ${battleId}`);
    
    const timerIds = this.battleTimers.get(battleId);
    if (timerIds) {
      let canceledCount = 0;
      
      timerIds.forEach(timerId => {
        const timer = this.activeTimers.get(timerId);
        if (timer) {
          clearTimeout(timer);
          this.activeTimers.delete(timerId);
          canceledCount++;
        }
      });
      
      console.log(`‚úÖ [BattleSequencer] ${canceledCount} timers annul√©s pour ${battleId}`);
      this.battleTimers.delete(battleId);
    }
  }
  
  /**
   * Programme un √©v√©nement √† ex√©cuter apr√®s un d√©lai
   */
  private scheduleEvent(event: BattleEvent, delay: number, battleId: string): void {
    const executeAt = Date.now() + delay;
    
    this.eventQueue.push({ event, executeAt, battleId });
    
    // ‚úÖ NOUVEAU: Timer avec ID unique
    const eventTimerId = `event_${event.eventId}_${Date.now()}`;
    
    const timer = setTimeout(() => {
      this.removeTimer(eventTimerId, battleId);
      this.executeEvent(event, battleId);
    }, delay);
    
    // ‚úÖ NOUVEAU: Stocker le timer d'√©v√©nement
    this.storeTimer(eventTimerId, timer, battleId);
    
    console.log(`‚è∞ [BattleSequencer] √âv√©nement "${event.type}" programm√© dans ${delay}ms`);
  }
  
  /**
   * Ex√©cute un √©v√©nement au bon moment
   */
  private executeEvent(event: BattleEvent, battleId: string): void {
    console.log(`üé¨ [BattleSequencer] Ex√©cution √©v√©nement: ${event.type}`);
    
    try {
      // Log de l'√©v√©nement
      if (this.battleRoomCallbacks) {
        this.battleRoomCallbacks.logBattleEvent(event);
      }
      
      // Traitement selon le type d'√©v√©nement
      switch (event.type) {
        case 'message':
          this.handleMessageEvent(event);
          break;
          
        case 'animation':
          this.handleAnimationEvent(event);
          break;
          
        case 'damage':
          this.handleDamageEvent(event);
          break;
          
        case 'heal':
          this.handleHealEvent(event);
          break;
          
        case 'status':
          this.handleStatusEvent(event);
          break;
          
        case 'faint':
          this.handleFaintEvent(event);
          break;
          
        case 'ui_update':
          this.handleUIUpdateEvent(event);
          break;
          
        case 'turn_change':
          this.handleTurnChangeEvent(event);
          break;
          
        case 'battle_end':
          this.handleBattleEndEvent(event);
          break;
          
        default:
          console.warn(`‚ö†Ô∏è [BattleSequencer] Type d'√©v√©nement non g√©r√©: ${event.type}`);
      }
      
    } catch (error) {
      console.error(`üí• [BattleSequencer] Erreur ex√©cution √©v√©nement:`, error);
    }
  }
  
  // === HANDLERS D'√âV√âNEMENTS ===
  
  private handleMessageEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks) return;
    
    this.battleRoomCallbacks.broadcastMessage('battleMessage', {
      messageId: event.data.messageId,
      message: event.message,
      variables: event.data.variables || {},
      timing: event.delay
    });
  }
  
  private handleAnimationEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks) return;
    
    this.battleRoomCallbacks.broadcastMessage('battleAnimation', {
      animation: event.animation,
      target: event.targetId,
      duration: event.delay,
      data: event.data
    });
  }
  
  private handleDamageEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks || !event.targetId) return;
    
    const damage = event.data.damage || 0;
    const newHp = Math.max(0, (event.data.currentHp || 0) - damage);
    
    this.battleRoomCallbacks.updatePokemonHP(event.targetId, newHp);
    this.battleRoomCallbacks.broadcastMessage('pokemonDamage', {
      pokemonId: event.targetId,
      damage: damage,
      newHp: newHp,
      effectiveness: event.data.effectiveness
    });
  }
  
  private handleHealEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks || !event.targetId) return;
    
    const healing = event.data.healing || 0;
    const newHp = Math.min(event.data.maxHp || 100, (event.data.currentHp || 0) + healing);
    
    this.battleRoomCallbacks.updatePokemonHP(event.targetId, newHp);
    this.battleRoomCallbacks.broadcastMessage('pokemonHeal', {
      pokemonId: event.targetId,
      healing: healing,
      newHp: newHp
    });
  }
  
  private handleStatusEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks) return;
    
    this.battleRoomCallbacks.broadcastMessage('statusChange', {
      pokemonId: event.targetId,
      status: event.data.status,
      applied: event.data.applied || true
    });
  }
  
  private handleFaintEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks || !event.targetId) return;
    
    this.battleRoomCallbacks.updatePokemonHP(event.targetId, 0);
    this.battleRoomCallbacks.broadcastMessage('pokemonFaint', {
      pokemonId: event.targetId
    });
  }
  
  private handleUIUpdateEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks) return;
    
    this.battleRoomCallbacks.broadcastUpdate(event.data);
  }
  
  private handleTurnChangeEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks) return;
    
    this.battleRoomCallbacks.changeTurn(event.data.newTurn);
    this.battleRoomCallbacks.broadcastMessage('turnChange', {
      newTurn: event.data.newTurn,
      turnNumber: event.data.turnNumber
    });
  }
  
  private handleBattleEndEvent(event: BattleEvent): void {
    if (!this.battleRoomCallbacks) return;
    
    this.battleRoomCallbacks.endBattle(event.data);
  }
  
  // === GESTION DE L'IA ===
  
  /**
   * Programme le tour de l'IA avec d√©lai authentique
   */
  private async scheduleAITurn(handler: IBattleHandler, context: BattleContext): Promise<void> {
    console.log(`ü§ñ [BattleSequencer] Programmation tour IA...`);
    
    // D√©lai r√©aliste pour l'IA (1-3 secondes)
    const aiThinkingTime = Math.random() * 2000 + 1000;
    
    // ‚úÖ NOUVEAU: Timer IA avec ID unique
    const aiScheduleTimerId = `ai_schedule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const aiScheduleTimer = setTimeout(async () => {
      this.removeTimer(aiScheduleTimerId, context.battleId);
      try {
        console.log(`ü§ñ [BattleSequencer] IA commence son tour`);
        
        // G√©n√©rer l'action IA
        const aiAction = await handler.generateAIAction(context);
        
        // Traiter l'action IA
        await this.processAction(aiAction, context);
        
      } catch (error) {
        console.error(`üí• [BattleSequencer] Erreur tour IA:`, error);
      }
    }, aiThinkingTime);
    
    // ‚úÖ NOUVEAU: Stocker le timer IA
    this.storeTimer(aiScheduleTimerId, aiScheduleTimer, context.battleId);
  }
  
  // === UTILITAIRES DE CR√âATION DE S√âQUENCES ===
  
  /**
   * Cr√©e une s√©quence d'attaque standard
   */
  createAttackSequence(
    attackerId: string,
    targetId: string,
    moveData: any,
    damageResult: any,
    context: BattleContext
  ): BattleSequence {
    const events: BattleEvent[] = [];
    let currentDelay = 0;
    
    const sequenceId = `attack_${attackerId}_${Date.now()}`;
    
    // 1. Message d'utilisation d'attaque
    const attackMessages = createAttackMessages(
      damageResult.attackerName,
      moveData.name,
      damageResult.effectiveness,
      damageResult.critical,
      attackerId !== context.currentPlayer
    );
    
    attackMessages.forEach(msg => {
      events.push({
        eventId: `msg_${events.length}`,
        type: 'message',
        timestamp: Date.now(),
        data: {
          messageId: msg.id,
          variables: msg.variables
        },
        message: msg.template,
        delay: currentDelay
      });
      currentDelay += msg.timing;
    });
    
    // 2. Animation d'attaque
    events.push({
      eventId: `anim_attack`,
      type: 'animation',
      timestamp: Date.now(),
      playerId: attackerId,
      targetId: targetId,
      data: {
        moveId: moveData.id,
        animation: moveData.animation || 'default_attack'
      },
      animation: moveData.animation || 'default_attack',
      delay: currentDelay
    });
    currentDelay += BATTLE_TIMINGS.MOVE_ANIMATION;
    
    // 3. D√©g√¢ts (si applicable)
    if (damageResult.finalDamage > 0) {
      events.push({
        eventId: `damage_${targetId}`,
        type: 'damage',
        timestamp: Date.now(),
        targetId: targetId,
        data: {
          damage: damageResult.finalDamage,
          currentHp: damageResult.targetCurrentHp,
          effectiveness: damageResult.effectiveness
        },
        delay: currentDelay
      });
      currentDelay += BATTLE_TIMINGS.DAMAGE_ANIMATION;
    }
    
    // 4. K.O. si n√©cessaire
    if (damageResult.targetFainted) {
      const faintMessage = createBattleMessage('MSG_POKEMON_FAINTED', {
        pokemon: damageResult.targetName
      });
      
      if (faintMessage) {
        events.push({
          eventId: `faint_msg`,
          type: 'message',
          timestamp: Date.now(),
          data: {
            messageId: faintMessage.id,
            variables: faintMessage.variables
          },
          message: faintMessage.template,
          delay: currentDelay
        });
        currentDelay += faintMessage.timing;
      }
      
      events.push({
        eventId: `faint_${targetId}`,
        type: 'faint',
        timestamp: Date.now(),
        targetId: targetId,
        data: {},
        delay: currentDelay
      });
      currentDelay += BATTLE_TIMINGS.MESSAGE_DISPLAY;
    }
    
    return {
      sequenceId,
      events,
      totalDuration: currentDelay,
      priority: 80
    };
  }
  
  /**
   * Cr√©e une s√©quence de capture
   */
  createCaptureSequence(
    playerId: string,
    targetId: string,
    ballType: string,
    result: any,
    context: BattleContext
  ): BattleSequence {
    const events: BattleEvent[] = [];
    let currentDelay = 0;
    
    const sequenceId = `capture_${playerId}_${Date.now()}`;
    
    // Messages de capture
    const captureMessages = BattleMessageHandler.generateCaptureSequence(
      result.trainerName,
      ballType,
      result.pokemonName,
      result.shakeCount,
      result.success,
      result.criticalCapture
    );
    
    captureMessages.forEach(msg => {
      events.push({
        eventId: `capture_msg_${events.length}`,
        type: 'message',
        timestamp: Date.now(),
        data: {
          messageId: msg.id,
          variables: msg.variables
        },
        message: msg.template,
        delay: currentDelay
      });
      currentDelay += msg.timing;
    });
    
    // Animation finale
    if (result.success) {
      events.push({
        eventId: `capture_success`,
        type: 'animation',
        timestamp: Date.now(),
        targetId: targetId,
        data: { captured: true },
        animation: 'capture_success',
        delay: currentDelay
      });
    }
    
    return {
      sequenceId,
      events,
      totalDuration: currentDelay,
      priority: 90
    };
  }
  
  /**
   * Cr√©e une s√©quence de changement de tour
   */
  createTurnChangeSequence(
    newTurn: string,
    turnNumber: number,
    context: BattleContext
  ): BattleSequence {
    const events: BattleEvent[] = [];
    const sequenceId = `turn_change_${Date.now()}`;
    
    // Message "√Ä votre tour"
    if (newTurn === context.participants[0]?.sessionId) {
      const turnMessage = createBattleMessage('MSG_TURN_START');
      if (turnMessage) {
        events.push({
          eventId: `turn_msg`,
          type: 'message',
          timestamp: Date.now(),
          data: {
            messageId: turnMessage.id,
            variables: turnMessage.variables
          },
          message: turnMessage.template,
          delay: 0
        });
      }
    }
    
    // Changement de tour
    events.push({
      eventId: `turn_change`,
      type: 'turn_change',
      timestamp: Date.now(),
      data: {
        newTurn,
        turnNumber
      },
      delay: BATTLE_TIMINGS.TURN_TRANSITION
    });
    
    return {
      sequenceId,
      events,
      totalDuration: BATTLE_TIMINGS.TURN_TRANSITION + BATTLE_TIMINGS.MESSAGE_DISPLAY,
      priority: 60
    };
  }
  
  // === GESTION DES CALLBACKS ===
  
  /**
   * D√©finit les callbacks du BattleRoom
   */
  setCallbacks(callbacks: IBattleRoomCallbacks): void {
    this.battleRoomCallbacks = callbacks;
  }
  
  // === NETTOYAGE ===
  
  /**
   * ‚úÖ AM√âLIOR√â: Annule toutes les s√©quences en cours pour un combat
   */
  cancelBattleSequences(battleId: string): void {
    console.log(`üõë [BattleSequencer] Annulation s√©quences pour ${battleId}`);
    
    // ‚úÖ NOUVEAU: Annuler tous les timers du combat
    this.cancelAllBattleTimers(battleId);
    
    // Nettoyer les s√©quences actives
    this.activeSequences.delete(battleId);
    
    // Nettoyer la queue d'√©v√©nements
    this.eventQueue = this.eventQueue.filter(item => item.battleId !== battleId);
  }
  
  /**
   * ‚úÖ AM√âLIOR√â: Nettoyage complet
   */
  destroy(): void {
    console.log(`üíÄ [BattleSequencer] Destruction...`);
    
    // Annuler tous les timers
    for (const timer of this.activeTimers.values()) {
      clearTimeout(timer);
    }
    
    // Nettoyer toutes les collections
    this.activeTimers.clear();
    this.battleTimers.clear();
    this.activeSequences.clear();
    this.eventQueue = [];
    this.handlers.clear();
    
    console.log(`‚úÖ [BattleSequencer] D√©truit`);
  }
  
  // === DEBUG ===
  
  /**
   * ‚úÖ AM√âLIOR√â: Obtient l'√©tat actuel du sequencer
   */
  getDebugInfo(): any {
    return {
      handlersCount: this.handlers.size,
      activeSequencesCount: this.activeSequences.size,
      activeTimersCount: this.activeTimers.size,
      battleTimersCount: this.battleTimers.size,
      eventQueueLength: this.eventQueue.length,
      hasCallbacks: !!this.battleRoomCallbacks
    };
  }
}

export default BattleSequencer;
